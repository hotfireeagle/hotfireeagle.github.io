<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜游</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-21T09:11:17.536Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hahahai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于滚动吸顶</title>
    <link href="http://yoursite.com/2019/04/18/%E5%85%B3%E4%BA%8E%E6%BB%9A%E5%8A%A8%E5%90%B8%E9%A1%B6/"/>
    <id>http://yoursite.com/2019/04/18/关于滚动吸顶/</id>
    <published>2019-04-18T07:03:22.000Z</published>
    <updated>2019-04-21T09:11:17.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 所有人其实就是一个整体，别人的不幸就是你的不幸。不要以为丧钟为谁而鸣，它就是为你而鸣。</p></blockquote><h3 id="1-题外话"><a href="#1-题外话" class="headerlink" title="1.题外话"></a>1.题外话</h3><p>说句题外话，请问对于下面的代码是输出什么信息呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    *, html, body &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">        padding: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.p1</span> &#123;</span></span><br><span class="line"><span class="undefined">        position: relative;</span></span><br><span class="line"><span class="undefined">        width: 100vw;</span></span><br><span class="line"><span class="undefined">        height: 300px;</span></span><br><span class="line"><span class="undefined">        padding: 60px;</span></span><br><span class="line"><span class="undefined">        border: 1px solid green;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.p2</span> &#123;</span></span><br><span class="line"><span class="undefined">        width: 100%;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        border: 1px solid red;</span></span><br><span class="line"><span class="undefined">        padding: 20px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.c</span> &#123;</span></span><br><span class="line"><span class="undefined">        width: 100%;</span></span><br><span class="line"><span class="undefined">        height: 50px;</span></span><br><span class="line"><span class="undefined">        background: yellow;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"p1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"p2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> c = <span class="built_in">document</span>.querySelector(<span class="string">'.c'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'c.offsetTop'</span>, c.offsetTop);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>求元素c的offsetTop？是20吗还是21？答案是都不是，为什么呢？因为对于offsetTop的定义是用来获取其相对于自己的定位父级顶部的距离，那么问题来了，这个定位父级是怎么定义的呢？答案就是与当前元素最近的position != static的元素。因此，对于上面这种场合来说，输出的结果应该是81px。</p><p>下面言归正传，首先介绍使用position: sticky的形式实现滚动置顶。</p><h3 id="2-黏性定位之position-sticky"><a href="#2-黏性定位之position-sticky" class="headerlink" title="2.黏性定位之position:sticky"></a>2.黏性定位之position:sticky</h3><p>先看黏性定位的定义：结合了 position:relative 和 position:fixed 两种定位功能于一体的特殊定位，适用于一些特殊场景。元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p><p>接下来带着问题加深理解下新朋友黏性定位(position: sticky):</p><p>问1.黏性定位position:sticky会有这么样的展示效果？</p><p>答：首先了解下使用方法，要使用黏性定位的话那么使用黏性定位的元素还需要搭配定位属性top,bottom,left,right四者之一。并且使用黏性定位的元素其任意一个父元素（包括祖先元素）都不能够将overflow设置为除了visible之外的其它值，否则的话黏性定位将会没有效果，所以如果某个时候你发现你写的黏性定位不起作用的话，先检查一下是否是因为设置黏性定位元素的父元素或者是父元素是不是设置了overflow为非visible之外的值。下面通过一个例子讨论展示效果是怎么呈现的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="undefined">  width: 100vw;</span></span><br><span class="line"><span class="undefined">  height: 200vh;</span></span><br><span class="line"><span class="undefined">  margin-top: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="undefined">  box-sizing: border-box;</span></span><br><span class="line"><span class="undefined">  width: 100vw;</span></span><br><span class="line"><span class="undefined">  height: 50px;</span></span><br><span class="line"><span class="undefined">  background: yellow;</span></span><br><span class="line"><span class="undefined">  position: sticky;</span></span><br><span class="line"><span class="undefined">  top: 60px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们设置了header的阈值是60px，这就表明着当header距离视窗的高度小于等于60px的时候，此时header将会固定在离视窗60px处的位置。这也就意味着只需要container滚动40px就能看到这种滚动置顶的效果。</p><p>问2.黏性定位position:sticky的元素的定位上下文是谁？</p><p>答：就视觉表现来看，我将其理解为两种行为：分别是距离自己最近的父级块元素和视窗本身。那么这两种行为在什么时候触发呢？触发了黏性定位所设置的那个阈值的时候，如果当黏性定位的元素距离视窗的距离大于阈值的话，那么他的定位上下文就是父元素本身；如果当黏性定位的元素距离视窗的距离小于阈值的话，那么他的定位上下文就是视窗自身了。</p><p>黏性定位就使用方法来说还是很方便的，但是兼容性问题不是特别好。</p><h3 id="3-根据offsetTop来实现滚动吸顶"><a href="#3-根据offsetTop来实现滚动吸顶" class="headerlink" title="3.根据offsetTop来实现滚动吸顶"></a>3.根据offsetTop来实现滚动吸顶</h3><p>在前面我们也提到过了，那就是一个元素的offsetTop值是相对于其定位父级的距离值，这个定位父级的position值为非static的父级元素或者body。那么问题来了，如果我们需要滚动置顶的元素的父级或者祖先级别元素有某个使用了定位属性的话，那么就会出现滚动吸顶不准确的情况了，如何解决？思路大致如下所示：不断调用offsetTop，没调用一次向上延伸到定位父级元素上面。直到到了body为止，下面介绍一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">html, body &#123;</span></span><br><span class="line"><span class="undefined">  margin: 0;</span></span><br><span class="line"><span class="undefined">  padding: 0;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="undefined">  position: relative;</span></span><br><span class="line"><span class="undefined">  margin-top: 60px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="undefined">  width: 100vw;</span></span><br><span class="line"><span class="undefined">  height: 150px;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">background</span>: <span class="selector-id">#f0f0f0</span>;</span></span><br><span class="line"><span class="undefined">  margin-bottom: 20px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="undefined">  width: 100vw;</span></span><br><span class="line"><span class="undefined">  height: 50px;</span></span><br><span class="line"><span class="undefined">  background: orange;</span></span><br><span class="line"><span class="undefined">  margin-bottom: 20px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.fixedHeader</span> &#123;</span></span><br><span class="line"><span class="undefined">  position: fixed;</span></span><br><span class="line"><span class="undefined">  top: 0;</span></span><br><span class="line"><span class="undefined">  left: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">computeOffset</span> (<span class="params">ele, direction</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> offsetY = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> offsetX = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">while</span> (ele != <span class="built_in">window</span>.document.body &amp;&amp; ele != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="undefined">    offsetY += ele.offsetTop;</span></span><br><span class="line"><span class="undefined">    offsetX += ele.offsetLeft;</span></span><br><span class="line"><span class="undefined">    ele = ele.offsetParent;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (direction == <span class="string">'left'</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> offsetX;</span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> offsetY;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkClassNameExists</span> (<span class="params">ele, className</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(ele.classList);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (arr.indexOf(className) !== <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">fixedHeader</span> (<span class="params">ele</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (checkClassNameExists(ele, <span class="string">'fixedHeader'</span>)) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">  ele.classList.add(<span class="string">'fixedHeader'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">normalHeader</span> (<span class="params">ele</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!checkClassNameExists(ele, <span class="string">'fixedHeader'</span>)) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">  ele.classList.remove(<span class="string">'fixedHeader'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> headerEle = <span class="built_in">document</span>.querySelector(<span class="string">'.header'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> truelyOffset = computeOffset(headerEle);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> scrollY = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (scrollY &gt; truelyOffset) &#123;</span></span><br><span class="line"><span class="undefined">      fixedHeader(headerEle);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="undefined">      normalHeader(headerEle);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要避免这里是相对于定位父级的offset，所以这里一直在取其相对的定位父级，直到到了body或者到了null的时候。</p><p>拓展：使用document.documentElement.style可以获取到浏览器所支持的css属性列表数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 所有人其实就是一个整体，别人的不幸就是你的不幸。不要以为丧钟为谁而鸣，它就是为你而鸣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-题外话&quot;&gt;&lt;a href=&quot;#1-题外话&quot; class=&quot;headerlink&quot; title=&quot;1.题
      
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>从一道题目谈谈跨域</title>
    <link href="http://yoursite.com/2019/04/09/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/04/09/从一道题目谈谈跨域/</id>
    <published>2019-04-08T16:25:28.000Z</published>
    <updated>2019-04-16T15:17:04.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>那个时代的摇滚让人热泪盈眶。</p></blockquote><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>跨域是浏览器限制的，在xhr请求中，跨域问题尤为常见。浏览器针对跨域请求的策略：一个域名的JS，在未经允许的情况下，是不得读取另外一个域名的内容的。跨域问题不能够单单通过前端进行解决。</p><p>关于跨域常见的误区：</p><p>误区一：是服务端阻止的你跨域。NO! 上面也提到的，跨域是浏览器应用同源策略所限制的。</p><h3 id="2-例子1：没有同源策略限制的接口请求"><a href="#2-例子1：没有同源策略限制的接口请求" class="headerlink" title="2.例子1：没有同源策略限制的接口请求"></a>2.例子1：没有同源策略限制的接口请求</h3><p>这里考虑使用cookie作为登录态的处理方法。假如你登录了a.com的话，然后接着登录b.com的话。并且这个b.com背地里偷偷摸摸做了一些暗操作：执行a.com网站的某个操作；我们知道对于cookie来说，浏览器会将它自动放到请求头里面的，所以假设没有同源策略的限制的话，那么b网站在背后偷偷对网站a发起请求那么就是可能的。但这样的操作所带来的问题不言而喻，因此基于同源策略的跨域解决是很有必要的。</p><h3 id="3-解决跨域的方案之使用JSONP技术"><a href="#3-解决跨域的方案之使用JSONP技术" class="headerlink" title="3.解决跨域的方案之使用JSONP技术"></a>3.解决跨域的方案之使用JSONP技术</h3><p>何谓JSONP技术？大意就是指使用script标签向被跨域的服务器发起请求。当服务器收到这个请求后，便返回一串js代码，前端页面在收到服务端所返回的数据之后便能够执行这个请求。为什么JSONP技术能够用来进行跨域呢？因为script标签就是不受浏览器的跨域限制哇。接下来举一个例子来使用JSONP技术来解决：在将会跨域的情况下，服务端根据客户端传过来的type返回对应的列表数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 这是前端页面代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> cb = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!arr || <span class="built_in">Object</span>.prototype.toString.call(arr) != <span class="string">"[object Array]"</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="javascript">  arr.map(<span class="function"><span class="params">str</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span></span><br><span class="line"><span class="undefined">    p.innerText = str;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(p);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https:abcdwillcors.com/jsonp?type=article&amp;cb=cb"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意query参数，这在JSONP中告诉了后端自己改怎么处理，处理完了该怎么返回。接下来看看后端相关代码（使用express）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mockDbQuery = <span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'article'</span>:</span><br><span class="line">      result = [<span class="string">'article1'</span>, <span class="string">'article2'</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'video'</span>:</span><br><span class="line">      result = [<span class="string">'video1'</span>, <span class="string">'video2'</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = [<span class="string">'article1'</span>, <span class="string">'video1'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> query = req.query;</span><br><span class="line">  res.cookie(<span class="string">'sessionid'</span>, <span class="string">'mock one'</span>);</span><br><span class="line">  <span class="keyword">let</span> result = mockDbQuery(query.type || <span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> response = <span class="string">`<span class="subst">$&#123;query.cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(result)&#125;</span>)`</span>;            <span class="comment">// 客户端接受到的应该是未经解释过的代码</span></span><br><span class="line">  res.send(response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>上面的例子便是使用JSONP技术来完成跨域功能处理。运行之后，前端将能够渲染出后端所返回的列表数据。</p><h3 id="4-通过表单Form来解决POST请求跨域问题"><a href="#4-通过表单Form来解决POST请求跨域问题" class="headerlink" title="4.通过表单Form来解决POST请求跨域问题"></a>4.通过表单Form来解决POST请求跨域问题</h3><p>对于上面的jsonp请求，很明显它支持GET请求的形式。尽管也能够携带有足够的参数，但是是满足不了POST请求的。为什么Form表单也没有被浏览器现在跨域？因为该种方式下，发起跨域的页面是无法获取新页面的内容的。而xhr确是有能力读取新页面返回的内容的。下面是一个使用form进行POST请求解决跨域的场景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 这是前端页面的代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> mockPost = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span></span><br><span class="line"><span class="javascript">  iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">  form.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">  iframe.name = <span class="string">'mockPost'</span>;</span></span><br><span class="line"><span class="undefined">  form.action = url;</span></span><br><span class="line"><span class="javascript">  form.method = <span class="string">'post'</span>;</span></span><br><span class="line"><span class="javascript">  form.target = iframe.name;              <span class="comment">// 避免在新页面中打开或者本页面刷新</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span></span><br><span class="line"><span class="undefined">    input.name = key;</span></span><br><span class="line"><span class="undefined">    input.value = data[key];</span></span><br><span class="line"><span class="undefined">    form.appendChild(input.cloneNode());</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(form);</span></span><br><span class="line"><span class="undefined">  form.submit();</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.removeChild(form);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">mockPost(<span class="string">'http://apiwillcors/apiPost'</span>, &#123; <span class="attr">name</span>: <span class="string">'3h'</span>, <span class="attr">sex</span>: <span class="string">'man'</span> &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来是后端部分的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接着上个jsonp中的express例子</span></span><br><span class="line">router.post(<span class="string">'/apiPost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = req.body;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'body is'</span>, body);                                     <span class="comment">// 打印出 &#123; name: '3h', sex: 'man' &#125;</span></span><br><span class="line">  res.send(<span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-使用CORS协议处理跨域问题"><a href="#5-使用CORS协议处理跨域问题" class="headerlink" title="5.使用CORS协议处理跨域问题"></a>5.使用CORS协议处理跨域问题</h3><p>CORS基本介绍：CORS的全程叫做cross origin resource sharing，翻译过来也就是叫做跨域资源共享。CORS协议用来避开浏览器的同源策略，是JSONP协议的现代版本，CORS能够更好的支持各种HTTP方法以及XMLHttpRequest。</p><p>CORS相比JSONP，具有下面这些特点：</p><p>1.CORS支持所有类型的HTTP方法，能够搭配XMLHttpRequest进行使用，能够更好的处理服务器的响应结果。</p><p>2.相比JSONP，CORS兼容性可能会没那么好。</p><p>CORS协议是被浏览器所使用的，所以不要奇怪为什么在postman里面是不受CORS限制的。CORS的实现思路是使用自定义的HTTP请求头来携带双方所规定好的请求头信息，这部分请求头信息被用于双方进行相互了解。如果浏览器支持CORS协议的话，但是双方的请求头信息不符合所约定的规则的话，那么也会出现跨域问题。</p><p>在CORS协议中，请求分为两种，分别是简单请求和非简单请求。满足下面这些限制条件的请求就属于简单请求：</p><p>(1).请求方法为GET，POST，HEAD中的一种；（2）.HTTP头信息只能有Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type，而且Content-Type的值只能是application/x-www-form-urlencoded，multiple/form-data，text/plain。</p><p>对于简单请求来说，后端需要设置Access-Control-Origin响应头的值为*，如下所示（使用express举例）:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接着上面的express例子</span></span><br><span class="line">router.get(<span class="string">'/cors'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.set(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  res.cookie(<span class="string">'tokenId'</span>, <span class="number">2</span>);</span><br><span class="line">  res.send(<span class="string">'fine'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是客户端的代码</span></span><br><span class="line">fetch(<span class="string">'localhost:port/jsonp/cors'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'res is'</span>, res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>很显然这个请求属于一个简单请求，并且我们的服务端还设置了Access-Control-Allow-Origin的值为*，意思就是告诉浏览器所有的Origin都能够访问我。因此此时即便是跨域了，但是也还是能够获取到数据的。</p><p>思考问题一：如果把Access-Control-Allow-Origin的值设置为某个具体的域名abc.com的话，并且发起跨域请求的网站的Origin并不是abc.com的话会发生什么情况？答案是会发生跨域，但是此时浏览器是能够收到服务器的正确响应结果的，只是不能通过js获取到返回值而已。把Access-Control-Allow-Origin值给取消所带来的结果也是一样。</p><p>接下来考虑对于非简单请求的CORS处理情况：</p><p>对于非简单请求来说，后端设置的请求头里面必不可少的信息是Access-Control-Allow-Origin(只要涉及到CORS，那个这个响应头信息必不可少)，Access-Control-Request-Method，Access-Control-Allow-Headers这几个字段。是不是后端设置这个请求支持了非简单请求，那么前端就必须使用非简单请求方式发起呢？答案是不是的，你仍旧可以使用简单请求方式向这个接口发起请求，至于能否拿到正确的数据这就需要看后端的处理方式的。</p><p>下面看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里使用的是all，不支持采用这种方法，仅仅作为演示使用</span></span><br><span class="line">router.all(<span class="string">'corsm'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.set(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  res.set(<span class="string">'Access-Control-Allow-Method'</span>, <span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>);</span><br><span class="line">  res.set(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Origin,Accept,t'</span>);</span><br><span class="line">  res.send(<span class="string">'fine'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端代码</span></span><br><span class="line">fetch(<span class="string">'http://someCom.com/jsonp/corsm'</span>, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    t: <span class="string">'test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res is'</span>, res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>稍微解释一下上面这个例子：为什么服务端是all？这里主要是为了省事，对于非简单请求来说，首先浏览器会先发送一个OPTIONS请求，这叫做预检请求，只有等预检请求通过了才会接着发送后面的正式请求；而这里使用all只是为了省事处理，不推荐。接着在说下前端代码，为了表示这是个非简单请求，这里显式的加上了请求头t来表示这不是一个简单请求。如果把t这个自定义请求头给去掉的话，那么就是走的简单请求了，此时仍旧能够正常拿到响应数据。</p><h3 id="6-使用代理来解决跨域问题"><a href="#6-使用代理来解决跨域问题" class="headerlink" title="6.使用代理来解决跨域问题"></a>6.使用代理来解决跨域问题</h3><p>我们知道跨域是浏览器所导致的情况，因此如果需要解决这个问题的话，那么我们可以引入中间件来进行请求转发。这就要求中间件和前端网页是在同源下面的，而后端接口api不同源没关系，我们使用中间件将请求转发到真正的后端接口上面，此时就巧妙的避免了跨域问题。这种解决方法很普遍采用，并且这个中间件大多数都是NGINX。</p><p>我们可以看看下面这个配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:5050/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /someapi/somePath/ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:20000/somePath/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面这个配置，当你访问这个域名，经过若干步骤后到达了服务器后，默认被转发到了服务器自身的5050端口上面，这个端口被中间件给监听着，它负责静态文件分发，当你的前端页面发起一个api请求后，此时若是路由匹配上了nginx所设置的/someapi/somePath/的话，那么会被转接给本机20000/somePath上面。在这个例子中，使用两个中间件，第一个便是nginx转发api请求，第二个便是5050端口上的中间件负责静态文件服务。可以整合为一个中间件，接口分发和静态文件分发都可以交给nginx承担。</p><h3 id="7-postMessage解决跨域问题"><a href="#7-postMessage解决跨域问题" class="headerlink" title="7.postMessage解决跨域问题"></a>7.postMessage解决跨域问题</h3><h3 id="8-canvas中的跨域问题"><a href="#8-canvas中的跨域问题" class="headerlink" title="8.canvas中的跨域问题"></a>8.canvas中的跨域问题</h3><p>我们知道对于img标签来说，当然是不存在跨域问题的，比如你可以像下面这样使用而无需担心跨域问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'http://timgsa.baidu.com/timg?image'</span>;</span><br></pre></td></tr></table></figure><p>但是如果要是把这张图用于进行canvas绘制的话，并且调用canvasInstance.getImageData方法的话，那么便会出现跨域问题，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分报错原因：The canvas has been tainted by cross-origin data.</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    context.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">'https://avatars3.githubusercontent.com/u/496048?s=120&amp;v=4%27;'</span>;</span><br></pre></td></tr></table></figure><p>为什么把图片绘制出来就没问题，调用getImageData或者toDataURL方法就会报跨域问题呢？因为此时会泄露信息。那么要怎么解决这个问题呢？告诉浏览器我请求别的域的图片的时候不用携带那个域名的敏感性信息即可，具体就是使用img.crossOrigin值即可。它有两个值可选，分别是’anonymous’和’use-credentials’这两个，第二个就表明我会携带敏感信息。需要注意的是，利用js对crossOrigin属性进行赋值的话，那么只要不是’use-credentials’那么就是表明是’anonymous’。所以对于上面这个问题，使用下面方式便可以解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>);                  <span class="comment">// 调用canvas绘制图片</span></span><br><span class="line">  context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);    <span class="comment">// 此时能够正常获取到图片信息，不受干扰</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line">&#125;;</span><br><span class="line">img.crossOrigin = <span class="string">'anonymous'</span>;</span><br><span class="line">img.src = <span class="string">'https://avatars3.githubusercontent.com/u/496048?s=120&amp;v=4%27;'</span>;</span><br></pre></td></tr></table></figure><p>上面这招算银弹吗？已经能够满足大部分使用场景了，但是对于ie10浏览器以下还是会有兼容性问题，所以该怎么解决呢？答案是利用ajax和URL.createObjectURL()方法曲线救国。</p><p>具体做法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = URL.createObjectURL(<span class="keyword">this</span>.response);</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    context.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    context.getImageData(<span class="number">0</span>, <span class="number">0</span> , <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.src = url;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'https://avatars3.githubusercontent.com/u/496048?s=120&amp;v=4%27;'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>这种方法的缺点就是会多一个请求，但是兼容性挺好。</p><h3 id="9-问题"><a href="#9-问题" class="headerlink" title="9.问题"></a>9.问题</h3><p>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</p><p>用来实现跨域，而且兼容性很好。如何用它来实现跨域？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;那个时代的摇滚让人热泪盈眶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;跨域是浏览
      
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>证书可信任</title>
    <link href="http://yoursite.com/2019/04/02/%E8%AF%81%E4%B9%A6%E5%8F%AF%E4%BF%A1%E4%BB%BB/"/>
    <id>http://yoursite.com/2019/04/02/证书可信任/</id>
    <published>2019-04-02T02:06:24.000Z</published>
    <updated>2019-04-02T04:00:01.044Z</updated>
    
    <content type="html"><![CDATA[<p><a href="详细内容参见知乎专栏">https://zhuanlan.zhihu.com/p/25587986</a></p><h3 id="1-浏览器如何验证您的证书是有效的？"><a href="#1-浏览器如何验证您的证书是有效的？" class="headerlink" title="1.浏览器如何验证您的证书是有效的？"></a>1.浏览器如何验证您的证书是有效的？</h3><p>主要分为下面几个流程：</p><ul><li><p>1.client hello阶段，此时用户会在浏览器地址栏输入一个地址，然后浏览器会解析输入的域名对应到其相对应的IP地址上面，接着浏览器和解析得到的IP地址所对应机器的443端口进行通话（当然如果你转到了其它端口的话，那么就会使用其它端口）。这步也叫做TLS协议的握手请求。</p></li><li><p>2.server hello阶段，服务器收到客户端在TLS协议的握手请求后，会根据客户端的host在自己机器上面寻找对应的证书文件，然后将证书等信息再返回给客户端。</p></li><li><p>3.客户端在收到需要访问网站的证书信息后，会验证证书是否有效。验证步骤主要分为下面几个：验证证书有效期；验证证书域名（和浏览器地址栏域名是否相同）；验证证书吊销状态；验证证书颁发机构；如果颁发机构是中间证书的话，接着验证中间证书的有效期，一直验证到最后最后一层证书，如果最后一层证书是在操作系统或浏览器内置的话，那么证书就是可信的，否则就是自签名的HTTPS证书；</p></li><li><p>4.这个时候证书验证基本就结束了，如果验证通过的话那么浏览器就显示正常；验证不通过浏览器会进行相应提示。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;详细内容参见知乎专栏&quot;&gt;https://zhuanlan.zhihu.com/p/25587986&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-浏览器如何验证您的证书是有效的？&quot;&gt;&lt;a href=&quot;#1-浏览器如何验证您的证书是有效的？&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>从一道作用域题目聊聊作用域</title>
    <link href="http://yoursite.com/2019/03/29/%E4%BB%8E%E4%B8%80%E9%81%93%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%A2%98%E7%9B%AE%E8%81%8A%E8%81%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/03/29/从一道作用域题目聊聊作用域/</id>
    <published>2019-03-29T04:10:04.000Z</published>
    <updated>2019-03-29T08:22:43.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目："><a href="#1-题目：" class="headerlink" title="1.题目："></a>1.题目：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;                 <span class="comment">// 步骤0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)          <span class="comment">// 步骤1</span></span><br><span class="line">    a = <span class="number">5</span>                   <span class="comment">// 步骤1-1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a)   <span class="comment">// 步骤2</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;             <span class="comment">// 步骤2-1</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)          <span class="comment">// 步骤3</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="2-分析："><a href="#2-分析：" class="headerlink" title="2.分析："></a>2.分析：</h3><p>我们知道js的运行流程分为两个部分，预编译期和执行期；先是预编译期接着是执行期。而在预编译期会进行词法分析等，预编译期导致的一个和我们强关联的结果那就是-变量声明提升。同时在es6出来之后，需要明白使用let和const声明的变量不会存在变量提升。</p><p>所以在上面预编译期间存在两处变量提升，分别是window.a 和 local.a。因此执行步骤1的时候此时由于Local作用域里面已经有变量a了，所以输出undefined。接下来运行步骤1-1，同样由于在预编译期间所导致的local.a，因此不会继续向上层作用域查找变量a。步骤0自然是挂载到了全局作用域下面。执行步骤2-1的时候，相当于local.a = 20;到这里基本就解释完毕了。</p><p>总结：var声明的变量在预编译期间会经历声明提升；如果在当前作用域没有找到某个变量，会向上层作用域进行查找，直到找到全局作用域，若是此时还没有找到的话，那么剩下的就是reference error了。</p><h3 id="3-拓展，立执行函数的作用域分析："><a href="#3-拓展，立执行函数的作用域分析：" class="headerlink" title="3.拓展，立执行函数的作用域分析："></a>3.拓展，立执行函数的作用域分析：</h3><p><strong>目前断言，立执行函数的作用域就是window</strong>。问题为什么在jQuery的立执行函数中需要传入window呢？答案：使得在jQuery代码块中访问window时，不需要将作用域链回退到顶层作用域，实现更快的访问window。</p><p>所以可以看一下下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果输出为 10 50 20</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;         </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    a = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="4-拓展2：理解变量提升"><a href="#4-拓展2：理解变量提升" class="headerlink" title="4.拓展2：理解变量提升"></a>4.拓展2：理解变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出1</span></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，对于函数表达式来说，从创建，赋值都被提升了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出：报错TypeError: fun is not a function</span></span><br><span class="line">fun();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面可以看出，对于函数赋值语句来说，函数变量创建存在提升，但是赋值并不存在。</p><p><strong>最奇怪的地方还是下面这种场景了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>前面提到过let和const是不存在变量提升的，如果是这样的话，那么为什么不是输出20呢？（local作用域找不到a，继而向上层作用域寻找）所以说，let在预编译期间应该还是做了更多的动作。基于此，我的理解是：在预编译（parser)期间，首先在全局作用域产生了一个变量a，接着在local作用域发现由let所定义的a，创建它，但是是否提升呢？<strong>可以理解为提升了，但是同时又创建了一个暂时死区</strong>，提升的意思是告诉后面执行阶段的代码a是local里面的，暂时死区的意思是指 <strong>变量a从声明语句那一处位置才开始变得可访问，在这之前是暂时死区，在这暂时死区里面访问是会报错的。</strong></p><p>总结：<strong>let和const存在提升，但是提升的意义是在于告诉所在的作用域你访问的就是我，不是别的哪个上层作用域；同时副作用是：创建了暂时死区，得等我被执行之后才可访问；否则报ReferenceError错误。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-题目：&quot;&gt;&lt;a href=&quot;#1-题目：&quot; class=&quot;headerlink&quot; title=&quot;1.题目：&quot;&gt;&lt;/a&gt;1.题目：&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>promise相关</title>
    <link href="http://yoursite.com/2019/03/28/promise%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/03/28/promise相关/</id>
    <published>2019-03-28T07:07:42.000Z</published>
    <updated>2019-03-29T03:03:24.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1.Promise"></a>1.Promise</h3><p>一个Promise具有三个状态，分别是pending，fulfilled，rejected；分别代表着初始状态；操作成功完成；操作失败；pending状态的promise可以转化为fulfilled状态，此时onfulfilled方法将会被触发执行；当pending状态转化为rejected状态的话，那么此时onrejected方法将会被触发。一个promise的resolve()和reject()都会产生状态，分别是fulfilled和rejected。如果这个promise没有定义onfulfilled或者onrejected的话，那么回调将不会被调用；一般onfulfilled都是作为Promise.prototype.then方法的第一个cb参数的，而onrejected都是作为Promise.prototype.then的第二个cb参数；如果在then中没有传递onrejected的话，那么可以使用Promise.prototype.catch来对错误操作进行兜底操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise.prototype.then和Promise.prototype.catch方法将会返回一个Promise，如果其不是显式的Promise数据类型的话，那么是会经过类型转换的，所以可以实现链式调用。可以看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 number is 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">2</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line">.then(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'number is'</span>, n);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-对promise运行情况的判断"><a href="#2-对promise运行情况的判断" class="headerlink" title="2.对promise运行情况的判断"></a>2.对promise运行情况的判断</h3><p><strong>1.promise哪部分是立执行的，哪部分是异步的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出1 2 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>2.重点就是区别出那部分是未来执行的，以及先进入排队的未来操作会被先执行：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 1 2 3 4</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;resolve();&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>))</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>3.奇怪现象之当then接收到不是function的时候</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 1 2 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在MDN上的描述为，如果then上面的不是一个function的话，那么将会使会利用then里面的东西创建一个新的Promise。</p><h3 id="3-分析一个Promise的大致运行流程"><a href="#3-分析一个Promise的大致运行流程" class="headerlink" title="3.分析一个Promise的大致运行流程"></a>3.分析一个Promise的大致运行流程</h3><p>代码如下所示（调试工具使用Chrome，Promise实现采用lie库）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="comment">// 再此处打一个端点</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行流程分析：</p><p>1.首先进入到Promise构造方法里面，判断构造函数所接收到的参数是否是一个function（使用typeof进行判断），如果不是的话那么报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> resolver !== <span class="string">'function'</span>) &#123;           <span class="comment">// resolve 是Promise构造函数的形式化参数</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'resolver must be a function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.每个Promise实例都只能有三种状态当中的一个，要么pending，要么是fulfilled，或者是rejected。很显然初始状态自然是pending;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In Promise constructor</span></span><br><span class="line"><span class="keyword">this</span>.state = [<span class="string">'PENDING'</span>]; <span class="comment">// 是一个数组，为什么得是数组后面揭晓</span></span><br></pre></td></tr></table></figure><p>3.设置未来执行的操作队列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In Promise constructor</span></span><br><span class="line"><span class="keyword">this</span>.queue = [];</span><br></pre></td></tr></table></figure><p>4.设置outcome值，可以理解为这个值会被用来传给onfulfilled回调和onrejected回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In Promise Constructor</span></span><br><span class="line"><span class="keyword">this</span>.outcome = <span class="keyword">void</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>5.准备工作已经就绪，接下来开始执行Promise的立执行部分，立执行部分就是传递给Promise构造函数的参数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">safelyResolveThenable(<span class="keyword">this</span>, resolver);    <span class="comment">// 其中this执行Promise实例，resolver就是传递给Promise构造函数的函数参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是safelyResolveThenable函数的定义：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safelyResolveThenable</span>(<span class="params">self, thenable</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对于一个Promise实例来说，最终的结果要么是resolve，要么就是reject。且状态只能是发生一次，所以有了下面的called</span></span><br><span class="line">  <span class="keyword">var</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    handlers.reject(self, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    handlers.resolve(self, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tryToUnwrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    thenable(onSuccess, onError);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = tryCatch(tryToUnwrap);</span><br><span class="line">  <span class="keyword">if</span> (result.status === <span class="string">'error'</span>) &#123;</span><br><span class="line">    onError(result.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有一个很重要的handlers全局对象的定义，如下所示：</span></span><br><span class="line"><span class="keyword">var</span> handlers = &#123;&#125;;</span><br><span class="line">handlers.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">self, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = tryCatch(getThen, value);</span><br><span class="line">  <span class="keyword">if</span> (result.status === <span class="string">'error'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handlers.reject(self, result.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> thenable = result.value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thenable) &#123;</span><br><span class="line">    safelyResolveThenable(self, thenable);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    self.state = FULFILLED; <span class="comment">// FULFILLED 的值是一个数组["fulfilled"]</span></span><br><span class="line">    self.outcome = value;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> len = self.queue.length;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">      self.queue[i].callFulfilled(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br><span class="line">handlers.reject = <span class="function"><span class="keyword">function</span> (<span class="params">self, error</span>) </span>&#123;</span><br><span class="line">  self.state = REJECTED; <span class="comment">// REJECTED 的值是一个数组["rejected"]</span></span><br><span class="line">  self.outcome = error;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">var</span> len = self.queue.length;</span><br><span class="line">  <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">    self.queue[i].callRejected(error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>6.运行safelyResolveThenable函数，首先设置called对象，因为一个Promise实例也就只能被决议一次，要么是fulfilled，要么是rejected。接下来定义了onError和onSuccess，分别对应构造Promise对象时候的function argument的第一个argument和第二个argument，然后执行tryCatch方法。这个tryCatch方法接受一个函数，这个函数完成的工作就是：执行构造Promise对象时候传递的函数参数。所以说，Promise构造函数所接受的resolver参数是立执行的。</p><p>7.运行tryCatch方法，tryCatch的函数签名如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatch</span>(<span class="params">func, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> out = &#123;&#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    out.value = func(value);</span><br><span class="line">    out.status = <span class="string">'success'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    out.status = <span class="string">'error'</span>;</span><br><span class="line">    out.value = e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次执行的时候，tryCatch接受的参数是实例化Promise时所传入的resolver，因此如果执行resolver的时候如果报错的话，那么状态将会是’error’，而非必须是reject所导致。（这一点挺重要，就是状态为’error’)。如果状态为’error’的话，那么在调用reject，也就是说间接的reject了，这就造成了下面这样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 error is Error: error...</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error is'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时需要区别开下面这种情况：</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>));</span><br><span class="line">&#125;).then(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve'</span>, err);      <span class="comment">// 此时promise的状态可不是rejected了，而是正常的fulfilled</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>8.对于我们debug的这个例子来说，运行到这步的时候就已经输出1了，同时resolve被替代为handlers.resolve方法，所以接下来执行handlers.resolve方法。回到上面的handlers.resolve方法，这个方法第一步也是调用的tryCatch，关键是要留意这个tryCatch的第一个参数不再是之前的resolver了，而是getThen方法，getThen的函数定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure we only access the accessor once as required by the spec</span></span><br><span class="line">  <span class="keyword">var</span> then = obj &amp;&amp; obj.then;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; <span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">appyThen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      then.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用就是判断resolve的参数是否又是一个Promise，如果是的话，那么传递给onfulfill或者onrejected的参数可就不是这个Promise instance value了，而是这个Promise instance 决议后的value。可以看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出为 1，2几乎同时输出，但是3滞后2S输出，同时值为n为3</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                resolve(<span class="number">3</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>, n);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>,<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p>哪怕是resolve多个Promise，最外层的onfulfilled或者onrejected也是获取最里层的promise所返回的值。如下所示是resolve 两个promise。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1和步骤2几乎同时输出；步骤3延时2S，输出4</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">3</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;)).then(<span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, n, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p>为什么能够处理多个Promise？这就需要归功于handlers.resolve的实现了，在里面会判断tryCatch所返回的对象中的value值是否存在，如果存在的话，那么表明又是一个实例化Promise的过程，此时又会走一遍上面走过的流程。因此此时仍旧处于未决议的状态，所以onfulfilled也好onrejected也好都得不到执行的机会。</p><p>9.执行到这步的时候，只要resolve后面跟的是非Promise对象的话，那么此时都是已经决议完成了，决议完成的话，将会执行下面这些步骤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thenable) &#123;</span><br><span class="line">    safelyResolveThenable(self, thenable);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  self.state = FULFILLED;</span><br><span class="line">  self.outcome = value;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">var</span> len = self.queue.length;</span><br><span class="line">  <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">    self.queue[i].callFulfilled(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> self;</span><br></pre></td></tr></table></figure><p>首先设置了决议状态位fulfilled，接着还设置了传递给onfulfilled函数的值outcome，到了这一步Promise的立执行部分就已经基本运行完了。因此这个时候开始走then流程了，then流程的源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === FULFILLED ||</span><br><span class="line">    <span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(INTERNAL);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) &#123;</span><br><span class="line">    <span class="keyword">var</span> resolver = <span class="keyword">this</span>.state === FULFILLED ? onFulfilled : onRejected;</span><br><span class="line">    unwrap(promise, resolver, <span class="keyword">this</span>.outcome);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(<span class="keyword">new</span> QueueItem(promise, onFulfilled, onRejected));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从源代码我们可以看出其实then语句部分也是立执行的（意思是说只要一旦Promise决议好了的话，那么便开始执行then部分的代码了）。此时会根据决议状态确定是执行onfulfilled还是onrejected。从上面我们可以看出，onfulfilled以及onrejected并没有要求一定得是函数类型的，而这也正是上面一个例子第三个例子onfulfill表现出来像是同步执行的原因。</p><p>10.执行unwrap方法流程，unwrap方法的函数定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrap</span>(<span class="params">promise, func, value</span>) </span>&#123;</span><br><span class="line">  immediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> returnValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      returnValue = func(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> handlers.reject(promise, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnValue === promise) &#123;        <span class="comment">// 万一你皮了返回自己那岂不是then到无求无尽了嘛</span></span><br><span class="line">      handlers.reject(promise, <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot resolve promise with itself'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlers.resolve(promise, returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.执行immediate方法，immediate方法的定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immediate</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue.push(task) === <span class="number">1</span> &amp;&amp; !draining) &#123;</span><br><span class="line">    scheduleDrain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12.接下来执行scheduleDrain方法，他的函数定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mutation = global.MutationObserver || global.WebKitMutationObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scheduleDrain;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Mutation) &#123;</span><br><span class="line">    <span class="keyword">var</span> called = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> Mutation(nextTick);</span><br><span class="line">    <span class="keyword">var</span> element = global.document.createTextNode(<span class="string">''</span>);</span><br><span class="line">    observer.observe(element, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;        <span class="comment">// 每次调用scheduleDrain都会改变element,而element是被监视了的，所以此时nextTick会被触发，属于微观层面的异步行为</span></span><br><span class="line">      element.data = (called = ++called % <span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!global.setImmediate &amp;&amp; <span class="keyword">typeof</span> global.MessageChannel !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> channel = <span class="keyword">new</span> global.MessageChannel();</span><br><span class="line">    channel.port1.onmessage = nextTick;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      channel.port2.postMessage(<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'document'</span> <span class="keyword">in</span> global &amp;&amp; <span class="string">'onreadystatechange'</span> <span class="keyword">in</span> global.document.createElement(<span class="string">'script'</span>)) &#123;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a &lt;script&gt; element; its readystatechange event will be fired asynchronously once it is inserted</span></span><br><span class="line">      <span class="comment">// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.</span></span><br><span class="line">      <span class="keyword">var</span> scriptEl = global.document.createElement(<span class="string">'script'</span>);</span><br><span class="line">      scriptEl.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        nextTick();</span><br><span class="line">        scriptEl.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">        scriptEl.parentNode.removeChild(scriptEl);</span><br><span class="line">        scriptEl = <span class="literal">null</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      global.document.documentElement.appendChild(scriptEl);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(nextTick, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分代码就是Promise的核心精华部分之一，也正是在这一步决定了onfulfill和onreject是被异步调用的原因之一，同时他们是属于微观层面的异步事件，会比setTimeout等的宏观层面的异步时间更早得到执行机会。那么是大致怎么实现的呢？通过阅读源代码可以发现依赖于scheduleDrain这个方法的实现。</p><p>首先需要明确的是，在大部分场合下，scheduleDrain的实现都不是依赖于setTimeout这种宏观层面的异步流程来实现的。除非是最最不济的情况下才会使用到setTimeout。所以再这里就需要了解到如何实现一个微观层面上的异步流程了，分析scheduleDrain函数的实现，我们可以发现它首先使用DOM3 Events所提供的window.MutationObserver，这个接口提供了监视DOM树发生变化时所作出更改的能力。我们可以看一下它的使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  attributes: <span class="literal">true</span>,</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cb = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'changed'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(cb);    <span class="comment">// 当被监听的DOM发生变化的时候便会执行这个cb</span></span><br><span class="line"></span><br><span class="line">observer.observe($<span class="number">0</span>, config);</span><br><span class="line">$<span class="number">0.</span>style.width = <span class="string">'20px'</span>;                   <span class="comment">// 这个时候你会发现changed被输出</span></span><br></pre></td></tr></table></figure><p>关于node上面的处理，这里就不讨论了。接下来继续看关于使用script标签来实现微观层面的异步行为。使用script来实现异步行为的注释写的很清楚，只要将script挂载上去，那么onreadystatechange便会被异步触发（微观层面）。唯一需要注意的就是需要清空资源。如果这些方式都实现不了的话，那么就使用setTimeout(nextTick, 0)代替。</p><p>为什么需要明确说明微观层面的异步行为呢？因为微观层面的异步行为比如Promise，宏观层面的异步行为如setTimeout，需要明确的是微观层面的异步行为会比宏观层面的异步行为更快的执行。</p><p>分析到这里，此时已经基本完毕了。有一点需要注意的是由于then放回的十一Promise，所以还会走一遍上面分析的流程。</p><h3 id="微观层面和宏观层面的异步行为分析"><a href="#微观层面和宏观层面的异步行为分析" class="headerlink" title="微观层面和宏观层面的异步行为分析"></a>微观层面和宏观层面的异步行为分析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果为1，2，3</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Promise&quot;&gt;&lt;a href=&quot;#1-Promise&quot; class=&quot;headerlink&quot; title=&quot;1.Promise&quot;&gt;&lt;/a&gt;1.Promise&lt;/h3&gt;&lt;p&gt;一个Promise具有三个状态，分别是pending，fulfilled，rejec
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实现一个sleep方法</title>
    <link href="http://yoursite.com/2019/03/28/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/28/实现一个sleep方法/</id>
    <published>2019-03-28T02:52:53.000Z</published>
    <updated>2019-03-28T03:43:56.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题：实现一个sleep方法进行等待"><a href="#1-问题：实现一个sleep方法进行等待" class="headerlink" title="1.问题：实现一个sleep方法进行等待"></a>1.问题：实现一个sleep方法进行等待</h3><p><strong>法一：使用Promise实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果，步骤1和步骤2，步骤4几乎同时输出，步骤3被延时1S</span></span><br><span class="line"><span class="keyword">let</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p><strong>法二：使用promise+async实现，避免callback形式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果，步骤1，步骤2，步骤4的输出结果几乎相同；步骤3被延时1S</span></span><br><span class="line"><span class="keyword">let</span> sleepPromise = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wait1s = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  <span class="keyword">await</span> sleepPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait1s();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p><strong>法三：使用promise+generator实现，注意每次调用generator构造方法都将会生成一个新的generator实例，此时将会从头开始yield.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1和步骤3几乎同时同时输出，步骤2滞后1S</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genIns = gen(<span class="number">1000</span>);</span><br><span class="line">genIns.next().value.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p>关于generator，调用generator实例的next会执行到yield语句，返回的是一个对象，该对象具有两个字段，分别是value和done，value对应yield出来的值，done表示这个generator实例是否执行完毕。每次调用generator构造函数函数都会生成一个新的generator实例。</p><p>看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gi = gen();</span><br><span class="line"><span class="built_in">console</span>.log(gi.next());     <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen().next());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gi.next());     <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gi.next());     <span class="comment">// &#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen().next());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen().next());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-问题：实现一个sleep方法进行等待&quot;&gt;&lt;a href=&quot;#1-问题：实现一个sleep方法进行等待&quot; class=&quot;headerlink&quot; title=&quot;1.问题：实现一个sleep方法进行等待&quot;&gt;&lt;/a&gt;1.问题：实现一个sleep方法进行等待&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>angular指令</title>
    <link href="http://yoursite.com/2019/02/11/angular%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2019/02/11/angular架构概览/</id>
    <published>2019-02-11T02:46:15.000Z</published>
    <updated>2019-02-14T02:05:35.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-内置指令"><a href="#一-内置指令" class="headerlink" title="一.内置指令"></a>一.内置指令</h3><p><strong>1.ngClass：在angular中，通过ngClass指令，可以同时添加或者移除多个类。</strong></p><p><strong>2.ngStyle: 使用ngStyle指令，可以给模板元素设置多个内联样式。</strong></p><p><strong>3.ngIf: 使用ngIf指令能够控制元素是否显示，并且如果其值为false的话，那么会从DOM树移除。</strong></p><p><strong>4.ngSwitch: ngSwitch指令需要和ngSwitchCase指令和ngSwitchDefault指令搭配使用。</strong></p><p><strong>5.ngFor：使用ngFor来展示列表数据；同时也可以获取到遍历索引；对于包含复杂列表的使用场景来说，使用普通的ngFor来渲染列表数据的话那么会出现明显的性能问题，此时应该配合使用trackBy来提升性能。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.component.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.css'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;</span><br><span class="line"></span><br><span class="line">  contractName = <span class="string">'hahahai'</span>;</span><br><span class="line"></span><br><span class="line">  setClasses() &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = &#123;</span><br><span class="line">      red: <span class="literal">true</span>,</span><br><span class="line">      font14: <span class="literal">true</span>,</span><br><span class="line">      title: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setStyles() &#123;</span><br><span class="line">    <span class="keyword">let</span> styles = &#123;</span><br><span class="line">      <span class="string">'color'</span>: <span class="literal">true</span> ? <span class="string">'red'</span> : <span class="string">'yellow'</span>,</span><br><span class="line">      <span class="string">'font-size'</span>: <span class="literal">true</span> ? <span class="string">'14px'</span> : <span class="string">'16px'</span>,</span><br><span class="line">      <span class="string">'font-weight'</span>: <span class="literal">true</span> ? <span class="string">'bold'</span> : <span class="string">'normal'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> styles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.component.html</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 [ngClass]=<span class="string">"setClasses()"</span>&gt;angular&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h1 [ngStyle]="setStyles()"&gt;angular&lt;/</span>h1&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span [ngSwitch]=<span class="string">"contractName"</span>&gt;</span><br><span class="line">    &lt;span *ngSwitchCase=<span class="string">"'timcook'"</span>&gt;timcook&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span *ngSwitchCase="'billgates'"&gt;billgates&lt;/</span>span&gt;</span><br><span class="line">    &lt;span *ngSwitchCase=<span class="string">"'hahahai'"</span>&gt;hahahai&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span *ngSwitchDefault&gt;弄那么&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-内置指令&quot;&gt;&lt;a href=&quot;#一-内置指令&quot; class=&quot;headerlink&quot; title=&quot;一.内置指令&quot;&gt;&lt;/a&gt;一.内置指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.ngClass：在angular中，通过ngClass指令，可以同时添加或者移除多个类。
      
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>新点总结</title>
    <link href="http://yoursite.com/2019/01/26/%E6%96%B0%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/26/新点总结/</id>
    <published>2019-01-26T03:40:45.000Z</published>
    <updated>2019-01-26T03:57:04.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-react实现简易的下载功能"><a href="#1-react实现简易的下载功能" class="headerlink" title="1.react实现简易的下载功能"></a>1.react实现简易的下载功能</h3><p>1.如果对于某个接口来说，后端发给你的就是需要下载的文件内容自身。那么可以像下面这样实现下载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, config).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">    response.blob().then(<span class="function"><span class="params">blobData</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">      <span class="keyword">let</span> href = <span class="built_in">window</span>.URL.createObjectURL(blobData);</span><br><span class="line">      a.href = href;</span><br><span class="line">      a.download = <span class="string">'FILE_NAME'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(a).click();</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(href);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-react实现简易的下载功能&quot;&gt;&lt;a href=&quot;#1-react实现简易的下载功能&quot; class=&quot;headerlink&quot; title=&quot;1.react实现简易的下载功能&quot;&gt;&lt;/a&gt;1.react实现简易的下载功能&lt;/h3&gt;&lt;p&gt;1.如果对于某个接口来说，后
      
    
    </summary>
    
    
      <category term="work" scheme="http://yoursite.com/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>react遇上typescript</title>
    <link href="http://yoursite.com/2019/01/21/react%E9%81%87%E4%B8%8Atypescript/"/>
    <id>http://yoursite.com/2019/01/21/react遇上typescript/</id>
    <published>2019-01-21T10:10:53.000Z</published>
    <updated>2019-01-21T10:12:47.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h3><p>这里介绍用create-react-app所创建的应用，使用下面的命令开启对typescript的支持：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app learn --typescript</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本配置&quot;&gt;&lt;a href=&quot;#1-基本配置&quot; class=&quot;headerlink&quot; title=&quot;1.基本配置&quot;&gt;&lt;/a&gt;1.基本配置&lt;/h3&gt;&lt;p&gt;这里介绍用create-react-app所创建的应用，使用下面的命令开启对typescript的支持：&lt;/
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>express+ts上手记1</title>
    <link href="http://yoursite.com/2019/01/20/express-ts%E4%B8%8A%E6%89%8B%E8%AE%B01/"/>
    <id>http://yoursite.com/2019/01/20/express-ts上手记1/</id>
    <published>2019-01-20T02:55:47.000Z</published>
    <updated>2019-01-20T14:26:37.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础配置"><a href="#1-基础配置" class="headerlink" title="1.基础配置"></a>1.基础配置</h3><p>1.在项目目录使用npm init -y生成npm配置，接着安装node所对应的ts声明文件：npm i @types/node –save；参考ts官网配置tsconfig.json文件；如果使用vscode的话，那么使用command（control）+ shift + b构建或者watch整个项目的变化。到达这一步的时候基本配置就已经配置好了。</p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h3><p>尽管我们没有在tsconfig.json文件里面指定include入口，不过此时有一个默认的配置。他会编译项目里面除开exclude指定的其他js文件。所以我们可以在项目的根目录使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础配置&quot;&gt;&lt;a href=&quot;#1-基础配置&quot; class=&quot;headerlink&quot; title=&quot;1.基础配置&quot;&gt;&lt;/a&gt;1.基础配置&lt;/h3&gt;&lt;p&gt;1.在项目目录使用npm init -y生成npm配置，接着安装node所对应的ts声明文件：npm i @
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>rust2</title>
    <link href="http://yoursite.com/2019/01/15/rust2/"/>
    <id>http://yoursite.com/2019/01/15/rust2/</id>
    <published>2019-01-15T12:50:34.000Z</published>
    <updated>2019-01-16T02:15:12.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-trait"><a href="#1-trait" class="headerlink" title="1.trait"></a>1.trait</h3><p>在trait中可以包含函数，常量，类型等。如下所示是一个包含函数的trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Shape</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的trait中都有一个隐藏的类型Self，代表了当前实现了该trait的具体类型，在trait中定义的函数，被叫做关联函数。如果一个关联函数的第一个参数是Self类型并且名字叫self的话（这样的参数叫做接收者），那么这个关联函数叫做方法，方法通过变量实例加上小数点进行调用；如果一个关联函数第一个参数不是接收者的话，那么这个关联函数叫做静态函数，通过类型::函数名的形式来调用。</p><p>所以在Rust中，Self（类型）和self（变量实例名）都是保留关键字。</p><p>当然我们也可以显示给接收者指定类型，但是同时他们在rust中都具有简写的写法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trait Shape &#123;</span><br><span class="line">  fn method1(self: Self);</span><br><span class="line">  fn method2(self: &amp;Self);</span><br><span class="line">  fn method3(self: &amp;mut Self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于上面的情况，也可以简写成下面的形式：</span></span><br><span class="line">trait Shape &#123;</span><br><span class="line">  fn method1(self);</span><br><span class="line">  fn method2(&amp;self);</span><br><span class="line">  fn method3(&amp;mut self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是让一个类实现一个trait的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">trait Shape &#123;</span><br><span class="line">  fn area(&amp;self) -&gt; f64;</span><br><span class="line">&#125;</span><br><span class="line">struct Circle &#123;</span><br><span class="line">  radius: f64,</span><br><span class="line">&#125;</span><br><span class="line">impl Shape <span class="keyword">for</span> Circle &#123;</span><br><span class="line">  fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">    std::f64::consts::PI * self.radius * self.radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  let c = Circle&#123; radius: <span class="number">10</span>f64 &#125;;</span><br><span class="line">  println!(<span class="string">"area is &#123;&#125;"</span>, c.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以为一个struct实现一个匿名trait；并不是只能在trait中声明函数，也可以定义函数的行为，实现他的struct便能够直接使用，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span></span> &#123;</span><br><span class="line">  radius: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Circle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">get_radius</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> c = Circle&#123; radius: <span class="number">10f64</span> &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"c.radius is &#123;&#125;"</span>, c.get_radius());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong>，只要一个trait里面的关联函数的第一个参数不是接收器的话，那么就表明这个方法是静态函数，使用类型::方式调用，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(this: &amp;<span class="keyword">Self</span>) &#123;  <span class="comment">// 由于第一个参数的名字不是self，尽管类型是Self</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"value is &#123;&#125;"</span>, this.<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = T(<span class="number">42</span>);</span><br><span class="line">  T::func(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rust规定，在函数中进行参数传递，返回值传递等地方，都要求这个类型在编译阶段具有确定的大小。而trait本身既不是具体类型，也不是指针类型，它只是定义了一个针对类型的抽象的约束，不同的类型可以实现同一个trait，同时满足同一个trait的类型可能具有不同的大小，所以trait在编译期间是没有确定大小的，因此不能使用trait作为实例变量，参数，返回值。</strong></p><p>在rust中，一个类可以实现多个trait，那么问题来了，如果实现的多个trait里面具有同名函数的话，那么调用的时候该怎么调用呢？对此rust提出了完全函数调用的概念，这使得函数调用变得直接与直观，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Cook</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Wash</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chef</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cook <span class="keyword">for</span> Chef &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Cook::start"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wash <span class="keyword">for</span> Chef &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Wash::start"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-trait&quot;&gt;&lt;a href=&quot;#1-trait&quot; class=&quot;headerlink&quot; title=&quot;1.trait&quot;&gt;&lt;/a&gt;1.trait&lt;/h3&gt;&lt;p&gt;在trait中可以包含函数，常量，类型等。如下所示是一个包含函数的trait。&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="rust" scheme="http://yoursite.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>flutter之弹性布局Flex</title>
    <link href="http://yoursite.com/2019/01/15/flutter%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/"/>
    <id>http://yoursite.com/2019/01/15/flutter之弹性布局Flex/</id>
    <published>2019-01-15T02:35:04.000Z</published>
    <updated>2019-01-15T05:23:19.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>弹性布局表示允许子widget按照一定比例来分配父容器的空间；如果你知道主轴方向，那么使用Row/Column会更加方便一些，因为这两者也都是继承自Flex的。下面我们可以看看Flex的基本定义，在前面Row和Column中提到过的属性这里就不提了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.direction, <span class="comment">// 弹性布局方向，对于Row来说默认就是水平方向；对于Column来说默认就是垂直方向。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-新概念-Expanded"><a href="#2-新概念-Expanded" class="headerlink" title="2.新概念-Expanded"></a>2.新概念-Expanded</h3><p>可以按照比例来扩伸Row，Column和Flex子Widget所占用的空间。下面可以看看它的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">    <span class="built_in">int</span> flex = <span class="number">1</span>,</span><br><span class="line">    <span class="meta">@required</span> Widget child</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>flex为弹性系数，如果为0或者null的话，则child是没有弹性的，此时不会扩伸占用的空间。如果大于0，所有的Expanded将会按照其flex的比例来分割主轴的全部空闲空间。</p><h3 id="3-流式布局"><a href="#3-流式布局" class="headerlink" title="3.流式布局"></a>3.流式布局</h3><p>对于Row和Column来说，如果子widget超出屏幕范围，则会报溢出错误，因为Row默认只能显示一行，如果超出屏幕的话并不会折行。在Flutter中，把超出屏幕显示范围会自动折行的布局叫做流失布局，具体通过Wrap和Flow这两个widget来进行支持。</p><h3 id="4-布局类和容器类"><a href="#4-布局类和容器类" class="headerlink" title="4.布局类和容器类"></a>4.布局类和容器类</h3><p>布局类一般接受一个widget数组（children)，而容器类一般只接受一个子Widget（child)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;弹性布局表示允许子widget按照一定比例来分配父容器的空间；如果你知道主轴方向，那么使用Row/Colum
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter线性布局</title>
    <link href="http://yoursite.com/2019/01/15/flutter%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/01/15/flutter线性布局/</id>
    <published>2019-01-15T01:41:55.000Z</published>
    <updated>2019-01-15T02:33:52.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就是水平方向；如果布局沿垂直方向，那么主轴就是指垂直方向；在Flutter中通过Row和Column来实现线性布局；并且Row以及Column都是继承自Flex。</p><h3 id="2-Row"><a href="#2-Row" class="headerlink" title="2.Row"></a>2.Row</h3><p>Row表明在水平方向排列其子widget，因此此时主轴就是水平方向；纵轴就是垂直方向；Row的定义如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  TextDirection textDirection,</span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  List&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>构造函数中各个字段的意思：</p><ul><li>1.textDirection：表示在水平方向上widget的布局顺序，注意一定是水平方向。</li><li>2.mainAxisSize：表示一个Row在水平方向所占用的空间，两个值可选，分别是mainAxisSize.min和mainAxisSize.max。</li><li>3.mainAxisAlignment：表示子Widgets在水平空间内的对齐方式；如果mainAxisSize的值为MainAxisSize.min的话，那么定义mainAxisAlignment的值将没有意义，因为子widget的宽度和Row的宽度是一样的。只有在mainAxisSize的值为mainAxisSize.max的时候，给mainAxisAlignment设置值才是可以接受的，假设textDirection的值为TextDirection.ltr的话，那么MainAxisAlignment.start表示左对齐；假设textDirection的值为TextDirection.rtl的话，那么设置MainAxisAlignment.end的话也是表明左对齐。当然还有mainAxisAlignment.center，这自然表明是居中了。</li><li>4.verticalDirection：表示Row的纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。</li><li>5.crossAxisAlignment：表示子widget在纵轴方向的对齐方式，在线性布局里面，Row的高度等于子Widgets中最高的子元素高度。这个属性具有三个可选值，分别是start,end,center，不同的是它的参考系是verticalDirection。</li><li>6.children：子widget数组。</li></ul><h3 id="3-Column"><a href="#3-Column" class="headerlink" title="3.Column"></a>3.Column</h3><p>Column表示在垂直方向进行排列，参数和Row类似，不同的就是Column表明的是垂直方向。</p><h3 id="4-需要注意的地方"><a href="#4-需要注意的地方" class="headerlink" title="4.需要注意的地方"></a>4.需要注意的地方</h3><p>如果Row里面嵌套Row，或者Column里面嵌套Column，那么只有最外面的Row或者Column会占用尽可能大的空间，里面的Row和Column为其实际大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就是水平方向；如果布局沿垂直方向，那么主轴就是指
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>next.js学习</title>
    <link href="http://yoursite.com/2019/01/14/next-js%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/14/next-js学习/</id>
    <published>2019-01-14T03:20:44.000Z</published>
    <updated>2019-01-15T01:57:35.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save next react reac-dom</span><br></pre></td></tr></table></figure><p>将上面的这些依赖安装好了之后，接着配置package.json文件，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"next"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"next build"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"next start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这些设置之后，在项目根目录下面的pages文件夹下面就是一个路由文件了，路由的名字和</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用&quot;&gt;&lt;a href=&quot;#1-使用&quot; class=&quot;headerlink&quot; title=&quot;1.使用&quot;&gt;&lt;/a&gt;1.使用&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>flutter之图片和icon</title>
    <link href="http://yoursite.com/2019/01/11/flutter%E4%B9%8B%E5%9B%BE%E7%89%87%E5%92%8Cicon/"/>
    <id>http://yoursite.com/2019/01/11/flutter之图片和icon/</id>
    <published>2019-01-11T11:46:42.000Z</published>
    <updated>2019-01-11T12:49:26.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>Flutter中，通过Image来加载并显示图片，Image的数据源可以是asset，文件，内存以及网络。</p><h3 id="2-ImageProvider"><a href="#2-ImageProvider" class="headerlink" title="2.ImageProvider"></a>2.ImageProvider</h3><p>ImageProvider是一个抽象类，主要定义了图片数据获取的接口load()，从不同的数据源获取图片需要实现不同的ImageProvider，比如AssetImage是实现了从Asset中加载图片的ImageProvider，而NetworkImage实现了从网络中加载图片的ImageProvider。</p><p>Image Widget有一个必选的image参数，它对应一个ImageProvider，如下面例子：</p><p>如果是从asset中加载图片的话，那么要先在pubspec.yml文件中的flutter部分添加以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  assets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">images/WechatIMG540.jpeg</span></span><br></pre></td></tr></table></figure><p>具体的实例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">    image: AssetImage(<span class="string">"images/some.png"</span>),</span><br><span class="line">    width: <span class="number">100.0</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 或者像下面这样</span></span><br><span class="line">Image.asset(<span class="string">"images/some.png"</span>, width: <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于网络图片来说，其用法可能更加简单一点</span></span><br><span class="line">Image(</span><br><span class="line">    image: NetworkImage(<span class="string">'image_url'</span>),</span><br><span class="line">    width: <span class="number">300.0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者像下面这样的便捷写法</span></span><br><span class="line">Image.network(</span><br><span class="line">    <span class="string">'img_url'</span>,</span><br><span class="line">    width: <span class="number">300.0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;Flutter中，通过Image来加载并显示图片，Image的数据源可以是asset，文件，内存以及网络。&lt;
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter之按钮</title>
    <link href="http://yoursite.com/2019/01/11/Flutter%E4%B9%8B%E6%8C%89%E9%92%AE/"/>
    <id>http://yoursite.com/2019/01/11/Flutter之按钮/</id>
    <published>2019-01-11T09:34:47.000Z</published>
    <updated>2019-01-11T11:29:33.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>Material widget库中提供了多种按钮Widget，比如RaisedButton，FlatButton，OutlineButton，它们都是直接或间接继承自RawMaterialButton。所有的Material库中的按钮都有下面几相同点：</p><ul><li>1.按下的时候会有水波动画</li><li>2.<strong>有一个onPressed属性来设置点击回调，按钮按下的时候执行该回调；如果不提供该回调的话则按钮会处于禁用状态。禁用状态不响应用户点击。</strong></li></ul><h3 id="2-RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。"><a href="#2-RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。" class="headerlink" title="2.RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。"></a>2.RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">'购买'</span>),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="3-FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。"><a href="#3-FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。" class="headerlink" title="3.FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。"></a>3.FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">    child: Text(<span class="string">'按钮'</span>),</span><br><span class="line">    onPressed: () =&gt; &#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>FlatButton的构造信息如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FlatButton(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onPressed, <span class="comment">// 按钮点击回调</span></span><br><span class="line">    <span class="keyword">this</span>.textColor,   <span class="comment">// 按钮文字颜色,</span></span><br><span class="line">    <span class="keyword">this</span>.color,     <span class="comment">// 按钮背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.disabledColor, <span class="comment">// 按钮禁用时候的背景颜色</span></span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;Material widget库中提供了多种按钮Widget，比如RaisedButton，FlatButt
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter之文本</title>
    <link href="http://yoursite.com/2019/01/09/Flutter%E4%B9%8B%E6%96%87%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/01/09/Flutter之文本/</id>
    <published>2019-01-09T15:17:00.000Z</published>
    <updated>2019-01-10T13:50:29.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>用于显示简单样式文本。用法如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'hello world'</span>, textAlign: TextAlign.center);</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'hello world'</span>*<span class="number">4</span>, maxLines: <span class="number">1</span>, overflow: TextOverflow.ellipsis);</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'hello world'</span>, textScaleFactor: <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><h3 id="2-Text方法的几个参数代表的意思"><a href="#2-Text方法的几个参数代表的意思" class="headerlink" title="2.Text方法的几个参数代表的意思"></a>2.Text方法的几个参数代表的意思</h3><ul><li><p>1.textAlign: 文本的对齐方式，可以选择左对齐，右对齐还是居中；这几个值都是从TextAlign里面获取。<strong>需要注意，对齐的参考系是Text Widget本身，这意味着如果Text的宽度和文本内容长度相等的话，那么此时指定对齐方式是没有意义的。</strong></p></li><li><p>2.maxLines, overflow: 指定文本显示的最大行数，默认情况下，文本是自动折行的。但是如果指定了maxLine的话，那么最多显示maxLines行，超出了maxLines行的行为由overflow的值来决定，默认是直接截断；如果想要显示省略号的话，那么使用TextOverflow.ellipsis值。</p></li><li><p>3.textScaleFactor: 代表文本相对于当前字体大小(style属性里面的fontSize)的缩放因子。</p></li><li><p>4.style: 他的值是一个TextStyle类所实例化出来的对象，举个例子如下所示：</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">'hello world'</span>,</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">      color: Colors.black,    <span class="comment">// 字体颜色</span></span><br><span class="line">      background: <span class="keyword">new</span> Paint()..color = Colors.white,    <span class="comment">// 字体底层的颜色（背景颜色）</span></span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      fontFamily: <span class="string">'Courier'</span>,</span><br><span class="line">      decoration: TextDecoration.underline,</span><br><span class="line">      height: <span class="number">1.3</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>需要注意的地方，TextStyle类的实例化参数height是一个因子，具体行高等于fontSize乘height。</strong></p><h3 id="3-TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。"><a href="#3-TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。" class="headerlink" title="3.TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。"></a>3.TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。</h3><p>如果想要对Text的不同部分应用不同的效果的话，那么使用TextSpan会更加方便。可以先看看TextSpan的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用了命名可选参数的写法，采用这种写法的话，除非带上@required的话否则都是可选</span></span><br><span class="line"><span class="keyword">const</span> TextSpan(&#123;</span><br><span class="line">    TextStyle style,</span><br><span class="line">    <span class="built_in">String</span> text,</span><br><span class="line">    <span class="built_in">List</span>&lt;TextSpan&gt; children,</span><br><span class="line">    GestureRecognizer recognizer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>各个参数的解释：</p><ul><li>1.children，一个TextSpan数组，说明TextSpan里面可以包含其它TextSpan</li><li>2.recognizer，在文本片段上进行手势处理</li></ul><p>举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Text.rich(TextSpan(</span><br><span class="line">    children: [</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">'主页：'</span></span><br><span class="line">      ),</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">'hotfireeagle.github.io'</span>,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">              color: Colors.blue</span><br><span class="line">          ),</span><br><span class="line">          recognizer: gotoLink, <span class="comment">// 手势处理方法</span></span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">))</span><br></pre></td></tr></table></figure><h3 id="4-DefaultTextStyle"><a href="#4-DefaultTextStyle" class="headerlink" title="4.DefaultTextStyle"></a>4.DefaultTextStyle</h3><p>在Widget树中，文本的样式默认是可以继承的。因此，如果在Widget树中的某个节点处设置一个默认的文本样式的话，那么该节点下的子树中的所有文本都会默认使用这个样式。不同于web编程，设置默认文本样式可以在任意一个父元素里面，但是在flutter里面如果想要设置默认文本样式的话，那么应该使用DefaultTextStyle这个widget才行。如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DefaultTextStyle(</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        fontSize: <span class="number">18.0</span></span><br><span class="line">    ),</span><br><span class="line">    textAlign: TextAlign.center,</span><br><span class="line">    <span class="comment">// 注意在这里是child</span></span><br><span class="line">    child: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        <span class="comment">// 注意在这里是children</span></span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">'hello world'</span>),</span><br><span class="line">          Text(<span class="string">'hello flutter'</span>),</span><br><span class="line">          Text(<span class="string">'cool'</span>, style: TextStyle(color: Colors.green))</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h3&gt;&lt;p&gt;用于显示简单样式文本。用法如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>express学习</title>
    <link href="http://yoursite.com/2019/01/07/express%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/07/express学习/</id>
    <published>2019-01-07T09:17:44.000Z</published>
    <updated>2019-01-09T15:22:15.814Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.helmet中间件介绍</strong></p><p>helmet中间件是用来增强express应用的安全性的，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.helmet中间件介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;helmet中间件是用来增强express应用的安全性的，&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>dart基础3</title>
    <link href="http://yoursite.com/2019/01/07/dart%E5%9F%BA%E7%A1%803/"/>
    <id>http://yoursite.com/2019/01/07/dart基础3/</id>
    <published>2019-01-07T03:03:34.000Z</published>
    <updated>2019-01-07T03:54:59.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.异步支持，在dart中有很多返回Future和Stream对象的函数，这些函数在设置完耗时任务之后就立即返回了，不会等待耗时任务完成。使用async和await关键字可以让我们像编写同步代码一样实现异步操作。</strong></p><p><strong>2.如何获得Future的返回结果，具有两种方式，分别是使用async和await；使用Future API。可以使用try…catch…来捕获代码中使用await所导致的错误。首先看看第一种方式：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.声明异步函数，使用async声明函数并且返回值是Future。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">'1.0.0'</span>; <span class="comment">// 需要注意async修饰符的位置</span></span><br></pre></td></tr></table></figure><p><strong>4.同样，对于Stream对象来说，他也是一种异步操作，如果想获取他的返回值的话，那么也有两种方式：分别是使用await（await for)和Stream API。</strong></p><p><strong>5.可调用类，通过给类实现一个call方法，能够让类所实例化出来的对象被调用。如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">callable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> a;</span><br><span class="line"></span><br><span class="line">  callable(<span class="keyword">this</span>.a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> consoleA() &#123; <span class="built_in">print</span>(<span class="string">'a is <span class="subst">$a</span>'</span>); &#125;</span><br><span class="line"></span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  let cb = callable(<span class="number">3</span>);</span><br><span class="line">  cb.consoleA(); <span class="comment">// a is 3</span></span><br><span class="line">  let ret = cb(<span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'ret is <span class="subst">$ret</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.typedef类型定义，考虑下面这个场景:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortCollection sc = SortCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(sc.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个例子，当把f赋值给compare的时候，f的类型信息(Object, Object) -&gt; int（rust写法)被丢弃了，此时compare的类型信息为Function。为了避免这种类型丢失的情况，可以像下面这样做：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortCollection coll = SortCollection(sort);</span><br><span class="line">  <span class="comment">// 这样做的话coll.compare类型信息便没有丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typedef和泛型结合在一起：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare&lt;<span class="built_in">int</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.异步支持，在dart中有很多返回Future和Stream对象的函数，这些函数在设置完耗时任务之后就立即返回了，不会等待耗时任务完成。使用async和await关键字可以让我们像编写同步代码一样实现异步操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>dart基础2</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2019/01/05/dart基础2/</id>
    <published>2019-01-05T09:23:32.000Z</published>
    <updated>2019-01-07T02:59:50.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.类</strong></p><p>Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。</p><p>在Dart2中，new关键字是可选的。</p><p>在dart中，存在像下面这样实例化对象的方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.常量构造函数</strong></p><p>在构造函数名之前加const关键字，来创建编译时常量，构造两个相同的编译时常量会产生一个唯一的，标准的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(identical(a, b));</span><br></pre></td></tr></table></figure><p><strong>3.一个不太明白的特性：在dart2中，一个常量上下文中的const关键字可以被省略。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个不省略的版本</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'point'</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 接下来是一个省略的版本，仅有一个const，由该const建立上下文</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">'point'</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.获取对象的类型</strong></p><p>使用对象的runtimeType属性可以在运行的时候获取对象的类型。他返回的是一个Type对象。</p><p><strong>5.实例变量：就是不是类对象所拥有的，而是类所实例化出来的对象所拥有的</strong></p><p>所有未初始化变量的默认值都是null，所有实例变量都会生成一个隐式的getter方法，非final的实例变量同样会生成一个隐式的setter方法。也就是说对一个实例变量进行赋值的时候，实际都是通过调用setter方法来赋值的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> y;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;  <span class="comment">// 初始值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.构造函数，通过创建一个和类同名的函数来声明构造函数，可以使用this关键字来获取当前实例。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很常见的生成构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还有更好的方式实现下面代码，在dart里面最佳实践应该减少使用this</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是精简模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// 一颗语法题</span></span><br><span class="line">  Point (<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有声明构造函数的情况下，Dart会提供一个默认的构造函数，默认构造函数没有参数并会调用父类的无参构造函数。子类不会继承父类的构造函数，子类不声明构造函数，那么它就只有默认构造函数。</p><p><strong>7.命名构造函数，使用命名构造函数可以为一个类实现多个构造函数，可以使用命名构造函数来更清晰的表明函数意图：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.什么鬼super，如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Person'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Employee'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;); <span class="comment">// 输出 =&gt; in Person in Employee</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.初始化列表概念，很难看</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">    : x = x,</span><br><span class="line">      y = y,</span><br><span class="line">      distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种初始化列表的写法起的作用对应了js里面的参数默认值，在写法上后者简直不要太简单优雅；在dart中，我们可以在构造函数后面加上一个:后面跟上一些初始化列表语句，同时也能够对其进行开发期assert判断处理。</p><p><strong>10.重定向构造函数，在某些情况下，某些命名构造函数只需要使用其它构造函数的逻辑即可，那么此时使用重定向构造函数便很合适：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  Point.which(<span class="built_in">num</span> x): <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.常量构造函数，常量构造函数所创建出来的实例并不是常量（？？），如果希望实例出来的变量是固定不变的话，那么首先构造函数得是const的，并且所有实例变量也都得是final。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.工厂构造函数，第一次接触到。如果类中的某个构造函数并不总是返回这个类的实例（而是有可能返回其它类的实例）的话，那么这个构造函数也被叫做工厂构造函数，使用factory关键字来定义，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.Getters和Setters，每一个实例变量都会有一个隐式的getter，通常也会有一个setter。同时我们也可以使用get和set关键字来显式设置getters和setters。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示声明带有getter和setter的实例属性</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>l</span><br><span class="line">  <span class="keyword">assert</span>(rect.left = <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>14.抽象方法，抽象方法只能够存在于抽象类中。实例方法，getter，setter方法可以是抽象的，他们只定义接口而不实现，实现交给子类去完成。调用抽象方法会带来运行时错误：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuff</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> soStuff() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>15.抽象类：使用abstract修饰符来定义一个抽象类，抽象类不能用来实例化，如果希望抽象类能够被实例化，那么可以通过定义工厂实例函数来实现。在dart中声明抽象方法无需加上abstract修饰符，没有大花括号并且加上返回值就是了。抽象方法只能在抽象类中定义。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> updateChildren();  <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16.接口：每个类都隐式的定义了一个接口，接口包含了该类所有的实例变量以及实例方法，但是，注意并不包含构造函数。如果想要创建一个A类，并且A类要支持B类的API的话，但是又不想继承B类的实现的话，那么可以通过让A类来实现B类的接口。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>, I am <span class="subst">$_name</span>'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">''</span>;</span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hi, <span class="subst">$who</span>, Do You Know Who I Am'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">'kay'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时一个类也能够用来实现多个接口，如下所示：</p><p>class Point implements PointA, PointB {…}</p><p><strong>17.枚举类型是一种特殊的类，使用enum关键字来定义一个枚举类。枚举中的每一个值都具有一个index getter方法，该方法这个值在枚举类型中的位置；每个枚举类型，都具有一个values实例常量，用来获取所有枚举值列表。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p><strong>18.使用mixins，使用类的时候with一个mixin，怎么实现一个mixin？使用mixin关键字进行定义，写法和类写法一样，除了使用mixin代替了class外。</strong></p><p><strong>19.静态变量和静态方法，使用static即可，注意，静态变量只有在被使用的时候才会初始化；静态方法因为不可以在实例上访问，所以无法访问this。</strong></p><p><strong>20.泛型，挺好的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p><strong>21.参数化字面量，作用是不用去猜？</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">'haha'</span>, <span class="string">'hai'</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">'index.html'</span>: <span class="string">'Homepage'</span>,</span><br><span class="line">  <span class="string">'robots.txt'</span>: <span class="string">'all spider'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>22.在运行时能够测试到泛型类型，泛型类型是固化的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'n1'</span>, <span class="string">'n2'</span>, <span class="string">'n3'</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>23.限制泛型类型</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> toString() =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>24.泛型方法，这才像样</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>25.库和可见性，import和library指令用来创建模块化的，可共享的代码库。以下划线_开头的标识符仅在库中可见，每个dart程序都是一个库，尽管没有使用library指令。</strong></p><p>利用import命令来使用一个库，import后面加上一个URI；对于内置的库来说，URI拥有自己内置的dart:方案；对于其他的库，使用系统文件路径或者package:方案；其中后者使用package:方案是指定由包管理器（pub工具）所提供的库。如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure><p><strong>26.指定库前缀来解决两个库里面定义了同一个类；假设下面两个类中都有Element的声明的话，那么如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Element</span> ele1 = <span class="built_in">Element</span>();</span><br><span class="line">lib2.<span class="built_in">Element</span> ele2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure><p><strong>27.导入库的一部分，还是挺方便的，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo; <span class="comment">// 只导入这个库的foo部分</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo; <span class="comment">// 导入这个库除了foo外的其它部分</span></span><br></pre></td></tr></table></figure><p><strong>28.延迟加载库，在某些地方还是能够派上用场的，使用延迟加载库的功能能够优化App启动时间；延迟加载库使用上了dart的异步功能，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary(); <span class="comment">// 调用loadLibrary函数来加载库</span></span><br><span class="line">  hello.printGreet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
</feed>
