<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜游</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-06T14:48:36.541Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hahahai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dart基础2</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2019/01/05/dart基础2/</id>
    <published>2019-01-05T09:23:32.000Z</published>
    <updated>2019-01-06T14:48:36.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.类</strong></p><p>Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。</p><p>在Dart2中，new关键字是可选的。</p><p>在dart中，存在像下面这样实例化对象的方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.常量构造函数</strong></p><p>在构造函数名之前加const关键字，来创建编译时常量，构造两个相同的编译时常量会产生一个唯一的，标准的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(identical(a, b));</span><br></pre></td></tr></table></figure><p><strong>3.一个不太明白的特性：在dart2中，一个常量上下文中的const关键字可以被省略。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个不省略的版本</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'point'</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 接下来是一个省略的版本，仅有一个const，由该const建立上下文</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">'point'</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.获取对象的类型</strong></p><p>使用对象的runtimeType属性可以在运行的时候获取对象的类型。他返回的是一个Type对象。</p><p><strong>5.实例变量：就是不是类对象所拥有的，而是类所实例化出来的对象所拥有的</strong></p><p>所有未初始化变量的默认值都是null，所有实例变量都会生成一个隐式的getter方法，非final的实例变量同样会生成一个隐式的setter方法。也就是说对一个实例变量进行赋值的时候，实际都是通过调用setter方法来赋值的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> y;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;  <span class="comment">// 初始值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.构造函数，通过创建一个和类同名的函数来声明构造函数，可以使用this关键字来获取当前实例。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很常见的生成构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还有更好的方式实现下面代码，在dart里面最佳实践应该减少使用this</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是精简模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// 一颗语法题</span></span><br><span class="line">  Point (<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有声明构造函数的情况下，Dart会提供一个默认的构造函数，默认构造函数没有参数并会调用父类的无参构造函数。子类不会继承父类的构造函数，子类不声明构造函数，那么它就只有默认构造函数。</p><p><strong>7.命名构造函数，使用命名构造函数可以为一个类实现多个构造函数，可以使用命名构造函数来更清晰的表明函数意图：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.什么鬼super，如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Person'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Employee'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;); <span class="comment">// 输出 =&gt; in Person in Employee</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.初始化列表概念，很难看</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">    : x = x,</span><br><span class="line">      y = y,</span><br><span class="line">      distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种初始化列表的写法起的作用对应了js里面的参数默认值，在写法上后者简直不要太简单优雅；在dart中，我们可以在构造函数后面加上一个:后面跟上一些初始化列表语句，同时也能够对其进行开发期assert判断处理。</p><p><strong>10.重定向构造函数，在某些情况下，某些命名构造函数只需要使用其它构造函数的逻辑即可，那么此时使用重定向构造函数便很合适：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  Point.which(<span class="built_in">num</span> x): <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.常量构造函数，常量构造函数所创建出来的实例并不是常量（？？），如果希望实例出来的变量是固定不变的话，那么首先构造函数得是const的，并且所有实例变量也都得是final。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.工厂构造函数，第一次接触到。如果类中的某个构造函数并不总是返回这个类的实例（而是有可能返回其它类的实例）的话，那么这个构造函数也被叫做工厂构造函数，使用factory关键字来定义，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.Getters和Setters，每一个实例变量都会有一个隐式的getter，通常也会有一个setter。同时我们也可以使用get和set关键字来显式设置getters和setters。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示声明带有getter和setter的实例属性</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>l</span><br><span class="line">  <span class="keyword">assert</span>(rect.left = <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>14.抽象方法，抽象方法只能够存在于抽象类中。实例方法，getter，setter方法可以是抽象的，他们只定义接口而不实现，实现交给子类去完成。调用抽象方法会带来运行时错误：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuff</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> soStuff() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>15.抽象类：使用abstract修饰符来定义一个抽象类，抽象类不能用来实例化，如果希望抽象类能够被实例化，那么可以通过定义工厂实例函数来实现。在dart中声明抽象方法无需加上abstract修饰符，没有大花括号并且加上返回值就是了。抽象方法只能在抽象类中定义。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> updateChildren();  <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16.接口：每个类都隐式的定义了一个接口，接口包含了该类所有的实例变量以及实例方法，但是，注意并不包含构造函数。如果想要创建一个A类，并且A类要支持B类的API的话，但是又不想继承B类的实现的话，那么可以通过让A类来实现B类的接口。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>, I am <span class="subst">$_name<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">class Impostor implements Person &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  get _name =&gt; '</span><span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  String greet(String who) =&gt; '</span></span>Hi, <span class="subst">$who</span>, Do You Know Who I Am'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">'kay'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时一个类也能够用来实现多个接口，如下所示：</p><p>class Point implements PointA, PointB {…}</p><p><strong>17.枚举类型是一种特殊的类，使用enum关键字来定义一个枚举类。枚举中的每一个值都具有一个index getter方法，该方法这个值在枚举类型中的位置；每个枚举类型，都具有一个values实例常量，用来获取所有枚举值列表。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p><strong>18.使用mixins，使用类的时候with一个mixin，怎么实现一个mixin？使用mixin关键字进行定义，写法和类写法一样，除了使用mixin代替了class外。</strong></p><p><strong>19.静态变量和静态方法，使用static即可，注意，静态变量只有在被使用的时候才会初始化；静态方法因为不可以在实例上访问，所以无法访问this。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>dart基础1</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%801/"/>
    <id>http://yoursite.com/2019/01/05/dart基础1/</id>
    <published>2019-01-05T02:02:32.000Z</published>
    <updated>2019-01-05T07:42:10.258Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.使用var会自动进行类型推断，如果不想要类型推断的话，那么使用dynamic。</strong></p><p><strong>2.dart没有关键字public,protected,private，如果标识符以_开头，则说明它相对于库是私有的。</strong></p><p><strong>3.任何和变量进行捆绑的都是对象，无论它是不是基本类型。例如String,Number也是继承自Object类，是祖先类。</strong></p><p><strong>4.变量只是存储对象引用，声明定义变量可以有如下方式：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'bob'</span>; <span class="comment">// 会自动进行类型推断为String类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span> name1 = <span class="string">'i can change'</span>; <span class="comment">// 动态类型，为什么是动态？因为Object是所有对象的祖先类ya</span></span><br><span class="line"><span class="keyword">dynamic</span> name2 = <span class="string">'also change'</span>;  <span class="comment">// 也是动态类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> name3 = <span class="string">'me'</span>; <span class="comment">// 显式说明类型</span></span><br></pre></td></tr></table></figure><p><strong>5.在使用过程中不会发生变化的变量可以使用final或者const来声明，final变量的值只能被设置一次；const在编译时则已经固定。如果const变量是类级别的，需要标记为static const。</strong></p><p><strong>6.天秀const，像是回到了c指针又像是rust的mut，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span>;  <span class="comment">// 定义一个常量变量a，前面也提到了变量里面存储的是对象引用，所以这个变量a不能再被赋值了，只能指向'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">const</span> []; <span class="comment">// ???? 秀，这个时候的const是说明右值是不会发生变化的，因此使用aa变量的时候是不能修改到其引用的对象的</span></span><br><span class="line"></span><br><span class="line">aa = <span class="string">'ok'</span>; <span class="comment">// 话还没说完，但是变量aa并不是不可变的，所以变量aa是可以再次赋值，可以更改为指向其它对象的引用</span></span><br></pre></td></tr></table></figure><p><strong>7.String可以通过${expression}的方式内嵌表达式，如果表达式是一个标识符，则{}可以省略。</strong></p><p><strong>8.List就相当于js里面的Array，可以看看下面这种使用方法，其知识点正是上面所提到的那个const的地方：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">const</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// arr[1] = 1;  这种操作是会报错的，因为已经明确声明了变量arr所指向的对象是不可变的</span></span><br></pre></td></tr></table></figure><p><strong>9.Map就像是JavaScript里面的object一样，在一个map对象中一个key只能出现一次，下面介绍一下Map的用法：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">  <span class="string">'first'</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用map字面量来初始化一个对象，会被自动类型推断为Map&lt;String, String&gt;，所以如果有不符合类型推断的key或者value加入进去的话</span></span><br><span class="line"><span class="comment">// 那么将会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">Map</span>();</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">'one'</span>;</span><br><span class="line">m[<span class="number">2</span>] = <span class="string">'two'</span>;</span><br></pre></td></tr></table></figure><p>使用.length方法来获取当前map中的key-value对数量。创建一个Map类型运行时常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">'two'</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">'three'</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">'four'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>10.函数：如果函数中只有一句表达式的话，那么可以使用简写语法：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> n) =&gt; n !==<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><strong>11.函数的可选参数，函数具有两种参数类型，分别是required类型和optional类型，required类型参数放在参数的最前面，随后optional类型参数。其中可选参数又分为了命名参数和位置参数，一个可选参数只能是其中某一种。</strong></p><p><strong>12.命名可选参数，使用这种方式调用函数的时候很奇怪，看着像是js里面的object参数，但是又不是，其实也就是规定了参数的名字，让调用者明白对所传参数的意思更加一目了然？，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125; <span class="comment">// 这是定义函数时候的模样</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>); <span class="comment">// 这是调用函数时的模样，很奇怪吧</span></span><br></pre></td></tr></table></figure><p><em>（注：在flutter中，窗口小部件的构造函数仅使用命名参数），更易于阅读？</em></p><p>使用@required注释表明一个命名参数是必选的，其中@required被定义在package:meta/meta.dart里面，同时其它一些包也将其引入并导出了，比如说package:flutter/material.dart。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun(&#123;<span class="built_in">String</span> param1, <span class="meta">@required</span> <span class="built_in">bool</span> param2&#125;) &#123;...&#125; <span class="comment">// 如果在调用函数的时候没有传params参数的话将会报错</span></span><br></pre></td></tr></table></figure><p><strong>13.位置可选参数，将参数放到[]里面，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> say <span class="subst">$msg<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (device != null) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    result = '</span></span><span class="subst">$result</span> with <span class="subst">$device<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return result;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">say('</span></span>hai'</span>, <span class="string">'hello'</span>);</span><br><span class="line">say(<span class="string">'who'</span>, <span class="string">'hello'</span>, <span class="string">'wrchat'</span>);</span><br></pre></td></tr></table></figure><p><strong>14.默认参数值：可以使用=来定义可选参数的默认值，并且默认值只能是编译时常量，如果没有提供默认值的话，那么默认值为null。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'one'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'two'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list: <span class="subst">$list<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>gifts: <span class="subst">$gifts<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p><strong>15.main方法，任意一个dart应用都需要main函数，参数为一个可选的List<string></string></strong></p><p><strong>16.词法闭包</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeFun(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> add2 = makeFun(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> add4 = makeFun(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>17.关于算术操作需要注意的地方：/是返回浮点数；~/返回整数。</strong></p><p><strong>18.赋值运算符的花样，dart提供了一个??= 赋值运算符，只有当被赋值变量为null的时候，才会执行赋值操作，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b ??= value; <span class="comment">// 如果b为空的话，将变量赋值给b；否则，b的值保持不变</span></span><br></pre></td></tr></table></figure><p><strong>19.dart给条件表达式所新引入的东西：?? ； 用法如下所示：expr1 ?? expr2，如果expr1是non-null的话，那么返回expr1的值，否则返回expr2的值。</strong></p><p><strong>20.级联运算符..，用于支撑起链式调用，但是这里和js里所出现的又有所区别，多加了一个点。</strong></p><p><strong>21.流程控制语句：assert，如果assert语句中的布尔条件为false的话，那么正常的程序执行流程会被打断。assert的参数是可以解析成布尔值的任何表达式，如果表达式为true的话，则断言成功，程序继续执行。注，assert语句只在开发环境中有效。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.使用var会自动进行类型推断，如果不想要类型推断的话，那么使用dynamic。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.dart没有关键字public,protected,private，如果标识符以_开头，则说明它相对于库是私有的。&lt;/st
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>express开发小结</title>
    <link href="http://yoursite.com/2019/01/02/express%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/02/express开发小结/</id>
    <published>2019-01-02T13:27:49.000Z</published>
    <updated>2019-01-03T14:03:14.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.mongoose.model.prototype.findOne是一个promise，应该await一下的，否则的话，执行之后所返回的结果总会是true。</strong></p><p><strong>2.一个问题，如果请求头里面没有带上Content-Type为application/json的话，那么在某些时候会出现一些不确定的情况。</strong></p><p><strong>3.对于下面这个操作会出错，最好try…catch一下</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  id = mongoose.Types.Object(id);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'非法id'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.mongoose.model.prototype.findOne是一个promise，应该await一下的，否则的话，执行之后所返回的结果总会是true。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.一个问题，如果请求头里面没有带上Content
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Express值请求体中间件解析</title>
    <link href="http://yoursite.com/2018/12/29/Express%E5%80%BC%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/29/Express值请求体中间件解析/</id>
    <published>2018-12-29T05:55:40.000Z</published>
    <updated>2018-12-29T06:36:24.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.express请求体中间件有很多，比如说常见的body-parser,multer,formidable,这些中间件都各有各的应用场景,比如说body-parser很适合用来对application/x-www-form-urlencoded，application/json格式的表单请求做处理。multer中间件很适合对multipart/form-data的body，也就是说很适合处理文件上传。Formidable中间件可用于处理表单和上传文件，功能大而且全，既可以用来处理表单也能够用来处理上传文件。</strong></p><p><strong>2.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.express请求体中间件有很多，比如说常见的body-parser,multer,formidable,这些中间件都各有各的应用场景,比如说body-parser很适合用来对application/x-www-form-urlencoded，appli
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>express测试</title>
    <link href="http://yoursite.com/2018/12/28/express%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/12/28/express测试/</id>
    <published>2018-12-28T05:25:45.000Z</published>
    <updated>2018-12-28T10:04:55.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.测试API</strong></p><p>一个API基本上是一系列的代码块逻辑组成的，而对于mocha和chai来说，一般只是用来测试某个函数，所以就测试场景来说不是特别适合。因此有了Supertest，Supertest就不一样了，对于API测试来说，它会向server发送一个请求，自然的，server会对我们的请求作出响应，一旦做出了响应，那么我们便可以对响应进行断言，以此来测试响应数据是否正确。</p><p><strong>2.关键库supertest</strong></p><p>示例代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"><span class="keyword">const</span> supertest = <span class="built_in">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'html test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    request = supertest(app)</span><br><span class="line">      .get(<span class="string">'/html'</span>)</span><br><span class="line">      .set(<span class="string">'User-Agent'</span>, <span class="string">'cool supertest'</span>)</span><br><span class="line">      .set(<span class="string">'Accept'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'return html response'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    request</span><br><span class="line">      .expect(<span class="string">'Content-Type'</span>, /text\/html/)</span><br><span class="line">      .expect(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> $ = cheerio.load(res.text);</span><br><span class="line">        <span class="keyword">let</span> domContent = $(query).text();                  <span class="comment">// 获取query处的content</span></span><br><span class="line">        <span class="keyword">if</span> (domContent !== <span class="string">'CONTENT_YOU_WANT'</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'content do not match'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .expect(<span class="number">200</span>)</span><br><span class="line">      .end(done);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.测试API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个API基本上是一系列的代码块逻辑组成的，而对于mocha和chai来说，一般只是用来测试某个函数，所以就测试场景来说不是特别适合。因此有了Supertest，Supertest就不一样了，对于API测试来说
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>flutter之widget基础</title>
    <link href="http://yoursite.com/2018/12/28/flutter%E4%B9%8Bwidget%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/28/flutter之widget基础/</id>
    <published>2018-12-27T16:36:20.000Z</published>
    <updated>2018-12-28T15:16:27.444Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.基础概念</strong></p><p>widget不仅只描述UI。widget是描述一个UI元素的配置数据；widget并不是绘制在屏幕的UI的抽象，那是Element，Widget只是描述Element的配置；一个Widget可以对应多个Element。</p><p>StatelessWidget适用于不需要维护状态的场景，通常在build方法中嵌套其它Widget来构建UI。</p><p>StatefulWidget继承自Widget类，并重写了createElement方法，而且还提供了一个新的接口createState。其中createState用于创建和Stateful widget相关的状态，如果一个stateful widget被插入到widget树的多个位置的话，那么flutter framework会调用该方法为每一个位置生成一个独立的state实例。</p><p><strong>2.State</strong></p><p>一个StatefulWidget类会对应一个State类，State表示的是其需要进行维护的状态。这些状态信息能够在widget build时被同步获取；State所维护的状态信息可以在widget的生命周期中被改变，当state发生变化后，可以手动调用setState来通知flutter状态发生了变化，flutter在收到通知后，会重新调用build方法构建widget树，从而达到更新UI的目的。</p><p>state有两个常用的属性，这里做个介绍：</p><ul><li><p>1.widget：表示和本State实例所关联的widget实例；由于State实例只会在widget第一次被插入到树中时被创建，所以State实例和widget的对应关系是动态化的，当重新构建的时候widget发生了变化的话，那么flutter会动态设置State实例的widget属性为新的widget实例；</p></li><li><p>2.context：BuildContext类的一个实例，表示构建widget的上下文。</p></li></ul><p><strong>3.Widget的生命周期</strong></p><ul><li>1.initState：当一个statewidget第一次被插入到widget树的时候会首先调用它，对于每一个state对象，flutter只会调用一次该回调，通常在这个回调中只会做一些一次性的动作。</li><li>2.didChangeDependencies</li><li>3.build</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.基础概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;widget不仅只描述UI。widget是描述一个UI元素的配置数据；widget并不是绘制在屏幕的UI的抽象，那是Element，Widget只是描述Element的配置；一个Widget可以对应多个Eleme
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之包管理</title>
    <link href="http://yoursite.com/2018/12/27/flutter%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/27/flutter之包管理/</id>
    <published>2018-12-26T17:13:48.000Z</published>
    <updated>2018-12-26T17:28:50.206Z</updated>
    
    <content type="html"><![CDATA[<p><em>1.基本概念</em></p><p>包管理的配置文件采用yaml格式，默认配置文件叫做pubspec.yaml，位于项目根目录。</p><p><em>2.各个字段的基本意义</em></p><ul><li>1.name: 应用或者包名称</li><li>2.description: 应用或者包的简介</li><li>3.version: 应用或者包的版本号</li><li>4.dependencies: 应用或者包的依赖</li><li>5.dev_dependencies: 开发环境依赖</li><li>6.flutter: flutter相关配置选项</li></ul><p><em>3.包仓库</em></p><p>Flutter的包管理仓库就是dart语言的包管理仓库，叫做pub仓库，类似于npm仓库。添加一个依赖包只需要根性pubspec.yaml即可，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  packageName:</span> <span class="string">PACKAGE_VERSION</span>  <span class="comment">## 直接使用pub仓库的包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  package1:</span> <span class="string">./lib/package1</span>  <span class="comment">## 使用本地包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  pkg2:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="string">git_url</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">src/pkg2</span>    <span class="comment">## 如果不在仓库的根目录下的话，那么就加上相对路径，在的话则无需这步</span></span><br></pre></td></tr></table></figure><p><em>4.引入包</em></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:pkg2/pkg2.dart'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;1.基本概念&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;包管理的配置文件采用yaml格式，默认配置文件叫做pubspec.yaml，位于项目根目录。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.各个字段的基本意义&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.name: 应用或者包名称&lt;/li&gt;
&lt;li&gt;2
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter学习1</title>
    <link href="http://yoursite.com/2018/12/26/flutter%E5%AD%A6%E4%B9%A01/"/>
    <id>http://yoursite.com/2018/12/26/flutter学习1/</id>
    <published>2018-12-26T07:08:12.000Z</published>
    <updated>2018-12-26T17:05:39.316Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.JIT以及AOT</strong></p><p>JIT是just in time的缩写，表明即时编译，是指一边编译一边运行，Javascript和Python属于这一种类别；AOT则是需要经过提前编译，将其编译为机器码，典型代表是C/C++类语言。</p><p><strong>2.开发环境安装</strong></p><p>按照官网流程步骤进行安装，使用真机运行flutter的话如果想要体验热重载的话那么只需要在控制台下按下r键即可，终端下输入flutter run运行即可。</p><p><strong>3.dart简介</strong></p><p>1.<em>dart是强类型语言</em>，使用var关键字来定义变量，一旦变量被赋值，那么变量的类型就被确定了，后续不能进行修改。比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str; <span class="comment">// 说明没有什么默认赋值</span></span><br><span class="line">str = <span class="string">'hello world'</span>;</span><br><span class="line">str = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>2.<em>dynamic和Object</em>：功能和var相似，都能够在赋值时进行类型推断，不同在于，赋值后可以改变其类型。而Object在dart里面是所有对象的基类，也就是说其它类型都是Object的子类，所以任何数据类型的数据都可以赋值给Object声明的对象，在表现上和dynamic类似。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> t;</span><br><span class="line">t = <span class="string">'hello world'</span>;</span><br><span class="line">t = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>3.<em>final和const</em></p><p>如果你不打算修改一个变量的话，那么使用final和const，final和const的区别在于，const变量是一个编译时常量，final变量则在使用的时候才被初始化。使用final和const修饰变量，变量类型可以省略。</p><p><em>4.函数</em></p><p>dart函数如果没有显示申明返回类型的话，那么返回类型将会是dynamic，函数返回值不具有类型推断功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> CALLBACK();</span><br><span class="line"></span><br><span class="line">isNoble(<span class="built_in">int</span> atom) &#123;</span><br><span class="line">  <span class="keyword">return</span> _noble[atom] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test(CALLBACK cb) &#123;</span><br><span class="line">  <span class="built_in">print</span>(cb());</span><br><span class="line">&#125;</span><br><span class="line">test(isNoble);</span><br></pre></td></tr></table></figure><p>箭头函数：单行函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble (<span class="built_in">int</span> atomic) =&gt; _noble[atomic] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>函数作为参数传递：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的var cb</span></span><br><span class="line"><span class="keyword">void</span> exec(<span class="keyword">var</span> cb) &#123;</span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line">exec(() =&gt; <span class="built_in">print</span>(<span class="string">'xxx'</span>));</span><br></pre></td></tr></table></figure><p>可选参数，利用[]进行标记</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (device != null) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    result = '</span></span><span class="subst">$result</span> with a <span class="subst">$device<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return result;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">say('</span></span>i'</span>, <span class="string">'am ok'</span>);</span><br><span class="line">say(<span class="string">'i'</span>, <span class="string">'am ok'</span>, <span class="string">'oneplus a5000'</span>);</span><br></pre></td></tr></table></figure><p><em>flutter命名参数？</em></p><p><em>5.异步</em></p><p>典型的异步函数有返回Future和Stream这些东西的函数，Future和JavaScript中的Promise是非常相像的.</p><p><em>6.基本知识</em></p><ul><li><p>1.Flutter中main函数是整个应用程序的入口，main函数中会调用runApp方法，他的功能是启动Flutter应用，这个函数所接受的参数为一个Widget类型的参数，换言之，一个Flutter应用本身就是一个widget。一个widget的主要工作就是提供一个build方法来描述该怎么构建UI界面（一般就是通过组合方式）。home是Flutter应用的首页，同时也是一个widget。</p></li><li><p>2.Stateful Widget和Stateless Widget的明显区别在于前者可以具有状态，而后者并不拥有。同时一个Stateful Widget至少由两个类组成：一个StatefulWidget类；一个State类。</p></li></ul><p><em>7.路由</em></p><p>Route在Android里面对应一个Activity，在IOS中对应的是ViewController。当然，在Flutter中一个Route也是一个widget，只不过这个widget会通过路由操作呈现在UI上面，定义一个widget如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AboutMe</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scafford(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'我的'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">            child: Text(<span class="string">'这个人很懒，什么也没有留下'</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好了一个Widget，那么怎么进行使用呢？答案就是利用Flutter提供的Navigator方法来实现路由操作，比如像下面这样的将路由push到路由栈的顶部：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scafford(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">            title: <span class="keyword">new</span> Text(<span class="string">'首页'</span>)</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">            child: <span class="keyword">new</span> Column(</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  FlatButton(</span><br><span class="line">                      child: Text(<span class="string">'我的'</span>),</span><br><span class="line">                      textColor: Colors.blue,</span><br><span class="line">                      onPressed: () &#123;</span><br><span class="line">                        Navigator.push(</span><br><span class="line">                            context,</span><br><span class="line">                            <span class="keyword">new</span> MaterialPageRoute(builder: (context)&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> AboutMe();</span><br><span class="line">                            &#125;)</span><br><span class="line">                        );</span><br><span class="line">                      &#125;</span><br><span class="line">                  )</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点就是利用Navigator.push进行路由跳转，将一个widget路由页面通过MaterialPageRoute进行包装一下，MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，来自于Material组件库，实现与平台一致的动画效果；Navigator是Flutter提供的路由管理的widget，它通过一个栈来管理一个路由widget集合。下面是其暴露出了的两个常用的方法：</p><ul><li>Future push(BuildContext context, Route route)：将页面进行入栈</li><li>bool pop(BuildContext context)：将页面出栈</li></ul><p><em>8.命名路由</em></p><p>基本概念：给路由命名，之后便能直接通过路由名字打开一个新路由：</p><p>1.路由表表里面注册路由，到根widget里面进行注册routes，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'APP'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(primarySwatch: Colors.blue),</span><br><span class="line">        home: <span class="keyword">new</span> Index(),</span><br><span class="line">        routes: &#123;</span><br><span class="line">          <span class="string">"About"</span>: (context) =&gt; AboutMe()</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过路由名字打开一个路由需要调用Navigator.pushNamed方法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">'About'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Navigator.push(context,</span></span><br><span class="line"><span class="comment">  new MaterialPageRoute(builder: (context) &#123;</span></span><br><span class="line"><span class="comment">      return new AboutMe();</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.JIT以及AOT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JIT是just in time的缩写，表明即时编译，是指一边编译一边运行，Javascript和Python属于这一种类别；AOT则是需要经过提前编译，将其编译为机器码，典型代表是C/C++类语言。&lt;/
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>express2之database</title>
    <link href="http://yoursite.com/2018/12/20/express2%E4%B9%8Bdatabase/"/>
    <id>http://yoursite.com/2018/12/20/express2之database/</id>
    <published>2018-12-20T15:14:29.000Z</published>
    <updated>2018-12-23T08:45:43.031Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.基本名词</strong></p><p>在MongoDB中，每个database都会有一个或者多个collection，为了便于理解，可以把collection理解为array。一个collection里可以拥有任意个documents，一个documents很像js里面的对象，同一个collection里面的documents不必存储具有同样数据结构的数据。注意在技术上，documents并不是作为JSON存储的，documents看起来很像json，但是实际上它是binary JSON，俗称BSON。Mongo会给每个document增加一个_id属性，这个_id属性是独一无二的。</p><p><strong>2.关于加密库</strong></p><p>node不适合做计算密集型的工作任务，而对于密码学来说，往往需要很大的计算量，辛亏在node中可以很方便的调用node的扩展，所以有个bcrypt的库，其使用了C代码来处理这部分计算，加快了计算量。</p><p><strong>3.POST请求之body-parser</strong></p><p>POST请求传过来的参数可以是多种编码格式的，这个可以通过请求头里面的Content-Type字段看出，比如说下面这些：application/x-www-form-urlencoded(常见于form注册)，application/json常见于ajax发送json数据的时候，除了上面两种Content-Type之外，还存在其他常用的content-type，可以查阅相关资料，这里要说的是，在express中如何在req.body里面使用它们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;)); <span class="comment">// 针对application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 针对application/json</span></span><br></pre></td></tr></table></figure><p><strong>4.express之用户鉴权</strong></p><p>用户鉴权具有很多种方式，常见的有session-cookie机制，token机制，OAuth机制，下面进行逐一介绍：</p><p>4-1.session-cookie机制：基本概念：服务端的session，客户端的cookie，利用cookie和session来完成前后端的认证。因为HTTP请求是无状态的，所以服务器不能识别出用户的身份。采用session-cookie机制的话，就引入了一种判断用户身份的唯一标志session，每当用户进行登录的时候，服务端便会为该用户创建一个session（会话），这个session能够用来唯一标识用户，那么问题来了，session是服务端的，那么下次这个客户端的请求到来时，服务器怎么知道是这个用户呢？答案就是让用户携带和自己session所唯一对应的cookie进来，这个cookie在用户进行登录成功的时候服务端便设置好了，以后的客户端的每一次请求便会把这个cookie给携带进来，而服务端在每一次请求到来时都会去查一下该客户在本地有没有对应session，如果有的话，那么就说明验证成功了。</p><p>session-cookie机制主要分为下面几个步骤：</p><p>①.服务器在用户成功登录后在服务器端创建session-&gt;持久化保存session-&gt;给这个session生成一个唯一对应的sessionId</p><p>②.sessionId签名，根据设置的secret对sid进行加密处理，下次收到sid时接着会根据secret进行解密处理。（注意签名过程非必须）-&gt; 在该请求的响应头中种下这个sid。</p><p>③.浏览器在收到响应后，将sid保存到本地cookie中，使得浏览器接下来的请求能够将sid存在cookie中发送给服务端。</p><p>④.服务端在需要登录的接口上面验证客户端时候携带了sid，并且查找这个sid是否有在服务端中维护，如果有的话，那么就说明鉴权通过。</p><p>4-2:在Express中如何使用passport插件，首先要搞清楚，passport不负责实现鉴权逻辑，它只是一层包装，鉴权逻辑在包装里面，需要开发人员自行编写。使用passport进行用户鉴权的话，开发人员主要完成下面三部分逻辑处理：</p><p>①.在Express中引入中间件。</p><p>②.告诉passport如何去序列化和反序列化用户，这部分将用户的session映射成了实际的user object。</p><p>③.告诉passport怎么进行用户授权，既判断一个用户是否在系统中。 这个时候passport会和Mongo进行接触。</p><p>第一步：引入相关中间件，这个步骤依赖body-parser，cookie-parser，express-session，passport，passport-local。</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookieParser'</span>);</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> authSetting = <span class="built_in">require</span>(<span class="string">'./authSetting'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>, &#123; <span class="attr">userNewUrlParser</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">authSetting(); <span class="comment">// 一个配置passport的文件</span></span><br><span class="line"></span><br><span class="line">app.use(passport.initialize());</span><br><span class="line">app.use(passport.session());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));                          <span class="comment">// content-type 为 x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.json());                                                   <span class="comment">// content-type 为 application/json</span></span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">'YOU_SESSION_SECRET'</span>,</span><br><span class="line">  resave: <span class="literal">true</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>第二步：告诉passport怎么序列化用户和反序列化用户。思考一下在express MongoDB技术栈里面如何将用户传过来的sid对应到user object上面，我们知道在MongoDB里面每一个文档都具有一个唯一的_id字段，利用这个字段来唯一标识用户是个可行的办法，并且查询的时候利用_id来查，效率也会比普通字段属性会更好。下面是实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authSetting.js</span></span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./models/user'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化用户，将用户转化为id</span></span><br><span class="line">  passport.serializeUser(<span class="function"><span class="keyword">function</span>(<span class="params">user, done</span>) </span>&#123;</span><br><span class="line">    done(<span class="literal">null</span>, user._id);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 解序列化用户，将用户id转化为user object</span></span><br><span class="line">  passport.deserializeUser(<span class="function"><span class="keyword">function</span>(<span class="params">id, done</span>) </span>&#123;</span><br><span class="line">    User.findById(id, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">      done(err, user);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三步：如何进行用户授权，在这一步中需要用上策略，这本例中使用本地策略。使用本地策略需要引入一个npm包-passport-local，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原有authSetting.js中加入</span></span><br><span class="line"><span class="keyword">const</span> LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>).Strategy; <span class="comment">// 引入本地passport-策略包</span></span><br></pre></td></tr></table></figure><p>接下来就是制定本地策略，如下所示：1.客户端在进行登录的时候，服务端获取到用户名（或其他id)；2.服务端根据这个用户名查找mongodb数据库中是否存在该用户，如果没有的话，可以返回这个用户未注册；3.如果存在这个用户的话，那么继续比对密码，如果密码正确的话，那么返回user object，如果密码比对错误的话，那么返回密码错误。示例代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authSetting.js</span></span><br><span class="line">passport.use(<span class="string">'login'</span>, <span class="keyword">new</span> LocalStrategy(<span class="function"><span class="keyword">function</span>(<span class="params">username, password, done</span>) </span>&#123;</span><br><span class="line">  User.findOne(&#123;username&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查询数据库的时候报错</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在这个用户</span></span><br><span class="line">    <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'No User Has That Username'</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    user.checkPassword(password, <span class="function"><span class="keyword">function</span>(<span class="params">err, isMatch</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;  <span class="comment">// 取密码出错</span></span><br><span class="line">        <span class="keyword">return</span> done(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isMatch) &#123;  <span class="comment">// 有这个用户，则返回这个用户</span></span><br><span class="line">        <span class="keyword">return</span> done(<span class="literal">null</span>, user);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 密码错误</span></span><br><span class="line">        <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Invalid password.'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>4-2.token机制：和session-cookie很像。大致流程如下所示：</p><p>①.客户进行登录</p><p>②.如果成功登录，服务端给这个用户生成一个唯一对应的token，并且将这个token返回给客户端</p><p>③.客户端将这个token进行存储</p><p>④.客户端接将token放在请求头里面发送给服务端</p><p>⑤.服务端在需要登录的页面中进行token验证，如果请求通过的话则放行。</p><p>和session-cookie的区别：</p><p>①.session-cookie需要经过一个中间层sid，而token不需要，就是直接代表了用户，并且在用户端和服务端之间传输。</p><p>②.不需要cookie进行配合，</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.基本名词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在MongoDB中，每个database都会有一个或者多个collection，为了便于理解，可以把collection理解为array。一个collection里可以拥有任意个documents，一个docum
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>小程序性能优化</title>
    <link href="http://yoursite.com/2018/12/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/12/18/小程序性能优化/</id>
    <published>2018-12-18T05:32:50.000Z</published>
    <updated>2018-12-18T05:32:50.176Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="http://yoursite.com/2018/12/13/express/"/>
    <id>http://yoursite.com/2018/12/13/express/</id>
    <published>2018-12-13T14:11:01.000Z</published>
    <updated>2018-12-29T03:22:50.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。"><a href="#1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。" class="headerlink" title="1.express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。"></a>1.express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。</h3><h3 id="2-express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示："><a href="#2-express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示：" class="headerlink" title="2.express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示："></a>2.express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> morgan = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(morgan(<span class="string">'dev'</span>));</span><br></pre></td></tr></table></figure><h3 id="3-实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then-以及catch-的参数。一个Promise只能够被决议一次。"><a href="#3-实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then-以及catch-的参数。一个Promise只能够被决议一次。" class="headerlink" title="3.实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then()以及catch()的参数。一个Promise只能够被决议一次。"></a>3.实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then()以及catch()的参数。一个Promise只能够被决议一次。</h3><h3 id="4-express中间件的形式形如下面这样："><a href="#4-express中间件的形式形如下面这样：" class="headerlink" title="4.express中间件的形式形如下面这样："></a>4.express中间件的形式形如下面这样：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleWare</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do stuff with request and/or response</span></span><br><span class="line">  next(); <span class="comment">// when our middleware done,call the next middleWare to do work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你甚至可以创建一些下面这种没意思但是有趣的middleware</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, req.method, req.url); <span class="comment">// 打印请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a joke</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds();</span><br><span class="line">  <span class="keyword">if</span> (second % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">403</span>).json(&#123;<span class="string">"from_me"</span>: <span class="string">"403 forbidden"</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-一些不可错过的中间件之静态文件中间件："><a href="#5-一些不可错过的中间件之静态文件中间件：" class="headerlink" title="5.一些不可错过的中间件之静态文件中间件："></a>5.一些不可错过的中间件之静态文件中间件：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(PUBLIC_PATH));</span><br></pre></td></tr></table></figure><p>关于express.static中间件有一个需要注意的问题就是，当这个中间件进行了有效的服务的话（指分发了静态资源），那么它将会阻止中间件 chain，相当于不会调用next；但是如果没有匹配到需要分发的静态资源的话，那么会调用next，将执行权利继续交给下一个midlleware。所以最佳实践是将静态资源中间件放在后面的适当位置（自然是要放在404 middleware前面的）。</p><h3 id="6-路由：routing-is-a-way-to-map-requests-to-specific-handlers-depending-on-their-URL-and-HTTP-verb。"><a href="#6-路由：routing-is-a-way-to-map-requests-to-specific-handlers-depending-on-their-URL-and-HTTP-verb。" class="headerlink" title="6.路由：routing is a way to map requests to specific handlers depending on their URL and HTTP verb。"></a>6.路由：routing is a way to map requests to specific handlers depending on <strong>their URL and HTTP verb</strong>。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/hello/:who'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">`&lt;h1&gt;hello <span class="subst">$&#123;req.params.who&#125;</span>&lt;/h1&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-重定向："><a href="#7-重定向：" class="headerlink" title="7.重定向："></a>7.重定向：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/redirect'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.redirect(<span class="string">'/index'</span>); <span class="comment">// 站内重定向，或者像下面这样，重定向到其他站点</span></span><br><span class="line">  <span class="comment">// res.redirect('http://www.expressjs.com');</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-发文件："><a href="#8-发文件：" class="headerlink" title="8.发文件："></a>8.发文件：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">'somePath'</span>);</span><br><span class="line">app.get(<span class="string">'/file'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(filePath); <span class="comment">// 需要注意的是并不会触发下载操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）："><a href="#9-获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）：" class="headerlink" title="9.获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）："></a>9.获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.ip, req.method, req.url);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="10-获取请求头中的某个字段的值："><a href="#10-获取请求头中的某个字段的值：" class="headerlink" title="10.获取请求头中的某个字段的值："></a>10.获取请求头中的某个字段的值：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.ip, req.method, req.url, req.get(<span class="string">'Accept-Language'</span>));</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="11-视图（采用ejs视图为例）："><a href="#11-视图（采用ejs视图为例）：" class="headerlink" title="11.视图（采用ejs视图为例）："></a>11.视图（采用ejs视图为例）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'views'</span>, path.resolve(__dirname, <span class="string">'VIEWS_PATH'</span>));              <span class="comment">// 第一步设置视图文件所在的文件位置</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'ejs'</span>);                                         <span class="comment">// 设置视图引擎为EJS</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;<span class="attr">message</span> : <span class="string">'ejs template'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// VIEWS_PATH/index.ejs</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;ejs&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;%= message %&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><h3 id="12-让所有视图都可以使用某个数据-将这个数据挂载到app-locals下面即可-："><a href="#12-让所有视图都可以使用某个数据-将这个数据挂载到app-locals下面即可-：" class="headerlink" title="12.让所有视图都可以使用某个数据(将这个数据挂载到app.locals下面即可)："></a>12.让所有视图都可以使用某个数据(将这个数据挂载到app.locals下面即可)：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.locals.allCanUse = <span class="string">'all the views template can use this me'</span>;</span><br></pre></td></tr></table></figure><h3 id="13-res-end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。"><a href="#13-res-end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。" class="headerlink" title="13.res.end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。"></a>13.res.end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。</h3><h3 id="14-Express中的middleware-stack"><a href="#14-Express中的middleware-stack" class="headerlink" title="14.Express中的middleware stack"></a>14.Express中的middleware stack</h3><p>首先有很重要的一点需要明白，那就是express是基于node进行处理的，前面也提到了，node处理输入并作出响应可以被抽象为对req object以及res object的处理，node把每个网络中传输过来的二进制请求转换为JavaScript object，当我们做好了响应后，使用res.end便又把响应数据发送给了客户端。在原生的node里面，这两个对象在一个函数过程里面进行处理。而在express中，req，res这两个对象是经由一系列的函数数组进行处理的，这个函数数组便叫做middleware stack了。具体过程便是：1.请求到达node server-&gt;2.交接给express APP进行处理-&gt;3.express中middleware stack中的每一个函数对请求进行处理-&gt;4.处理好了之后将结果返回给node server-&gt;5.发回给客户。</p><p>middleware stack中的每一个函数都接受三个参数，其中前两个分别是req和res，他们都是node server产生的，当然express在两个对象的基础上进行了一些增强。第三个参数就是next，是一个函数类型的变量。</p><p>当处理好了响应（响应数据已经可以发送给客户端了）的时候，调用res.end方法即可；当然在express中，我们也可以通过调用其他方法比如说res.send和res.sendFile或者json等，无论如何，上面这些提到的方法都将调用res.end。</p><p>对于一个中间件来说，下面两个动作必须执行其中的某一个，否则会发生错误（比如请求一直被挂起）。两个动作分别如下所示：</p><ul><li>1.作出响应，具体来说就是调用res.end或者res.send,以及res.sendFile等；</li><li>2.调用next()将执行权利交出去，让middleware stack中的下一个函数执行；</li></ul><p><strong>15.错误中间件，错误中间件具有四个参数，按照顺序来分别是(err, req, res, next)。如果在某个正常的中间件中，调用next方法的时候传入了一个Error参数的话，那么当这个中间件执行完后，接下来执行的中间件有可能就不是下一个中间件了，而是下一个错误捕获中间件。并且错误中间件也能够调用next方法，同理，如果往next里面传入了一个错误参数的话那么也是跳到最近的下一个错误中间件。举个例子：假如有A,B,C,D,E,F这六个中间件，其中中间件C和中间件E都是错误中间件的话，那么当在执行B中间件的时候如果next的参数是一个error的话，那么执行权就到了最近的下一个错误捕获中间件C，如果继续在中间件C中的next方法传入一个error参数的话，那么执行权就又到了E错误中间件。</strong></p><p><strong>16.路由：express能够根据HTTP动作和请求资源将请求链接到相应的controller上面。</strong></p><p>动态路由匹配使用下面这种模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/users/:userId'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do some stuff</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>类似于上面这样的路由能够动态匹配到/users/123和/users/ebooks等类似的；但是对于像下面这样的路由是匹配不到的：/users/或者/users/123/photo等类似的。</p><p><strong>17.动态路由匹配之使用正则表达式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/^\/users\/(\d+)$/</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> userId = <span class="built_in">parseInt</span>(req.params[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于上面这个例子来说，我们定义的正则表达式所表达的意思是指：必须是以/users开始，以一个数字或者多个数字结尾的路由；使用正则表达式来定义动态路由匹配和使用普通字符串来匹配路由有一个区别就是，正则表达式没有给动态内容命名，对于这种情况，express是这样处理的：利用索引进行访问，每个被正则表达式所匹配到的值都会顺序占据数组的一个位置。所以看看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/^\/users\/(\d+)-(\d+)$/</span>, (req, res) =&gt; &#123; <span class="comment">// 貌似一个圆括号是一个匹配单位</span></span><br><span class="line">  <span class="keyword">let</span> startId = <span class="built_in">parseInt</span>(req.params[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">let</span> endId = <span class="built_in">parseInt</span>(req.params[<span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看一个更加复杂的匹配要求，要求匹配 xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx，其中x是任意一个十六进制中的一个数，y是8，9，A，B中的某一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^([0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-4[0-9a-f]&#123;3&#125;-[89AB][0-9a-f]&#123;3&#125;-[0-9a-f]&#123;12&#125;)$/i</span>;</span><br><span class="line">app.get(reg, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> uuid = req.params[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>18.路由值查询字符串匹配</strong></p><p>先看一个正常的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url像这样：/search?key=chaos</span></span><br><span class="line">app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> key = req.query.key; <span class="comment">// 值是一个字符串</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看一个不太正常的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url像这样：/search?key=oh&amp;key=no ; 糟糕的url设计</span></span><br><span class="line">app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = req.query.key; <span class="comment">// 由于两个query的键名一样，所以键值是一个数组！！！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>19.express路由：</strong></p><p>Routers就是一个中间件的角色，可以使用app.use方法在express的实例化对象中使用这个这个中间件。换句话说，routes把我们整个应用分割成了几份小app来对待，这可以避免在app.js里面出现大量的路由逻辑代码，避免app.js变得越来越臃肿。</p><p>下面可以看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">'./routes/apiRouter'</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/api'</span>, apiRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes/apiRouter.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = express.Router();</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.status(<span class="number">200</span>).send(<span class="string">'获取用户列表数据成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'/topic'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.status(<span class="number">200</span>).send(<span class="string">'获取热点数据成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = api;</span><br></pre></td></tr></table></figure><p><strong>20.https一些基础知识</strong></p><p>https之所以比http安全，是因为他在http的基础上增加了一层协议——TLS或SSL，这里简单的提一下TLS。TLS使用的加密技术简单来说就是这样：每个节点中的设备都具有一个public key和一个private key，其中public key只有自己知道，而private key则所有网络中的其他节点都能知道。当节点A想传数据给节点B的时候，节点A发送的信息会使用自己的private key和节点B的public key进行加密，当节点B接收到数据后，在利用自己的private key和节点A的public key进行解密。由于理论上，自己的private key只有自己知道，因此即使传输数据被其它设备给非法获取的话，那么也不能够破解出传输内容。</p><p><strong>21.在express中既使用http服务也使用https服务：</strong></p><p>利用HTTPS的话首先需要用户私钥以及凭证，我们可以利用OpenSSL来生成，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 项目根目录</span></span><br><span class="line">openssl genrsa -out privatekey.pem 1024           <span class="comment">## 生成私钥</span></span><br><span class="line">openssl req -new -key privatekey.pem -out request.pem       <span class="comment">## 生成凭证</span></span><br></pre></td></tr></table></figure><p>在express中既启动http服务又启动https服务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目根目录index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpsOptions = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'./privatekey.pem'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'./request.pem'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">80</span>);</span><br><span class="line">https.createServer(httpsOptions, app).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure><p><strong>22.http动词进一步认识</strong></p><ul><li>1.GET: GET方法不应该改变应用的状态，GET是幂等性的，这意味着你从服务器连续取500次某种资源的结果和只取一次的结果应该是一样的，资源不应该发生变化。</li></ul><p><strong>23.api version：为了兼容老用户，但是新的业务逻辑又的确需要更改</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api1.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = express.Router();</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'time'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123; <span class="attr">time</span>: str &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> routerV1 = <span class="built_in">require</span>(<span class="string">'./api1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'v1'</span>, routerV1); <span class="comment">// url =&gt; /v1/time</span></span><br><span class="line">app.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'port 8080'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>24.一些HTTP状态码:</strong></p><ul><li><ol><li>100 =&gt; Continue</li></ol></li><li><ol start="2"><li>101 =&gt; Switch Protocol</li></ol></li><li><ol start="3"><li>200 =&gt; Ok</li></ol></li><li><ol start="4"><li>201 =&gt; 成功，常见于PUT请求和POST请求</li></ol></li><li><ol start="5"><li>202 =&gt; 成功收到请求，但是请求的东西还在处理过程中</li></ol></li><li><ol start="6"><li>301 =&gt; don’t visit this url any more</li></ol></li><li><ol start="7"><li>401 =&gt; 未授权 Unauthorized</li></ol></li><li><ol start="8"><li>403 =&gt; 无权 Forbidden</li></ol></li><li><ol start="9"><li>404 =&gt; 资源找不到</li></ol></li><li><ol start="10"><li>500 =&gt; 服务器出错了</li></ol></li></ul><p><strong>25.从req.headers中获取到你想要访问的请求头</strong></p><ul><li>req.headers.origin: 资源发起位置</li><li>req.headers.referer: 原始资源位置</li></ul><p><strong>26.HTTP的OPTIONS方法用于获取目的资源所支持的通信选项，客户端可以对特定的URL使用OPTIONS方法，也可以对整站使用OPTIONS方法（通过将URL设置为通配符*）即可。同时，在跨域中，在发起一个正式请求之前也一定会发起一个预检请求，这个预检请求会被服务器检查是否支持接下来的实际请求，这个预检请求报文中的Access-Control-Request-Method首部字段的值就是实际请求中的Access-Control-Request-Method的值，预检请求报文中的Access-Control-Request-Headers首部字段的值就是接下来实际请求中的Access-Control-Request-Method的值，服务器在收到OPTOINS预检请求后，会返回一个Access-Control-Allow-Methods首部字段，这个字段会表明服务器所允许的请求方法，和Allow字段类似，但是Access-Control-Allow-Methods只会用在CORS上面（注意GET,HEAD,POST可能不受此限制)。</strong></p><p><strong>27.前面提到了预检请求，那么在客户端发送了一个预检请求后，如果预检请求后客户端发送请求头中method和服务端返回的响应头中的method不匹配的话，那么该怎么阻挡下次正式请求发送呢？答案就是浏览器会自动判断，如果不匹配的话，那么浏览器会自动阻止下次正式请求的发起。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。&quot;&gt;&lt;a href=&quot;#1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch</title>
    <link href="http://yoursite.com/2018/12/13/elasticsearch/"/>
    <id>http://yoursite.com/2018/12/13/elasticsearch/</id>
    <published>2018-12-13T09:00:42.000Z</published>
    <updated>2018-12-13T14:13:05.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>需要先安装Java环境，接着直接到elasticsearch官网下载软件包，解压缩。启动到其解压后目录，运行./bin/elasticsearch即可。</p><p>测试是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9200/</span><br></pre></td></tr></table></figure><p>能看到序列化后的json字符串输出就说明成功启动了。（注意在启动时的日志上面会标明elasticsearch的启动端口以及IP）。</p><h3 id="2-ElasticSearch以及restful"><a href="#2-ElasticSearch以及restful" class="headerlink" title="2.ElasticSearch以及restful"></a>2.ElasticSearch以及restful</h3><p>restful：url就表示客户需要的资源，而需要对资源进行什么操作体现在http方法上。和大部分场景一样，在ElasticSearch中，资源就是json文档，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h3&gt;&lt;p&gt;需要先安装Java环境，接着直接到elasticsearch官网下载软件包，解压缩。启动到其解压后目录，运行./bin/el
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nodejs之process</title>
    <link href="http://yoursite.com/2018/12/12/nodejs%E4%B9%8Bprocess/"/>
    <id>http://yoursite.com/2018/12/12/nodejs之process/</id>
    <published>2018-12-12T11:57:32.000Z</published>
    <updated>2018-12-12T14:10:01.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"><a href="#1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。" class="headerlink" title="1.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"></a>1.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。</h3><h3 id="2-使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示："><a href="#2-使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示：" class="headerlink" title="2.使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示："></a>2.使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;   <span class="comment">// 判断是否是主进程</span></span><br><span class="line">  <span class="comment">// 每当成功创建一个进程，便会emit一个online事件，而主进程能够监听这个事件</span></span><br><span class="line">  cluster.on(<span class="string">'online'</span>, worker =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> is online`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;    <span class="comment">// 创建10个worker</span></span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 这是worker，每个worker运行的工作可以放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-被fork出来的process也被叫做worker-每个worker能够和master通过各种events来进行交流。"><a href="#3-被fork出来的process也被叫做worker-每个worker能够和master通过各种events来进行交流。" class="headerlink" title="3.被fork出来的process也被叫做worker,每个worker能够和master通过各种events来进行交流。"></a>3.被fork出来的process也被叫做worker,每个worker能够和master通过各种events来进行交流。</h3><h3 id="4-再看一下下面这个例子："><a href="#4-再看一下下面这个例子：" class="headerlink" title="4.再看一下下面这个例子："></a>4.再看一下下面这个例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CPUS = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cpus'</span>, CPUS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'master listening...'</span>);</span><br><span class="line"></span><br><span class="line">    cluster.on(<span class="string">'listening'</span>, (worker, address) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(worker.process.pid, address.address+<span class="string">''</span>+address.port);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(worker.process.pid + <span class="string">'died'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; CPUS; i++) &#123;</span><br><span class="line">        cluster.fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">200</span>);</span><br><span class="line">        res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">    &#125;).listen(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：对于上面的打印cpus的数量这一行，会打印几遍呢？答案是打印CPUS+1遍，不仅每个创建出来的worker运行了这份脚本，而且主worker也运行了这份脚本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>node事件循环</title>
    <link href="http://yoursite.com/2018/12/12/node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2018/12/12/node事件循环/</id>
    <published>2018-12-12T09:11:18.000Z</published>
    <updated>2018-12-12T09:11:18.568Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数式一</title>
    <link href="http://yoursite.com/2018/12/11/%E5%87%BD%E6%95%B0%E5%BC%8F%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/11/函数式一/</id>
    <published>2018-12-11T07:58:40.000Z</published>
    <updated>2018-12-13T13:52:17.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子："><a href="#1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：" class="headerlink" title="1.纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子："></a>1.纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Flock = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flock.prototype.conjoin = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag += other.seag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flock.prototype.breed = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag *= other.seag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Flock(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Flock(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Flock(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.breed(b) =&gt; 16;  16 + 16;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = a.conjoin(c).breed(b).conjoin(a.breed(b)).seag;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);    <span class="comment">// =&gt; 32</span></span><br></pre></td></tr></table></figure><p>上面这个例子输出的结果是32。</p><h3 id="2-区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array-prototype-slice就是一个纯方法，而Array-prototype-splice并不是一个纯方法。"><a href="#2-区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array-prototype-slice就是一个纯方法，而Array-prototype-splice并不是一个纯方法。" class="headerlink" title="2.区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array.prototype.slice就是一个纯方法，而Array.prototype.splice并不是一个纯方法。"></a>2.区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array.prototype.slice就是一个纯方法，而Array.prototype.splice并不是一个纯方法。</h3><h3 id="3-一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态："><a href="#3-一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态：" class="headerlink" title="3.一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态："></a>3.一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mini = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data &gt;= mini;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pure的应该像下面这样的写法</span></span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mini = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> data &gt;= mini;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-可以使用Object-freeze来创建一个不可变对象："><a href="#4-可以使用Object-freeze来创建一个不可变对象：" class="headerlink" title="4.可以使用Object.freeze来创建一个不可变对象："></a>4.可以使用Object.freeze来创建一个不可变对象：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = <span class="built_in">Object</span>.freeze(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);  <span class="comment">// 还是为1</span></span><br></pre></td></tr></table></figure><h3 id="5-纯函数的优点一：可缓存性："><a href="#5-纯函数的优点一：可缓存性：" class="headerlink" title="5.纯函数的优点一：可缓存性："></a>5.纯函数的优点一：可缓存性：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** memoize函数能够将计算过的值给缓存起来，节约计算时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">    cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[arg_str];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x &#125;);</span><br><span class="line">square(<span class="number">5</span>);</span><br><span class="line">square(<span class="number">5</span>); <span class="comment">// 从缓存里面取值</span></span><br></pre></td></tr></table></figure><h3 id="6-组合，下面可以看一个函数组合的例子："><a href="#6-组合，下面可以看一个函数组合的例子：" class="headerlink" title="6.组合，下面可以看一个函数组合的例子："></a>6.组合，下面可以看一个函数组合的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x=<span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.toUpperCase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">x=<span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> power = compose(toUpperCase, reverseString);  <span class="comment">// 很直观 从右到左</span></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="string">'hello frp'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：&quot;&gt;&lt;a href=&quot;#1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：&quot; class=&quot;headerlink&quot; title=&quot;1.纯函数：同一个输入，同一个输出，不改变数
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>rn基础一</title>
    <link href="http://yoursite.com/2018/12/11/rn%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/11/rn基础一/</id>
    <published>2018-12-11T05:51:46.000Z</published>
    <updated>2018-12-11T05:57:59.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-设置全屏"><a href="#1-设置全屏" class="headerlink" title="1.设置全屏"></a>1.设置全屏</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; View, Dimensions &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;&#123;<span class="attr">width</span>: Dimensions.get(<span class="string">'window'</span>).width, <span class="attr">height</span>: Dimensions.get(<span class="string">'window'</span>).height&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-设置全屏&quot;&gt;&lt;a href=&quot;#1-设置全屏&quot; class=&quot;headerlink&quot; title=&quot;1.设置全屏&quot;&gt;&lt;/a&gt;1.设置全屏&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>react生态基本使用笔记</title>
    <link href="http://yoursite.com/2018/12/07/react%E7%94%9F%E6%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/07/react生态基本使用笔记/</id>
    <published>2018-12-07T03:18:59.000Z</published>
    <updated>2018-12-23T05:24:36.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用react-router的link标签的时候可以这样使用："><a href="#1-使用react-router的link标签的时候可以这样使用：" class="headerlink" title="1.使用react-router的link标签的时候可以这样使用："></a>1.使用react-router的link标签的时候可以这样使用：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">`routeUrl`</span>, <span class="attr">state</span>: stateObj &#125;&#125;&gt;target&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure><p>Link里面所传递的state对象在子页面中可以通过this.props.location.state来进行获取。一个好处，放在location里面的数据不会被刷新掉。</p><h3 id="2-更新过程不会触发componentWillMount以及componentDidMount。"><a href="#2-更新过程不会触发componentWillMount以及componentDidMount。" class="headerlink" title="2.更新过程不会触发componentWillMount以及componentDidMount。"></a>2.更新过程不会触发componentWillMount以及componentDidMount。</h3><h3 id="3-一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this-props-params-classId来获取班级id。"><a href="#3-一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this-props-params-classId来获取班级id。" class="headerlink" title="3.一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this.props.params.classId来获取班级id。"></a>3.一个route形如下面这样的话：<route path="course/:courseId/class/:classId" component="{CourseClassInfo}/">，那么我们可以在CourseClassInfo组件中通过this.props.params.classId来获取班级id。</route></h3><p><strong>4.React挂载阶段所触发的生命周期方法：</strong></p><ul><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p><em>需要注意的地方，React 16.3版本发布以后，引入了下面几个生命周期方法：UNSAFE_componentWillMount,UNSAFE_componentWillReceiveProps,UNSAFE_componentWillUpdate，这几个方法是用来替代componentWillMount和componentWillReceiveProps以及componentWillUpdate的，为什么要进项替代？因为这几个方法在接下来react主要希望实现的目标-异步渲染中将会带来比之前更大的误解。</em> 虽然在react 16.3版本中引入了这几个方法，但是旧的原有方法和新的替代方法是处于一个可以共存的状态下。</p><p>来到react 17以上的版本之后，react将componentWillMount，componentWillReceiveProps，componentWillUpdate这些旧方法都给移除了。只有这些方法相对应的带有UNSAFE_前缀的才可使用。</p><p><strong>5.更新阶段执行的生命周期方法：首先更新一个组件有三种途径，分别是父组件更新，自身状态变化，自身强制更新</strong>。不同的途径所触发的生命周期方法是不同的，<em>先介绍父组件更新所触发的生命周期方法：</em></p><ul><li>1.componentWillReceiveProps()</li><li>2.shouldComponentUpdate()</li><li>3.componentWillUpdate()</li><li>4.render()</li><li>5.componentDidUpdate()</li></ul><p><em>当自身状态发生变化的时候，也就是自己调用setState，此时触发的生命周期方法如下所示：</em></p><ul><li>1.shouldComponentUpdate()</li><li>2.componentWillUpdate()</li><li>3.render()</li><li>4.componentDidUpdate()</li></ul><p><em>当调用forceUpdate()强制触发更新的时候，将会触发下面这些生命周期方法：</em></p><ul><li>1.componentWillUpdate()</li><li>2.render()</li><li>3.componentDidUpdate()</li></ul><p><strong>6.卸载阶段：这个阶段调用的就是componentWillUnmount，可以在这个方法里面执行一些垃圾回收操作。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用react-router的link标签的时候可以这样使用：&quot;&gt;&lt;a href=&quot;#1-使用react-router的link标签的时候可以这样使用：&quot; class=&quot;headerlink&quot; title=&quot;1.使用react-router的link标签的时候
      
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>《nodejs 8 the right way》-阅读笔记1</title>
    <link href="http://yoursite.com/2018/12/07/nodejs%20the%20right%20way%20%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/07/nodejs the right way 一/</id>
    <published>2018-12-06T16:49:00.000Z</published>
    <updated>2018-12-13T09:22:09.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用const定义变量，在定义的时候必须赋值。"><a href="#1-使用const定义变量，在定义的时候必须赋值。" class="headerlink" title="1.使用const定义变量，在定义的时候必须赋值。"></a>1.使用const定义变量，在定义的时候必须赋值。</h3><h3 id="2-fs-watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。"><a href="#2-fs-watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。" class="headerlink" title="2.fs.watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。"></a>2.fs.watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。</h3><h3 id="3-事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait-for，或者程序退出（比如一个未被捕获的异常所引起的退出）。"><a href="#3-事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait-for，或者程序退出（比如一个未被捕获的异常所引起的退出）。" class="headerlink" title="3.事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait for，或者程序退出（比如一个未被捕获的异常所引起的退出）。"></a>3.事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait for，或者程序退出（比如一个未被捕获的异常所引起的退出）。</h3><h3 id="4-process-argv命令行参数列表，第一个是nodefull-path路径，第2个是所执行文件的full-path路径，第三个开始就是自定义参数。"><a href="#4-process-argv命令行参数列表，第一个是nodefull-path路径，第2个是所执行文件的full-path路径，第三个开始就是自定义参数。" class="headerlink" title="4.process.argv命令行参数列表，第一个是nodefull path路径，第2个是所执行文件的full path路径，第三个开始就是自定义参数。"></a>4.process.argv命令行参数列表，第一个是nodefull path路径，第2个是所执行文件的full path路径，第三个开始就是自定义参数。</h3><h3 id="5-child-process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject-pipe-process-stdout"><a href="#5-child-process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject-pipe-process-stdout" class="headerlink" title="5.child_process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject.pipe(process.stdout);"></a>5.child_process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject.pipe(process.stdout);</h3><h3 id="6-fs-writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。"><a href="#6-fs-writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。" class="headerlink" title="6.fs.writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。"></a>6.fs.writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。</h3><h3 id="7-事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err-cb。一个未被捕获的异常会导致线程被中断。"><a href="#7-事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err-cb。一个未被捕获的异常会导致线程被中断。" class="headerlink" title="7.事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err cb。一个未被捕获的异常会导致线程被中断。"></a>7.事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err cb。一个未被捕获的异常会导致线程被中断。</h3><h3 id="8-node在很多build-in-模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。"><a href="#8-node在很多build-in-模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。" class="headerlink" title="8.node在很多build-in 模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。"></a>8.node在很多build-in 模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。</h3><h3 id="9-fs-watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs-watch监听的文件被删除是ok的，"><a href="#9-fs-watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs-watch监听的文件被删除是ok的，" class="headerlink" title="9.fs.watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs.watch监听的文件被删除是ok的，"></a>9.fs.watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs.watch监听的文件被删除是ok的，</h3><h3 id="10-net-createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection-write-方法写数据，可以监听connection-on-‘close’-来监听客户端断开连接。"><a href="#10-net-createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection-write-方法写数据，可以监听connection-on-‘close’-来监听客户端断开连接。" class="headerlink" title="10.net.createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection.write()方法写数据，可以监听connection.on(‘close’)来监听客户端断开连接。"></a>10.net.createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection.write()方法写数据，可以监听connection.on(‘close’)来监听客户端断开连接。</h3><h3 id="11-当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。"><a href="#11-当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。" class="headerlink" title="11.当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。"></a>11.当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。</h3><h3 id="12-npm-i-–production-表示只安装dependencies而不安装devDependencies。"><a href="#12-npm-i-–production-表示只安装dependencies而不安装devDependencies。" class="headerlink" title="12.npm i –production 表示只安装dependencies而不安装devDependencies。"></a>12.npm i –production 表示只安装dependencies而不安装devDependencies。</h3><h3 id="13-Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理："><a href="#13-Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理：" class="headerlink" title="13.Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理："></a>13.Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should finish with 5 seconds'</span>, done =&gt; &#123;</span><br><span class="line">  setTimeout(done, <span class="number">4500</span>);</span><br><span class="line">&#125;).timeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>除了在it后面调用timeout方法之外，其实在describe后面也可以设置一个timeout方法。</p><h3 id="14-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"><a href="#14-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。" class="headerlink" title="14.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"></a>14.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。</h3><h3 id="15-child-process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。"><a href="#15-child-process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。" class="headerlink" title="15.child_process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。"></a>15.child_process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。</h3><h3 id="16-直观看来，nodejs中process-nextTick中的cb会比setTimeout-cb-0-更快执行。"><a href="#16-直观看来，nodejs中process-nextTick中的cb会比setTimeout-cb-0-更快执行。" class="headerlink" title="16.直观看来，nodejs中process.nextTick中的cb会比setTimeout(cb, 0)更快执行。"></a>16.直观看来，nodejs中process.nextTick中的cb会比setTimeout(cb, 0)更快执行。</h3><h3 id="17-curl-O-资源链接-可以下载指定链接的资源。"><a href="#17-curl-O-资源链接-可以下载指定链接的资源。" class="headerlink" title="17.curl -O 资源链接 可以下载指定链接的资源。"></a>17.curl -O 资源链接 可以下载指定链接的资源。</h3><h3 id="18-Mocha携带flag-–-watch表明持续监听测试用例文件，如下所示："><a href="#18-Mocha携带flag-–-watch表明持续监听测试用例文件，如下所示：" class="headerlink" title="18.Mocha携带flag – watch表明持续监听测试用例文件，如下所示："></a>18.Mocha携带flag – watch表明持续监听测试用例文件，如下所示：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test:watch"</span>: <span class="string">"mocha --watch --reporter min"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-chmod-x-file；将文件权限修改为可执行。"><a href="#19-chmod-x-file；将文件权限修改为可执行。" class="headerlink" title="19.chmod +x file；将文件权限修改为可执行。"></a>19.chmod +x file；将文件权限修改为可执行。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用const定义变量，在定义的时候必须赋值。&quot;&gt;&lt;a href=&quot;#1-使用const定义变量，在定义的时候必须赋值。&quot; class=&quot;headerlink&quot; title=&quot;1.使用const定义变量，在定义的时候必须赋值。&quot;&gt;&lt;/a&gt;1.使用const定义
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue学习</title>
    <link href="http://yoursite.com/2018/12/01/vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/12/01/vue学习/</id>
    <published>2018-12-01T08:19:30.000Z</published>
    <updated>2018-12-01T08:21:54.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-vue-router-this-router-replace-url-进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。"><a href="#1-vue-router-this-router-replace-url-进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。" class="headerlink" title="1.vue-router: this.$router.replace(url)进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。"></a>1.vue-router: this.$router.replace(url)进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-vue-router-this-router-replace-url-进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。&quot;&gt;&lt;a href=&quot;#1-vue-router-this-router-replace-url-进行跳转，并不
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用nestjs开发一个博客应用之程序配置</title>
    <link href="http://yoursite.com/2018/11/30/%E7%94%A8nestjs%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8%E4%B9%8B%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/30/用nestjs开发一个博客应用之程序配置/</id>
    <published>2018-11-29T16:52:52.000Z</published>
    <updated>2018-11-30T15:43:03.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi-package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示："><a href="#1-应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi-package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示：" class="headerlink" title="1.应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示："></a>1.应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示：</h3><h3 id="2-1-先安装相关依赖包："><a href="#2-1-先安装相关依赖包：" class="headerlink" title="2-1:先安装相关依赖包："></a>2-1:先安装相关依赖包：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i --save dotenv; <span class="comment">## 键值对处理相关包，我们的配置文件是以键值对的形式出现的</span></span><br><span class="line">npm i --save joi; <span class="comment">## 字段建模验证</span></span><br><span class="line">npm i --save-dev @types/joi;</span><br></pre></td></tr></table></figure><h3 id="2-2-假设有配置问价如下所示："><a href="#2-2-假设有配置问价如下所示：" class="headerlink" title="2-2:假设有配置问价如下所示："></a>2-2:假设有配置问价如下所示：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_NAME = BLOG</span><br><span class="line">DATABASE_USER = YOU_NAME</span><br><span class="line">DATABASE_PASSWORD = YOU_PASSWORD</span><br></pre></td></tr></table></figure><h3 id="2-3-创建这个module的service文件："><a href="#2-3-创建这个module的service文件：" class="headerlink" title="2-3:创建这个module的service文件："></a>2-3:创建这个module的service文件：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.service.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> joi <span class="keyword">from</span> <span class="string">'joi'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个具有任意属性的对象类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> EnvConfig &#123;</span><br><span class="line">  [Key: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ConfigService &#123;</span><br><span class="line">  <span class="keyword">private</span> readonly envConfig: EnvConfig;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">filePath: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> config = dotenv.parse(fs.readFileSync(filePath));           <span class="comment">// 读取配置文件，并利用dotenv进行解析</span></span><br><span class="line">    <span class="keyword">this</span>.envConfig = <span class="keyword">this</span>.validateInput(config);                      <span class="comment">// 验证配置</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> validateInput(envConfig: EnvConfig): EnvConfig &#123;</span><br><span class="line">    <span class="keyword">const</span> envSchema: joi.ObjectSchema = joi.object(&#123;</span><br><span class="line">      DATABASE_NAME: joi.string()</span><br><span class="line">                        .valid([<span class="string">'blog'</span>, <span class="string">'ablog'</span>])</span><br><span class="line">                        .default(<span class="string">'blog'</span>),</span><br><span class="line">      DATABASE_USER: joi.string()</span><br><span class="line">                        .valid([<span class="string">'root'</span>, <span class="string">'visitor'</span>])</span><br><span class="line">                        .default(<span class="string">'root'</span>),</span><br><span class="line">      DATABASE_PASSWORD: joi.number().required()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> &#123; error, value: validateConfig &#125; = joi.validate(envConfig, envSchema);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> validateConfig</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个配置属性都必须设置一个getter方法来获取值</span></span><br><span class="line">  <span class="keyword">get</span> databaseName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.envConfig.DATABASE_NAME;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> databaseUser(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.envConfig.DATABASE_USER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> databasePassword(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.envConfig.DATABASE_PASSWORD;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-创建配置的module文件："><a href="#2-4-创建配置的module文件：" class="headerlink" title="2-4:创建配置的module文件："></a>2-4:创建配置的module文件：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigService &#125; <span class="keyword">from</span> <span class="string">'./config.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  providers: [</span><br><span class="line">    provide: ConfigService,</span><br><span class="line">    useValue: <span class="keyword">new</span> ConfigService(<span class="string">`<span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">  ],</span><br><span class="line">  exports: [ConfigService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ConfigModule &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块："><a href="#2-5-到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块：" class="headerlink" title="2-5:到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块："></a>2-5:到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule &#125; <span class="keyword">from</span> <span class="string">'./config.module'</span>;</span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [ConfigModule]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前模块中引入了config模块之后，便能够进行使用了，如下所示：</span></span><br><span class="line"><span class="comment">// app.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppService &#123;</span><br><span class="line">  <span class="keyword">private</span> dataBaseName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">config: ConfigService</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataBaseName = config.databaseName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi-package一起使用，因为有的时候我们并不希望某个配置项为空或者
      
    
    </summary>
    
    
      <category term="nestjs" scheme="http://yoursite.com/tags/nestjs/"/>
    
  </entry>
  
</feed>
