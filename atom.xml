<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜游</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-10T13:50:29.952Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hahahai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter之文本</title>
    <link href="http://yoursite.com/2019/01/09/Flutter%E4%B9%8B%E6%96%87%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/01/09/Flutter之文本/</id>
    <published>2019-01-09T15:17:00.000Z</published>
    <updated>2019-01-10T13:50:29.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>用于显示简单样式文本。用法如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'hello world'</span>, textAlign: TextAlign.center);</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'hello world'</span>*<span class="number">4</span>, maxLines: <span class="number">1</span>, overflow: TextOverflow.ellipsis);</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'hello world'</span>, textScaleFactor: <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><h3 id="2-Text方法的几个参数代表的意思"><a href="#2-Text方法的几个参数代表的意思" class="headerlink" title="2.Text方法的几个参数代表的意思"></a>2.Text方法的几个参数代表的意思</h3><ul><li><p>1.textAlign: 文本的对齐方式，可以选择左对齐，右对齐还是居中；这几个值都是从TextAlign里面获取。<strong>需要注意，对齐的参考系是Text Widget本身，这意味着如果Text的宽度和文本内容长度相等的话，那么此时指定对齐方式是没有意义的。</strong></p></li><li><p>2.maxLines, overflow: 指定文本显示的最大行数，默认情况下，文本是自动折行的。但是如果指定了maxLine的话，那么最多显示maxLines行，超出了maxLines行的行为由overflow的值来决定，默认是直接截断；如果想要显示省略号的话，那么使用TextOverflow.ellipsis值。</p></li><li><p>3.textScaleFactor: 代表文本相对于当前字体大小(style属性里面的fontSize)的缩放因子。</p></li><li><p>4.style: 他的值是一个TextStyle类所实例化出来的对象，举个例子如下所示：</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">'hello world'</span>,</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">      color: Colors.black,    <span class="comment">// 字体颜色</span></span><br><span class="line">      background: <span class="keyword">new</span> Paint()..color = Colors.white,    <span class="comment">// 字体底层的颜色（背景颜色）</span></span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      fontFamily: <span class="string">'Courier'</span>,</span><br><span class="line">      decoration: TextDecoration.underline,</span><br><span class="line">      height: <span class="number">1.3</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>需要注意的地方，TextStyle类的实例化参数height是一个因子，具体行高等于fontSize乘height。</strong></p><h3 id="3-TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。"><a href="#3-TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。" class="headerlink" title="3.TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。"></a>3.TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。</h3><p>如果想要对Text的不同部分应用不同的效果的话，那么使用TextSpan会更加方便。可以先看看TextSpan的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用了命名可选参数的写法，采用这种写法的话，除非带上@required的话否则都是可选</span></span><br><span class="line"><span class="keyword">const</span> TextSpan(&#123;</span><br><span class="line">    TextStyle style,</span><br><span class="line">    <span class="built_in">String</span> text,</span><br><span class="line">    <span class="built_in">List</span>&lt;TextSpan&gt; children,</span><br><span class="line">    GestureRecognizer recognizer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>各个参数的解释：</p><ul><li>1.children，一个TextSpan数组，说明TextSpan里面可以包含其它TextSpan</li><li>2.recognizer，在文本片段上进行手势处理</li></ul><p>举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Text.rich(TextSpan(</span><br><span class="line">    children: [</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">'主页：'</span></span><br><span class="line">      ),</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">'hotfireeagle.github.io'</span>,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">              color: Colors.blue</span><br><span class="line">          ),</span><br><span class="line">          recognizer: gotoLink, <span class="comment">// 手势处理方法</span></span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">))</span><br></pre></td></tr></table></figure><h3 id="4-DefaultTextStyle"><a href="#4-DefaultTextStyle" class="headerlink" title="4.DefaultTextStyle"></a>4.DefaultTextStyle</h3><p>在Widget树中，文本的样式默认是可以继承的。因此，如果在Widget树中的某个节点处设置一个默认的文本样式的话，那么该节点下的子树中的所有文本都会默认使用这个样式。不同于web编程，设置默认文本样式可以在任意一个父元素里面，但是在flutter里面如果想要设置默认文本样式的话，那么应该使用DefaultTextStyle这个widget才行。如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DefaultTextStyle(</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        fontSize: <span class="number">18.0</span></span><br><span class="line">    ),</span><br><span class="line">    textAlign: TextAlign.center,</span><br><span class="line">    <span class="comment">// 注意在这里是child</span></span><br><span class="line">    child: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        <span class="comment">// 注意在这里是children</span></span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">'hello world'</span>),</span><br><span class="line">          Text(<span class="string">'hello flutter'</span>),</span><br><span class="line">          Text(<span class="string">'cool'</span>, style: TextStyle(color: Colors.green))</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h3&gt;&lt;p&gt;用于显示简单样式文本。用法如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>express学习</title>
    <link href="http://yoursite.com/2019/01/07/express%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/07/express学习/</id>
    <published>2019-01-07T09:17:44.000Z</published>
    <updated>2019-01-09T15:22:15.814Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.helmet中间件介绍</strong></p><p>helmet中间件是用来增强express应用的安全性的，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.helmet中间件介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;helmet中间件是用来增强express应用的安全性的，&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>dart基础3</title>
    <link href="http://yoursite.com/2019/01/07/dart%E5%9F%BA%E7%A1%803/"/>
    <id>http://yoursite.com/2019/01/07/dart基础3/</id>
    <published>2019-01-07T03:03:34.000Z</published>
    <updated>2019-01-07T03:54:59.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.异步支持，在dart中有很多返回Future和Stream对象的函数，这些函数在设置完耗时任务之后就立即返回了，不会等待耗时任务完成。使用async和await关键字可以让我们像编写同步代码一样实现异步操作。</strong></p><p><strong>2.如何获得Future的返回结果，具有两种方式，分别是使用async和await；使用Future API。可以使用try…catch…来捕获代码中使用await所导致的错误。首先看看第一种方式：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.声明异步函数，使用async声明函数并且返回值是Future。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">'1.0.0'</span>; <span class="comment">// 需要注意async修饰符的位置</span></span><br></pre></td></tr></table></figure><p><strong>4.同样，对于Stream对象来说，他也是一种异步操作，如果想获取他的返回值的话，那么也有两种方式：分别是使用await（await for)和Stream API。</strong></p><p><strong>5.可调用类，通过给类实现一个call方法，能够让类所实例化出来的对象被调用。如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">callable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> a;</span><br><span class="line"></span><br><span class="line">  callable(<span class="keyword">this</span>.a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> consoleA() &#123; <span class="built_in">print</span>(<span class="string">'a is <span class="subst">$a<span class="string">'); &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  call(String a, String b, String c) =&gt; '</span></span><span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">void main() &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  let cb = callable(3);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  cb.consoleA(); // a is 3</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  let ret = cb('</span><span class="number">7</span><span class="string">', '</span><span class="number">8</span><span class="string">', '</span><span class="number">9</span><span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>ret is <span class="subst">$ret<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p><strong>6.typedef类型定义，考虑下面这个场景:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortCollection sc = SortCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(sc.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个例子，当把f赋值给compare的时候，f的类型信息(Object, Object) -&gt; int（rust写法)被丢弃了，此时compare的类型信息为Function。为了避免这种类型丢失的情况，可以像下面这样做：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortCollection coll = SortCollection(sort);</span><br><span class="line">  <span class="comment">// 这样做的话coll.compare类型信息便没有丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typedef和泛型结合在一起：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare&lt;<span class="built_in">int</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.异步支持，在dart中有很多返回Future和Stream对象的函数，这些函数在设置完耗时任务之后就立即返回了，不会等待耗时任务完成。使用async和await关键字可以让我们像编写同步代码一样实现异步操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>dart基础2</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2019/01/05/dart基础2/</id>
    <published>2019-01-05T09:23:32.000Z</published>
    <updated>2019-01-07T02:59:50.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.类</strong></p><p>Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。</p><p>在Dart2中，new关键字是可选的。</p><p>在dart中，存在像下面这样实例化对象的方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.常量构造函数</strong></p><p>在构造函数名之前加const关键字，来创建编译时常量，构造两个相同的编译时常量会产生一个唯一的，标准的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(identical(a, b));</span><br></pre></td></tr></table></figure><p><strong>3.一个不太明白的特性：在dart2中，一个常量上下文中的const关键字可以被省略。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个不省略的版本</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'point'</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 接下来是一个省略的版本，仅有一个const，由该const建立上下文</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">'point'</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.获取对象的类型</strong></p><p>使用对象的runtimeType属性可以在运行的时候获取对象的类型。他返回的是一个Type对象。</p><p><strong>5.实例变量：就是不是类对象所拥有的，而是类所实例化出来的对象所拥有的</strong></p><p>所有未初始化变量的默认值都是null，所有实例变量都会生成一个隐式的getter方法，非final的实例变量同样会生成一个隐式的setter方法。也就是说对一个实例变量进行赋值的时候，实际都是通过调用setter方法来赋值的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> y;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;  <span class="comment">// 初始值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.构造函数，通过创建一个和类同名的函数来声明构造函数，可以使用this关键字来获取当前实例。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很常见的生成构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还有更好的方式实现下面代码，在dart里面最佳实践应该减少使用this</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是精简模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// 一颗语法题</span></span><br><span class="line">  Point (<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有声明构造函数的情况下，Dart会提供一个默认的构造函数，默认构造函数没有参数并会调用父类的无参构造函数。子类不会继承父类的构造函数，子类不声明构造函数，那么它就只有默认构造函数。</p><p><strong>7.命名构造函数，使用命名构造函数可以为一个类实现多个构造函数，可以使用命名构造函数来更清晰的表明函数意图：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.什么鬼super，如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Person'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Employee'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;); <span class="comment">// 输出 =&gt; in Person in Employee</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.初始化列表概念，很难看</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">    : x = x,</span><br><span class="line">      y = y,</span><br><span class="line">      distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种初始化列表的写法起的作用对应了js里面的参数默认值，在写法上后者简直不要太简单优雅；在dart中，我们可以在构造函数后面加上一个:后面跟上一些初始化列表语句，同时也能够对其进行开发期assert判断处理。</p><p><strong>10.重定向构造函数，在某些情况下，某些命名构造函数只需要使用其它构造函数的逻辑即可，那么此时使用重定向构造函数便很合适：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  Point.which(<span class="built_in">num</span> x): <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.常量构造函数，常量构造函数所创建出来的实例并不是常量（？？），如果希望实例出来的变量是固定不变的话，那么首先构造函数得是const的，并且所有实例变量也都得是final。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.工厂构造函数，第一次接触到。如果类中的某个构造函数并不总是返回这个类的实例（而是有可能返回其它类的实例）的话，那么这个构造函数也被叫做工厂构造函数，使用factory关键字来定义，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.Getters和Setters，每一个实例变量都会有一个隐式的getter，通常也会有一个setter。同时我们也可以使用get和set关键字来显式设置getters和setters。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示声明带有getter和setter的实例属性</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>l</span><br><span class="line">  <span class="keyword">assert</span>(rect.left = <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>14.抽象方法，抽象方法只能够存在于抽象类中。实例方法，getter，setter方法可以是抽象的，他们只定义接口而不实现，实现交给子类去完成。调用抽象方法会带来运行时错误：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuff</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> soStuff() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>15.抽象类：使用abstract修饰符来定义一个抽象类，抽象类不能用来实例化，如果希望抽象类能够被实例化，那么可以通过定义工厂实例函数来实现。在dart中声明抽象方法无需加上abstract修饰符，没有大花括号并且加上返回值就是了。抽象方法只能在抽象类中定义。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> updateChildren();  <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16.接口：每个类都隐式的定义了一个接口，接口包含了该类所有的实例变量以及实例方法，但是，注意并不包含构造函数。如果想要创建一个A类，并且A类要支持B类的API的话，但是又不想继承B类的实现的话，那么可以通过让A类来实现B类的接口。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>, I am <span class="subst">$_name<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">class Impostor implements Person &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  get _name =&gt; '</span><span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  String greet(String who) =&gt; '</span></span>Hi, <span class="subst">$who</span>, Do You Know Who I Am'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">'kay'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时一个类也能够用来实现多个接口，如下所示：</p><p>class Point implements PointA, PointB {…}</p><p><strong>17.枚举类型是一种特殊的类，使用enum关键字来定义一个枚举类。枚举中的每一个值都具有一个index getter方法，该方法这个值在枚举类型中的位置；每个枚举类型，都具有一个values实例常量，用来获取所有枚举值列表。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p><strong>18.使用mixins，使用类的时候with一个mixin，怎么实现一个mixin？使用mixin关键字进行定义，写法和类写法一样，除了使用mixin代替了class外。</strong></p><p><strong>19.静态变量和静态方法，使用static即可，注意，静态变量只有在被使用的时候才会初始化；静态方法因为不可以在实例上访问，所以无法访问this。</strong></p><p><strong>20.泛型，挺好的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p><strong>21.参数化字面量，作用是不用去猜？</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">'haha'</span>, <span class="string">'hai'</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">'index.html'</span>: <span class="string">'Homepage'</span>,</span><br><span class="line">  <span class="string">'robots.txt'</span>: <span class="string">'all spider'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>22.在运行时能够测试到泛型类型，泛型类型是固化的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'n1'</span>, <span class="string">'n2'</span>, <span class="string">'n3'</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>23.限制泛型类型</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> toString() =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>24.泛型方法，这才像样</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>25.库和可见性，import和library指令用来创建模块化的，可共享的代码库。以下划线_开头的标识符仅在库中可见，每个dart程序都是一个库，尽管没有使用library指令。</strong></p><p>利用import命令来使用一个库，import后面加上一个URI；对于内置的库来说，URI拥有自己内置的dart:方案；对于其他的库，使用系统文件路径或者package:方案；其中后者使用package:方案是指定由包管理器（pub工具）所提供的库。如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure><p><strong>26.指定库前缀来解决两个库里面定义了同一个类；假设下面两个类中都有Element的声明的话，那么如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Element</span> ele1 = <span class="built_in">Element</span>();</span><br><span class="line">lib2.<span class="built_in">Element</span> ele2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure><p><strong>27.导入库的一部分，还是挺方便的，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo; <span class="comment">// 只导入这个库的foo部分</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo; <span class="comment">// 导入这个库除了foo外的其它部分</span></span><br></pre></td></tr></table></figure><p><strong>28.延迟加载库，在某些地方还是能够派上用场的，使用延迟加载库的功能能够优化App启动时间；延迟加载库使用上了dart的异步功能，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary(); <span class="comment">// 调用loadLibrary函数来加载库</span></span><br><span class="line">  hello.printGreet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>dart基础1</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%801/"/>
    <id>http://yoursite.com/2019/01/05/dart基础1/</id>
    <published>2019-01-05T02:02:32.000Z</published>
    <updated>2019-01-05T07:42:10.258Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.使用var会自动进行类型推断，如果不想要类型推断的话，那么使用dynamic。</strong></p><p><strong>2.dart没有关键字public,protected,private，如果标识符以_开头，则说明它相对于库是私有的。</strong></p><p><strong>3.任何和变量进行捆绑的都是对象，无论它是不是基本类型。例如String,Number也是继承自Object类，是祖先类。</strong></p><p><strong>4.变量只是存储对象引用，声明定义变量可以有如下方式：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'bob'</span>; <span class="comment">// 会自动进行类型推断为String类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span> name1 = <span class="string">'i can change'</span>; <span class="comment">// 动态类型，为什么是动态？因为Object是所有对象的祖先类ya</span></span><br><span class="line"><span class="keyword">dynamic</span> name2 = <span class="string">'also change'</span>;  <span class="comment">// 也是动态类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> name3 = <span class="string">'me'</span>; <span class="comment">// 显式说明类型</span></span><br></pre></td></tr></table></figure><p><strong>5.在使用过程中不会发生变化的变量可以使用final或者const来声明，final变量的值只能被设置一次；const在编译时则已经固定。如果const变量是类级别的，需要标记为static const。</strong></p><p><strong>6.天秀const，像是回到了c指针又像是rust的mut，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span>;  <span class="comment">// 定义一个常量变量a，前面也提到了变量里面存储的是对象引用，所以这个变量a不能再被赋值了，只能指向'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">const</span> []; <span class="comment">// ???? 秀，这个时候的const是说明右值是不会发生变化的，因此使用aa变量的时候是不能修改到其引用的对象的</span></span><br><span class="line"></span><br><span class="line">aa = <span class="string">'ok'</span>; <span class="comment">// 话还没说完，但是变量aa并不是不可变的，所以变量aa是可以再次赋值，可以更改为指向其它对象的引用</span></span><br></pre></td></tr></table></figure><p><strong>7.String可以通过${expression}的方式内嵌表达式，如果表达式是一个标识符，则{}可以省略。</strong></p><p><strong>8.List就相当于js里面的Array，可以看看下面这种使用方法，其知识点正是上面所提到的那个const的地方：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">const</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// arr[1] = 1;  这种操作是会报错的，因为已经明确声明了变量arr所指向的对象是不可变的</span></span><br></pre></td></tr></table></figure><p><strong>9.Map就像是JavaScript里面的object一样，在一个map对象中一个key只能出现一次，下面介绍一下Map的用法：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">  <span class="string">'first'</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用map字面量来初始化一个对象，会被自动类型推断为Map&lt;String, String&gt;，所以如果有不符合类型推断的key或者value加入进去的话</span></span><br><span class="line"><span class="comment">// 那么将会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">Map</span>();</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">'one'</span>;</span><br><span class="line">m[<span class="number">2</span>] = <span class="string">'two'</span>;</span><br></pre></td></tr></table></figure><p>使用.length方法来获取当前map中的key-value对数量。创建一个Map类型运行时常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">'two'</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">'three'</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">'four'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>10.函数：如果函数中只有一句表达式的话，那么可以使用简写语法：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> n) =&gt; n !==<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><strong>11.函数的可选参数，函数具有两种参数类型，分别是required类型和optional类型，required类型参数放在参数的最前面，随后optional类型参数。其中可选参数又分为了命名参数和位置参数，一个可选参数只能是其中某一种。</strong></p><p><strong>12.命名可选参数，使用这种方式调用函数的时候很奇怪，看着像是js里面的object参数，但是又不是，其实也就是规定了参数的名字，让调用者明白对所传参数的意思更加一目了然？，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125; <span class="comment">// 这是定义函数时候的模样</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>); <span class="comment">// 这是调用函数时的模样，很奇怪吧</span></span><br></pre></td></tr></table></figure><p><em>（注：在flutter中，窗口小部件的构造函数仅使用命名参数），更易于阅读？</em></p><p>使用@required注释表明一个命名参数是必选的，其中@required被定义在package:meta/meta.dart里面，同时其它一些包也将其引入并导出了，比如说package:flutter/material.dart。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun(&#123;<span class="built_in">String</span> param1, <span class="meta">@required</span> <span class="built_in">bool</span> param2&#125;) &#123;...&#125; <span class="comment">// 如果在调用函数的时候没有传params参数的话将会报错</span></span><br></pre></td></tr></table></figure><p><strong>13.位置可选参数，将参数放到[]里面，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> say <span class="subst">$msg<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (device != null) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    result = '</span></span><span class="subst">$result</span> with <span class="subst">$device<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return result;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">say('</span></span>hai'</span>, <span class="string">'hello'</span>);</span><br><span class="line">say(<span class="string">'who'</span>, <span class="string">'hello'</span>, <span class="string">'wrchat'</span>);</span><br></pre></td></tr></table></figure><p><strong>14.默认参数值：可以使用=来定义可选参数的默认值，并且默认值只能是编译时常量，如果没有提供默认值的话，那么默认值为null。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'one'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'two'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list: <span class="subst">$list<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>gifts: <span class="subst">$gifts<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p><strong>15.main方法，任意一个dart应用都需要main函数，参数为一个可选的List<string></string></strong></p><p><strong>16.词法闭包</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeFun(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> add2 = makeFun(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> add4 = makeFun(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>17.关于算术操作需要注意的地方：/是返回浮点数；~/返回整数。</strong></p><p><strong>18.赋值运算符的花样，dart提供了一个??= 赋值运算符，只有当被赋值变量为null的时候，才会执行赋值操作，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b ??= value; <span class="comment">// 如果b为空的话，将变量赋值给b；否则，b的值保持不变</span></span><br></pre></td></tr></table></figure><p><strong>19.dart给条件表达式所新引入的东西：?? ； 用法如下所示：expr1 ?? expr2，如果expr1是non-null的话，那么返回expr1的值，否则返回expr2的值。</strong></p><p><strong>20.级联运算符..，用于支撑起链式调用，但是这里和js里所出现的又有所区别，多加了一个点。</strong></p><p><strong>21.流程控制语句：assert，如果assert语句中的布尔条件为false的话，那么正常的程序执行流程会被打断。assert的参数是可以解析成布尔值的任何表达式，如果表达式为true的话，则断言成功，程序继续执行。注，assert语句只在开发环境中有效。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.使用var会自动进行类型推断，如果不想要类型推断的话，那么使用dynamic。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.dart没有关键字public,protected,private，如果标识符以_开头，则说明它相对于库是私有的。&lt;/st
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>express开发小结</title>
    <link href="http://yoursite.com/2019/01/02/express%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/02/express开发小结/</id>
    <published>2019-01-02T13:27:49.000Z</published>
    <updated>2019-01-03T14:03:14.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.mongoose.model.prototype.findOne是一个promise，应该await一下的，否则的话，执行之后所返回的结果总会是true。</strong></p><p><strong>2.一个问题，如果请求头里面没有带上Content-Type为application/json的话，那么在某些时候会出现一些不确定的情况。</strong></p><p><strong>3.对于下面这个操作会出错，最好try…catch一下</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  id = mongoose.Types.Object(id);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'非法id'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.mongoose.model.prototype.findOne是一个promise，应该await一下的，否则的话，执行之后所返回的结果总会是true。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.一个问题，如果请求头里面没有带上Content
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Express值请求体中间件解析</title>
    <link href="http://yoursite.com/2018/12/29/Express%E5%80%BC%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/29/Express值请求体中间件解析/</id>
    <published>2018-12-29T05:55:40.000Z</published>
    <updated>2018-12-29T06:36:24.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.express请求体中间件有很多，比如说常见的body-parser,multer,formidable,这些中间件都各有各的应用场景,比如说body-parser很适合用来对application/x-www-form-urlencoded，application/json格式的表单请求做处理。multer中间件很适合对multipart/form-data的body，也就是说很适合处理文件上传。Formidable中间件可用于处理表单和上传文件，功能大而且全，既可以用来处理表单也能够用来处理上传文件。</strong></p><p><strong>2.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.express请求体中间件有很多，比如说常见的body-parser,multer,formidable,这些中间件都各有各的应用场景,比如说body-parser很适合用来对application/x-www-form-urlencoded，appli
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>express测试</title>
    <link href="http://yoursite.com/2018/12/28/express%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/12/28/express测试/</id>
    <published>2018-12-28T05:25:45.000Z</published>
    <updated>2018-12-28T10:04:55.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.测试API</strong></p><p>一个API基本上是一系列的代码块逻辑组成的，而对于mocha和chai来说，一般只是用来测试某个函数，所以就测试场景来说不是特别适合。因此有了Supertest，Supertest就不一样了，对于API测试来说，它会向server发送一个请求，自然的，server会对我们的请求作出响应，一旦做出了响应，那么我们便可以对响应进行断言，以此来测试响应数据是否正确。</p><p><strong>2.关键库supertest</strong></p><p>示例代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"><span class="keyword">const</span> supertest = <span class="built_in">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'html test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    request = supertest(app)</span><br><span class="line">      .get(<span class="string">'/html'</span>)</span><br><span class="line">      .set(<span class="string">'User-Agent'</span>, <span class="string">'cool supertest'</span>)</span><br><span class="line">      .set(<span class="string">'Accept'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'return html response'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    request</span><br><span class="line">      .expect(<span class="string">'Content-Type'</span>, /text\/html/)</span><br><span class="line">      .expect(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> $ = cheerio.load(res.text);</span><br><span class="line">        <span class="keyword">let</span> domContent = $(query).text();                  <span class="comment">// 获取query处的content</span></span><br><span class="line">        <span class="keyword">if</span> (domContent !== <span class="string">'CONTENT_YOU_WANT'</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'content do not match'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .expect(<span class="number">200</span>)</span><br><span class="line">      .end(done);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.测试API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个API基本上是一系列的代码块逻辑组成的，而对于mocha和chai来说，一般只是用来测试某个函数，所以就测试场景来说不是特别适合。因此有了Supertest，Supertest就不一样了，对于API测试来说
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>flutter之widget基础</title>
    <link href="http://yoursite.com/2018/12/28/flutter%E4%B9%8Bwidget%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/28/flutter之widget基础/</id>
    <published>2018-12-27T16:36:20.000Z</published>
    <updated>2018-12-28T15:16:27.444Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.基础概念</strong></p><p>widget不仅只描述UI。widget是描述一个UI元素的配置数据；widget并不是绘制在屏幕的UI的抽象，那是Element，Widget只是描述Element的配置；一个Widget可以对应多个Element。</p><p>StatelessWidget适用于不需要维护状态的场景，通常在build方法中嵌套其它Widget来构建UI。</p><p>StatefulWidget继承自Widget类，并重写了createElement方法，而且还提供了一个新的接口createState。其中createState用于创建和Stateful widget相关的状态，如果一个stateful widget被插入到widget树的多个位置的话，那么flutter framework会调用该方法为每一个位置生成一个独立的state实例。</p><p><strong>2.State</strong></p><p>一个StatefulWidget类会对应一个State类，State表示的是其需要进行维护的状态。这些状态信息能够在widget build时被同步获取；State所维护的状态信息可以在widget的生命周期中被改变，当state发生变化后，可以手动调用setState来通知flutter状态发生了变化，flutter在收到通知后，会重新调用build方法构建widget树，从而达到更新UI的目的。</p><p>state有两个常用的属性，这里做个介绍：</p><ul><li><p>1.widget：表示和本State实例所关联的widget实例；由于State实例只会在widget第一次被插入到树中时被创建，所以State实例和widget的对应关系是动态化的，当重新构建的时候widget发生了变化的话，那么flutter会动态设置State实例的widget属性为新的widget实例；</p></li><li><p>2.context：BuildContext类的一个实例，表示构建widget的上下文。</p></li></ul><p><strong>3.Widget的生命周期</strong></p><ul><li>1.initState：当一个statewidget第一次被插入到widget树的时候会首先调用它，对于每一个state对象，flutter只会调用一次该回调，通常在这个回调中只会做一些一次性的动作。</li><li>2.didChangeDependencies</li><li>3.build</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.基础概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;widget不仅只描述UI。widget是描述一个UI元素的配置数据；widget并不是绘制在屏幕的UI的抽象，那是Element，Widget只是描述Element的配置；一个Widget可以对应多个Eleme
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter之包管理</title>
    <link href="http://yoursite.com/2018/12/27/flutter%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/27/flutter之包管理/</id>
    <published>2018-12-26T17:13:48.000Z</published>
    <updated>2018-12-26T17:28:50.206Z</updated>
    
    <content type="html"><![CDATA[<p><em>1.基本概念</em></p><p>包管理的配置文件采用yaml格式，默认配置文件叫做pubspec.yaml，位于项目根目录。</p><p><em>2.各个字段的基本意义</em></p><ul><li>1.name: 应用或者包名称</li><li>2.description: 应用或者包的简介</li><li>3.version: 应用或者包的版本号</li><li>4.dependencies: 应用或者包的依赖</li><li>5.dev_dependencies: 开发环境依赖</li><li>6.flutter: flutter相关配置选项</li></ul><p><em>3.包仓库</em></p><p>Flutter的包管理仓库就是dart语言的包管理仓库，叫做pub仓库，类似于npm仓库。添加一个依赖包只需要根性pubspec.yaml即可，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  packageName:</span> <span class="string">PACKAGE_VERSION</span>  <span class="comment">## 直接使用pub仓库的包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  package1:</span> <span class="string">./lib/package1</span>  <span class="comment">## 使用本地包</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  pkg2:</span></span><br><span class="line"><span class="attr">    git:</span></span><br><span class="line"><span class="attr">      url:</span> <span class="string">git_url</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">src/pkg2</span>    <span class="comment">## 如果不在仓库的根目录下的话，那么就加上相对路径，在的话则无需这步</span></span><br></pre></td></tr></table></figure><p><em>4.引入包</em></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:pkg2/pkg2.dart'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;1.基本概念&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;包管理的配置文件采用yaml格式，默认配置文件叫做pubspec.yaml，位于项目根目录。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.各个字段的基本意义&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.name: 应用或者包名称&lt;/li&gt;
&lt;li&gt;2
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter学习1</title>
    <link href="http://yoursite.com/2018/12/26/flutter%E5%AD%A6%E4%B9%A01/"/>
    <id>http://yoursite.com/2018/12/26/flutter学习1/</id>
    <published>2018-12-26T07:08:12.000Z</published>
    <updated>2018-12-26T17:05:39.316Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.JIT以及AOT</strong></p><p>JIT是just in time的缩写，表明即时编译，是指一边编译一边运行，Javascript和Python属于这一种类别；AOT则是需要经过提前编译，将其编译为机器码，典型代表是C/C++类语言。</p><p><strong>2.开发环境安装</strong></p><p>按照官网流程步骤进行安装，使用真机运行flutter的话如果想要体验热重载的话那么只需要在控制台下按下r键即可，终端下输入flutter run运行即可。</p><p><strong>3.dart简介</strong></p><p>1.<em>dart是强类型语言</em>，使用var关键字来定义变量，一旦变量被赋值，那么变量的类型就被确定了，后续不能进行修改。比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str; <span class="comment">// 说明没有什么默认赋值</span></span><br><span class="line">str = <span class="string">'hello world'</span>;</span><br><span class="line">str = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>2.<em>dynamic和Object</em>：功能和var相似，都能够在赋值时进行类型推断，不同在于，赋值后可以改变其类型。而Object在dart里面是所有对象的基类，也就是说其它类型都是Object的子类，所以任何数据类型的数据都可以赋值给Object声明的对象，在表现上和dynamic类似。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> t;</span><br><span class="line">t = <span class="string">'hello world'</span>;</span><br><span class="line">t = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>3.<em>final和const</em></p><p>如果你不打算修改一个变量的话，那么使用final和const，final和const的区别在于，const变量是一个编译时常量，final变量则在使用的时候才被初始化。使用final和const修饰变量，变量类型可以省略。</p><p><em>4.函数</em></p><p>dart函数如果没有显示申明返回类型的话，那么返回类型将会是dynamic，函数返回值不具有类型推断功能。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">bool</span> CALLBACK();</span><br><span class="line"></span><br><span class="line">isNoble(<span class="built_in">int</span> atom) &#123;</span><br><span class="line">  <span class="keyword">return</span> _noble[atom] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test(CALLBACK cb) &#123;</span><br><span class="line">  <span class="built_in">print</span>(cb());</span><br><span class="line">&#125;</span><br><span class="line">test(isNoble);</span><br></pre></td></tr></table></figure><p>箭头函数：单行函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble (<span class="built_in">int</span> atomic) =&gt; _noble[atomic] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>函数作为参数传递：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的var cb</span></span><br><span class="line"><span class="keyword">void</span> exec(<span class="keyword">var</span> cb) &#123;</span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line">exec(() =&gt; <span class="built_in">print</span>(<span class="string">'xxx'</span>));</span><br></pre></td></tr></table></figure><p>可选参数，利用[]进行标记</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (device != null) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    result = '</span></span><span class="subst">$result</span> with a <span class="subst">$device<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return result;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">say('</span></span>i'</span>, <span class="string">'am ok'</span>);</span><br><span class="line">say(<span class="string">'i'</span>, <span class="string">'am ok'</span>, <span class="string">'oneplus a5000'</span>);</span><br></pre></td></tr></table></figure><p><em>flutter命名参数？</em></p><p><em>5.异步</em></p><p>典型的异步函数有返回Future和Stream这些东西的函数，Future和JavaScript中的Promise是非常相像的.</p><p><em>6.基本知识</em></p><ul><li><p>1.Flutter中main函数是整个应用程序的入口，main函数中会调用runApp方法，他的功能是启动Flutter应用，这个函数所接受的参数为一个Widget类型的参数，换言之，一个Flutter应用本身就是一个widget。一个widget的主要工作就是提供一个build方法来描述该怎么构建UI界面（一般就是通过组合方式）。home是Flutter应用的首页，同时也是一个widget。</p></li><li><p>2.Stateful Widget和Stateless Widget的明显区别在于前者可以具有状态，而后者并不拥有。同时一个Stateful Widget至少由两个类组成：一个StatefulWidget类；一个State类。</p></li></ul><p><em>7.路由</em></p><p>Route在Android里面对应一个Activity，在IOS中对应的是ViewController。当然，在Flutter中一个Route也是一个widget，只不过这个widget会通过路由操作呈现在UI上面，定义一个widget如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AboutMe</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scafford(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'我的'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">            child: Text(<span class="string">'这个人很懒，什么也没有留下'</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好了一个Widget，那么怎么进行使用呢？答案就是利用Flutter提供的Navigator方法来实现路由操作，比如像下面这样的将路由push到路由栈的顶部：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scafford(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">            title: <span class="keyword">new</span> Text(<span class="string">'首页'</span>)</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">            child: <span class="keyword">new</span> Column(</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  FlatButton(</span><br><span class="line">                      child: Text(<span class="string">'我的'</span>),</span><br><span class="line">                      textColor: Colors.blue,</span><br><span class="line">                      onPressed: () &#123;</span><br><span class="line">                        Navigator.push(</span><br><span class="line">                            context,</span><br><span class="line">                            <span class="keyword">new</span> MaterialPageRoute(builder: (context)&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> AboutMe();</span><br><span class="line">                            &#125;)</span><br><span class="line">                        );</span><br><span class="line">                      &#125;</span><br><span class="line">                  )</span><br><span class="line">                ]</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点就是利用Navigator.push进行路由跳转，将一个widget路由页面通过MaterialPageRoute进行包装一下，MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，来自于Material组件库，实现与平台一致的动画效果；Navigator是Flutter提供的路由管理的widget，它通过一个栈来管理一个路由widget集合。下面是其暴露出了的两个常用的方法：</p><ul><li>Future push(BuildContext context, Route route)：将页面进行入栈</li><li>bool pop(BuildContext context)：将页面出栈</li></ul><p><em>8.命名路由</em></p><p>基本概念：给路由命名，之后便能直接通过路由名字打开一个新路由：</p><p>1.路由表表里面注册路由，到根widget里面进行注册routes，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'APP'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(primarySwatch: Colors.blue),</span><br><span class="line">        home: <span class="keyword">new</span> Index(),</span><br><span class="line">        routes: &#123;</span><br><span class="line">          <span class="string">"About"</span>: (context) =&gt; AboutMe()</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过路由名字打开一个路由需要调用Navigator.pushNamed方法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">'About'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Navigator.push(context,</span></span><br><span class="line"><span class="comment">  new MaterialPageRoute(builder: (context) &#123;</span></span><br><span class="line"><span class="comment">      return new AboutMe();</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.JIT以及AOT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JIT是just in time的缩写，表明即时编译，是指一边编译一边运行，Javascript和Python属于这一种类别；AOT则是需要经过提前编译，将其编译为机器码，典型代表是C/C++类语言。&lt;/
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>express2之database</title>
    <link href="http://yoursite.com/2018/12/20/express2%E4%B9%8Bdatabase/"/>
    <id>http://yoursite.com/2018/12/20/express2之database/</id>
    <published>2018-12-20T15:14:29.000Z</published>
    <updated>2018-12-23T08:45:43.031Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.基本名词</strong></p><p>在MongoDB中，每个database都会有一个或者多个collection，为了便于理解，可以把collection理解为array。一个collection里可以拥有任意个documents，一个documents很像js里面的对象，同一个collection里面的documents不必存储具有同样数据结构的数据。注意在技术上，documents并不是作为JSON存储的，documents看起来很像json，但是实际上它是binary JSON，俗称BSON。Mongo会给每个document增加一个_id属性，这个_id属性是独一无二的。</p><p><strong>2.关于加密库</strong></p><p>node不适合做计算密集型的工作任务，而对于密码学来说，往往需要很大的计算量，辛亏在node中可以很方便的调用node的扩展，所以有个bcrypt的库，其使用了C代码来处理这部分计算，加快了计算量。</p><p><strong>3.POST请求之body-parser</strong></p><p>POST请求传过来的参数可以是多种编码格式的，这个可以通过请求头里面的Content-Type字段看出，比如说下面这些：application/x-www-form-urlencoded(常见于form注册)，application/json常见于ajax发送json数据的时候，除了上面两种Content-Type之外，还存在其他常用的content-type，可以查阅相关资料，这里要说的是，在express中如何在req.body里面使用它们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;)); <span class="comment">// 针对application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.json()); <span class="comment">// 针对application/json</span></span><br></pre></td></tr></table></figure><p><strong>4.express之用户鉴权</strong></p><p>用户鉴权具有很多种方式，常见的有session-cookie机制，token机制，OAuth机制，下面进行逐一介绍：</p><p>4-1.session-cookie机制：基本概念：服务端的session，客户端的cookie，利用cookie和session来完成前后端的认证。因为HTTP请求是无状态的，所以服务器不能识别出用户的身份。采用session-cookie机制的话，就引入了一种判断用户身份的唯一标志session，每当用户进行登录的时候，服务端便会为该用户创建一个session（会话），这个session能够用来唯一标识用户，那么问题来了，session是服务端的，那么下次这个客户端的请求到来时，服务器怎么知道是这个用户呢？答案就是让用户携带和自己session所唯一对应的cookie进来，这个cookie在用户进行登录成功的时候服务端便设置好了，以后的客户端的每一次请求便会把这个cookie给携带进来，而服务端在每一次请求到来时都会去查一下该客户在本地有没有对应session，如果有的话，那么就说明验证成功了。</p><p>session-cookie机制主要分为下面几个步骤：</p><p>①.服务器在用户成功登录后在服务器端创建session-&gt;持久化保存session-&gt;给这个session生成一个唯一对应的sessionId</p><p>②.sessionId签名，根据设置的secret对sid进行加密处理，下次收到sid时接着会根据secret进行解密处理。（注意签名过程非必须）-&gt; 在该请求的响应头中种下这个sid。</p><p>③.浏览器在收到响应后，将sid保存到本地cookie中，使得浏览器接下来的请求能够将sid存在cookie中发送给服务端。</p><p>④.服务端在需要登录的接口上面验证客户端时候携带了sid，并且查找这个sid是否有在服务端中维护，如果有的话，那么就说明鉴权通过。</p><p>4-2:在Express中如何使用passport插件，首先要搞清楚，passport不负责实现鉴权逻辑，它只是一层包装，鉴权逻辑在包装里面，需要开发人员自行编写。使用passport进行用户鉴权的话，开发人员主要完成下面三部分逻辑处理：</p><p>①.在Express中引入中间件。</p><p>②.告诉passport如何去序列化和反序列化用户，这部分将用户的session映射成了实际的user object。</p><p>③.告诉passport怎么进行用户授权，既判断一个用户是否在系统中。 这个时候passport会和Mongo进行接触。</p><p>第一步：引入相关中间件，这个步骤依赖body-parser，cookie-parser，express-session，passport，passport-local。</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookieParser'</span>);</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> authSetting = <span class="built_in">require</span>(<span class="string">'./authSetting'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>, &#123; <span class="attr">userNewUrlParser</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">authSetting(); <span class="comment">// 一个配置passport的文件</span></span><br><span class="line"></span><br><span class="line">app.use(passport.initialize());</span><br><span class="line">app.use(passport.session());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));                          <span class="comment">// content-type 为 x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.json());                                                   <span class="comment">// content-type 为 application/json</span></span><br><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">'YOU_SESSION_SECRET'</span>,</span><br><span class="line">  resave: <span class="literal">true</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>第二步：告诉passport怎么序列化用户和反序列化用户。思考一下在express MongoDB技术栈里面如何将用户传过来的sid对应到user object上面，我们知道在MongoDB里面每一个文档都具有一个唯一的_id字段，利用这个字段来唯一标识用户是个可行的办法，并且查询的时候利用_id来查，效率也会比普通字段属性会更好。下面是实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authSetting.js</span></span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./models/user'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化用户，将用户转化为id</span></span><br><span class="line">  passport.serializeUser(<span class="function"><span class="keyword">function</span>(<span class="params">user, done</span>) </span>&#123;</span><br><span class="line">    done(<span class="literal">null</span>, user._id);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 解序列化用户，将用户id转化为user object</span></span><br><span class="line">  passport.deserializeUser(<span class="function"><span class="keyword">function</span>(<span class="params">id, done</span>) </span>&#123;</span><br><span class="line">    User.findById(id, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">      done(err, user);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三步：如何进行用户授权，在这一步中需要用上策略，这本例中使用本地策略。使用本地策略需要引入一个npm包-passport-local，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原有authSetting.js中加入</span></span><br><span class="line"><span class="keyword">const</span> LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>).Strategy; <span class="comment">// 引入本地passport-策略包</span></span><br></pre></td></tr></table></figure><p>接下来就是制定本地策略，如下所示：1.客户端在进行登录的时候，服务端获取到用户名（或其他id)；2.服务端根据这个用户名查找mongodb数据库中是否存在该用户，如果没有的话，可以返回这个用户未注册；3.如果存在这个用户的话，那么继续比对密码，如果密码正确的话，那么返回user object，如果密码比对错误的话，那么返回密码错误。示例代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// authSetting.js</span></span><br><span class="line">passport.use(<span class="string">'login'</span>, <span class="keyword">new</span> LocalStrategy(<span class="function"><span class="keyword">function</span>(<span class="params">username, password, done</span>) </span>&#123;</span><br><span class="line">  User.findOne(&#123;username&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 查询数据库的时候报错</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在这个用户</span></span><br><span class="line">    <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'No User Has That Username'</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    user.checkPassword(password, <span class="function"><span class="keyword">function</span>(<span class="params">err, isMatch</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;  <span class="comment">// 取密码出错</span></span><br><span class="line">        <span class="keyword">return</span> done(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isMatch) &#123;  <span class="comment">// 有这个用户，则返回这个用户</span></span><br><span class="line">        <span class="keyword">return</span> done(<span class="literal">null</span>, user);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 密码错误</span></span><br><span class="line">        <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Invalid password.'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>4-2.token机制：和session-cookie很像。大致流程如下所示：</p><p>①.客户进行登录</p><p>②.如果成功登录，服务端给这个用户生成一个唯一对应的token，并且将这个token返回给客户端</p><p>③.客户端将这个token进行存储</p><p>④.客户端接将token放在请求头里面发送给服务端</p><p>⑤.服务端在需要登录的页面中进行token验证，如果请求通过的话则放行。</p><p>和session-cookie的区别：</p><p>①.session-cookie需要经过一个中间层sid，而token不需要，就是直接代表了用户，并且在用户端和服务端之间传输。</p><p>②.不需要cookie进行配合，</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.基本名词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在MongoDB中，每个database都会有一个或者多个collection，为了便于理解，可以把collection理解为array。一个collection里可以拥有任意个documents，一个docum
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>小程序性能优化</title>
    <link href="http://yoursite.com/2018/12/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/12/18/小程序性能优化/</id>
    <published>2018-12-18T05:32:50.000Z</published>
    <updated>2018-12-18T05:32:50.176Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express</title>
    <link href="http://yoursite.com/2018/12/13/express/"/>
    <id>http://yoursite.com/2018/12/13/express/</id>
    <published>2018-12-13T14:11:01.000Z</published>
    <updated>2018-12-29T03:22:50.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。"><a href="#1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。" class="headerlink" title="1.express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。"></a>1.express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。</h3><h3 id="2-express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示："><a href="#2-express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示：" class="headerlink" title="2.express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示："></a>2.express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> morgan = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(morgan(<span class="string">'dev'</span>));</span><br></pre></td></tr></table></figure><h3 id="3-实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then-以及catch-的参数。一个Promise只能够被决议一次。"><a href="#3-实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then-以及catch-的参数。一个Promise只能够被决议一次。" class="headerlink" title="3.实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then()以及catch()的参数。一个Promise只能够被决议一次。"></a>3.实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then()以及catch()的参数。一个Promise只能够被决议一次。</h3><h3 id="4-express中间件的形式形如下面这样："><a href="#4-express中间件的形式形如下面这样：" class="headerlink" title="4.express中间件的形式形如下面这样："></a>4.express中间件的形式形如下面这样：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleWare</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do stuff with request and/or response</span></span><br><span class="line">  next(); <span class="comment">// when our middleware done,call the next middleWare to do work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你甚至可以创建一些下面这种没意思但是有趣的middleware</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, req.method, req.url); <span class="comment">// 打印请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a joke</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds();</span><br><span class="line">  <span class="keyword">if</span> (second % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">403</span>).json(&#123;<span class="string">"from_me"</span>: <span class="string">"403 forbidden"</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-一些不可错过的中间件之静态文件中间件："><a href="#5-一些不可错过的中间件之静态文件中间件：" class="headerlink" title="5.一些不可错过的中间件之静态文件中间件："></a>5.一些不可错过的中间件之静态文件中间件：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(PUBLIC_PATH));</span><br></pre></td></tr></table></figure><p>关于express.static中间件有一个需要注意的问题就是，当这个中间件进行了有效的服务的话（指分发了静态资源），那么它将会阻止中间件 chain，相当于不会调用next；但是如果没有匹配到需要分发的静态资源的话，那么会调用next，将执行权利继续交给下一个midlleware。所以最佳实践是将静态资源中间件放在后面的适当位置（自然是要放在404 middleware前面的）。</p><h3 id="6-路由：routing-is-a-way-to-map-requests-to-specific-handlers-depending-on-their-URL-and-HTTP-verb。"><a href="#6-路由：routing-is-a-way-to-map-requests-to-specific-handlers-depending-on-their-URL-and-HTTP-verb。" class="headerlink" title="6.路由：routing is a way to map requests to specific handlers depending on their URL and HTTP verb。"></a>6.路由：routing is a way to map requests to specific handlers depending on <strong>their URL and HTTP verb</strong>。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/hello/:who'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">`&lt;h1&gt;hello <span class="subst">$&#123;req.params.who&#125;</span>&lt;/h1&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-重定向："><a href="#7-重定向：" class="headerlink" title="7.重定向："></a>7.重定向：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/redirect'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.redirect(<span class="string">'/index'</span>); <span class="comment">// 站内重定向，或者像下面这样，重定向到其他站点</span></span><br><span class="line">  <span class="comment">// res.redirect('http://www.expressjs.com');</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-发文件："><a href="#8-发文件：" class="headerlink" title="8.发文件："></a>8.发文件：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">'somePath'</span>);</span><br><span class="line">app.get(<span class="string">'/file'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(filePath); <span class="comment">// 需要注意的是并不会触发下载操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）："><a href="#9-获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）：" class="headerlink" title="9.获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）："></a>9.获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.ip, req.method, req.url);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="10-获取请求头中的某个字段的值："><a href="#10-获取请求头中的某个字段的值：" class="headerlink" title="10.获取请求头中的某个字段的值："></a>10.获取请求头中的某个字段的值：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.ip, req.method, req.url, req.get(<span class="string">'Accept-Language'</span>));</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="11-视图（采用ejs视图为例）："><a href="#11-视图（采用ejs视图为例）：" class="headerlink" title="11.视图（采用ejs视图为例）："></a>11.视图（采用ejs视图为例）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'views'</span>, path.resolve(__dirname, <span class="string">'VIEWS_PATH'</span>));              <span class="comment">// 第一步设置视图文件所在的文件位置</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'ejs'</span>);                                         <span class="comment">// 设置视图引擎为EJS</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;<span class="attr">message</span> : <span class="string">'ejs template'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// VIEWS_PATH/index.ejs</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;ejs&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;%= message %&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><h3 id="12-让所有视图都可以使用某个数据-将这个数据挂载到app-locals下面即可-："><a href="#12-让所有视图都可以使用某个数据-将这个数据挂载到app-locals下面即可-：" class="headerlink" title="12.让所有视图都可以使用某个数据(将这个数据挂载到app.locals下面即可)："></a>12.让所有视图都可以使用某个数据(将这个数据挂载到app.locals下面即可)：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.locals.allCanUse = <span class="string">'all the views template can use this me'</span>;</span><br></pre></td></tr></table></figure><h3 id="13-res-end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。"><a href="#13-res-end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。" class="headerlink" title="13.res.end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。"></a>13.res.end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。</h3><h3 id="14-Express中的middleware-stack"><a href="#14-Express中的middleware-stack" class="headerlink" title="14.Express中的middleware stack"></a>14.Express中的middleware stack</h3><p>首先有很重要的一点需要明白，那就是express是基于node进行处理的，前面也提到了，node处理输入并作出响应可以被抽象为对req object以及res object的处理，node把每个网络中传输过来的二进制请求转换为JavaScript object，当我们做好了响应后，使用res.end便又把响应数据发送给了客户端。在原生的node里面，这两个对象在一个函数过程里面进行处理。而在express中，req，res这两个对象是经由一系列的函数数组进行处理的，这个函数数组便叫做middleware stack了。具体过程便是：1.请求到达node server-&gt;2.交接给express APP进行处理-&gt;3.express中middleware stack中的每一个函数对请求进行处理-&gt;4.处理好了之后将结果返回给node server-&gt;5.发回给客户。</p><p>middleware stack中的每一个函数都接受三个参数，其中前两个分别是req和res，他们都是node server产生的，当然express在两个对象的基础上进行了一些增强。第三个参数就是next，是一个函数类型的变量。</p><p>当处理好了响应（响应数据已经可以发送给客户端了）的时候，调用res.end方法即可；当然在express中，我们也可以通过调用其他方法比如说res.send和res.sendFile或者json等，无论如何，上面这些提到的方法都将调用res.end。</p><p>对于一个中间件来说，下面两个动作必须执行其中的某一个，否则会发生错误（比如请求一直被挂起）。两个动作分别如下所示：</p><ul><li>1.作出响应，具体来说就是调用res.end或者res.send,以及res.sendFile等；</li><li>2.调用next()将执行权利交出去，让middleware stack中的下一个函数执行；</li></ul><p><strong>15.错误中间件，错误中间件具有四个参数，按照顺序来分别是(err, req, res, next)。如果在某个正常的中间件中，调用next方法的时候传入了一个Error参数的话，那么当这个中间件执行完后，接下来执行的中间件有可能就不是下一个中间件了，而是下一个错误捕获中间件。并且错误中间件也能够调用next方法，同理，如果往next里面传入了一个错误参数的话那么也是跳到最近的下一个错误中间件。举个例子：假如有A,B,C,D,E,F这六个中间件，其中中间件C和中间件E都是错误中间件的话，那么当在执行B中间件的时候如果next的参数是一个error的话，那么执行权就到了最近的下一个错误捕获中间件C，如果继续在中间件C中的next方法传入一个error参数的话，那么执行权就又到了E错误中间件。</strong></p><p><strong>16.路由：express能够根据HTTP动作和请求资源将请求链接到相应的controller上面。</strong></p><p>动态路由匹配使用下面这种模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/users/:userId'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do some stuff</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>类似于上面这样的路由能够动态匹配到/users/123和/users/ebooks等类似的；但是对于像下面这样的路由是匹配不到的：/users/或者/users/123/photo等类似的。</p><p><strong>17.动态路由匹配之使用正则表达式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/^\/users\/(\d+)$/</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> userId = <span class="built_in">parseInt</span>(req.params[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于上面这个例子来说，我们定义的正则表达式所表达的意思是指：必须是以/users开始，以一个数字或者多个数字结尾的路由；使用正则表达式来定义动态路由匹配和使用普通字符串来匹配路由有一个区别就是，正则表达式没有给动态内容命名，对于这种情况，express是这样处理的：利用索引进行访问，每个被正则表达式所匹配到的值都会顺序占据数组的一个位置。所以看看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/^\/users\/(\d+)-(\d+)$/</span>, (req, res) =&gt; &#123; <span class="comment">// 貌似一个圆括号是一个匹配单位</span></span><br><span class="line">  <span class="keyword">let</span> startId = <span class="built_in">parseInt</span>(req.params[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">let</span> endId = <span class="built_in">parseInt</span>(req.params[<span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看一个更加复杂的匹配要求，要求匹配 xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx，其中x是任意一个十六进制中的一个数，y是8，9，A，B中的某一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^([0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-4[0-9a-f]&#123;3&#125;-[89AB][0-9a-f]&#123;3&#125;-[0-9a-f]&#123;12&#125;)$/i</span>;</span><br><span class="line">app.get(reg, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> uuid = req.params[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>18.路由值查询字符串匹配</strong></p><p>先看一个正常的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url像这样：/search?key=chaos</span></span><br><span class="line">app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> key = req.query.key; <span class="comment">// 值是一个字符串</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看一个不太正常的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url像这样：/search?key=oh&amp;key=no ; 糟糕的url设计</span></span><br><span class="line">app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = req.query.key; <span class="comment">// 由于两个query的键名一样，所以键值是一个数组！！！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>19.express路由：</strong></p><p>Routers就是一个中间件的角色，可以使用app.use方法在express的实例化对象中使用这个这个中间件。换句话说，routes把我们整个应用分割成了几份小app来对待，这可以避免在app.js里面出现大量的路由逻辑代码，避免app.js变得越来越臃肿。</p><p>下面可以看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">'./routes/apiRouter'</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/api'</span>, apiRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes/apiRouter.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = express.Router();</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'/users'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.status(<span class="number">200</span>).send(<span class="string">'获取用户列表数据成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'/topic'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.status(<span class="number">200</span>).send(<span class="string">'获取热点数据成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = api;</span><br></pre></td></tr></table></figure><p><strong>20.https一些基础知识</strong></p><p>https之所以比http安全，是因为他在http的基础上增加了一层协议——TLS或SSL，这里简单的提一下TLS。TLS使用的加密技术简单来说就是这样：每个节点中的设备都具有一个public key和一个private key，其中public key只有自己知道，而private key则所有网络中的其他节点都能知道。当节点A想传数据给节点B的时候，节点A发送的信息会使用自己的private key和节点B的public key进行加密，当节点B接收到数据后，在利用自己的private key和节点A的public key进行解密。由于理论上，自己的private key只有自己知道，因此即使传输数据被其它设备给非法获取的话，那么也不能够破解出传输内容。</p><p><strong>21.在express中既使用http服务也使用https服务：</strong></p><p>利用HTTPS的话首先需要用户私钥以及凭证，我们可以利用OpenSSL来生成，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 项目根目录</span></span><br><span class="line">openssl genrsa -out privatekey.pem 1024           <span class="comment">## 生成私钥</span></span><br><span class="line">openssl req -new -key privatekey.pem -out request.pem       <span class="comment">## 生成凭证</span></span><br></pre></td></tr></table></figure><p>在express中既启动http服务又启动https服务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目根目录index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpsOptions = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'./privatekey.pem'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'./request.pem'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">80</span>);</span><br><span class="line">https.createServer(httpsOptions, app).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure><p><strong>22.http动词进一步认识</strong></p><ul><li>1.GET: GET方法不应该改变应用的状态，GET是幂等性的，这意味着你从服务器连续取500次某种资源的结果和只取一次的结果应该是一样的，资源不应该发生变化。</li></ul><p><strong>23.api version：为了兼容老用户，但是新的业务逻辑又的确需要更改</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api1.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = express.Router();</span><br><span class="line"></span><br><span class="line">api.get(<span class="string">'time'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123; <span class="attr">time</span>: str &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> routerV1 = <span class="built_in">require</span>(<span class="string">'./api1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'v1'</span>, routerV1); <span class="comment">// url =&gt; /v1/time</span></span><br><span class="line">app.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'port 8080'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>24.一些HTTP状态码:</strong></p><ul><li><ol><li>100 =&gt; Continue</li></ol></li><li><ol start="2"><li>101 =&gt; Switch Protocol</li></ol></li><li><ol start="3"><li>200 =&gt; Ok</li></ol></li><li><ol start="4"><li>201 =&gt; 成功，常见于PUT请求和POST请求</li></ol></li><li><ol start="5"><li>202 =&gt; 成功收到请求，但是请求的东西还在处理过程中</li></ol></li><li><ol start="6"><li>301 =&gt; don’t visit this url any more</li></ol></li><li><ol start="7"><li>401 =&gt; 未授权 Unauthorized</li></ol></li><li><ol start="8"><li>403 =&gt; 无权 Forbidden</li></ol></li><li><ol start="9"><li>404 =&gt; 资源找不到</li></ol></li><li><ol start="10"><li>500 =&gt; 服务器出错了</li></ol></li></ul><p><strong>25.从req.headers中获取到你想要访问的请求头</strong></p><ul><li>req.headers.origin: 资源发起位置</li><li>req.headers.referer: 原始资源位置</li></ul><p><strong>26.HTTP的OPTIONS方法用于获取目的资源所支持的通信选项，客户端可以对特定的URL使用OPTIONS方法，也可以对整站使用OPTIONS方法（通过将URL设置为通配符*）即可。同时，在跨域中，在发起一个正式请求之前也一定会发起一个预检请求，这个预检请求会被服务器检查是否支持接下来的实际请求，这个预检请求报文中的Access-Control-Request-Method首部字段的值就是实际请求中的Access-Control-Request-Method的值，预检请求报文中的Access-Control-Request-Headers首部字段的值就是接下来实际请求中的Access-Control-Request-Method的值，服务器在收到OPTOINS预检请求后，会返回一个Access-Control-Allow-Methods首部字段，这个字段会表明服务器所允许的请求方法，和Allow字段类似，但是Access-Control-Allow-Methods只会用在CORS上面（注意GET,HEAD,POST可能不受此限制)。</strong></p><p><strong>27.前面提到了预检请求，那么在客户端发送了一个预检请求后，如果预检请求后客户端发送请求头中method和服务端返回的响应头中的method不匹配的话，那么该怎么阻挡下次正式请求发送呢？答案就是浏览器会自动判断，如果不匹配的话，那么浏览器会自动阻止下次正式请求的发起。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。&quot;&gt;&lt;a href=&quot;#1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch</title>
    <link href="http://yoursite.com/2018/12/13/elasticsearch/"/>
    <id>http://yoursite.com/2018/12/13/elasticsearch/</id>
    <published>2018-12-13T09:00:42.000Z</published>
    <updated>2018-12-13T14:13:05.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>需要先安装Java环境，接着直接到elasticsearch官网下载软件包，解压缩。启动到其解压后目录，运行./bin/elasticsearch即可。</p><p>测试是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9200/</span><br></pre></td></tr></table></figure><p>能看到序列化后的json字符串输出就说明成功启动了。（注意在启动时的日志上面会标明elasticsearch的启动端口以及IP）。</p><h3 id="2-ElasticSearch以及restful"><a href="#2-ElasticSearch以及restful" class="headerlink" title="2.ElasticSearch以及restful"></a>2.ElasticSearch以及restful</h3><p>restful：url就表示客户需要的资源，而需要对资源进行什么操作体现在http方法上。和大部分场景一样，在ElasticSearch中，资源就是json文档，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h3&gt;&lt;p&gt;需要先安装Java环境，接着直接到elasticsearch官网下载软件包，解压缩。启动到其解压后目录，运行./bin/el
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nodejs之process</title>
    <link href="http://yoursite.com/2018/12/12/nodejs%E4%B9%8Bprocess/"/>
    <id>http://yoursite.com/2018/12/12/nodejs之process/</id>
    <published>2018-12-12T11:57:32.000Z</published>
    <updated>2018-12-12T14:10:01.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"><a href="#1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。" class="headerlink" title="1.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"></a>1.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。</h3><h3 id="2-使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示："><a href="#2-使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示：" class="headerlink" title="2.使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示："></a>2.使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;   <span class="comment">// 判断是否是主进程</span></span><br><span class="line">  <span class="comment">// 每当成功创建一个进程，便会emit一个online事件，而主进程能够监听这个事件</span></span><br><span class="line">  cluster.on(<span class="string">'online'</span>, worker =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> is online`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;    <span class="comment">// 创建10个worker</span></span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 这是worker，每个worker运行的工作可以放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-被fork出来的process也被叫做worker-每个worker能够和master通过各种events来进行交流。"><a href="#3-被fork出来的process也被叫做worker-每个worker能够和master通过各种events来进行交流。" class="headerlink" title="3.被fork出来的process也被叫做worker,每个worker能够和master通过各种events来进行交流。"></a>3.被fork出来的process也被叫做worker,每个worker能够和master通过各种events来进行交流。</h3><h3 id="4-再看一下下面这个例子："><a href="#4-再看一下下面这个例子：" class="headerlink" title="4.再看一下下面这个例子："></a>4.再看一下下面这个例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CPUS = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cpus'</span>, CPUS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'master listening...'</span>);</span><br><span class="line"></span><br><span class="line">    cluster.on(<span class="string">'listening'</span>, (worker, address) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(worker.process.pid, address.address+<span class="string">''</span>+address.port);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(worker.process.pid + <span class="string">'died'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; CPUS; i++) &#123;</span><br><span class="line">        cluster.fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">200</span>);</span><br><span class="line">        res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">    &#125;).listen(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：对于上面的打印cpus的数量这一行，会打印几遍呢？答案是打印CPUS+1遍，不仅每个创建出来的worker运行了这份脚本，而且主worker也运行了这份脚本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>node事件循环</title>
    <link href="http://yoursite.com/2018/12/12/node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2018/12/12/node事件循环/</id>
    <published>2018-12-12T09:11:18.000Z</published>
    <updated>2018-12-12T09:11:18.568Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数式一</title>
    <link href="http://yoursite.com/2018/12/11/%E5%87%BD%E6%95%B0%E5%BC%8F%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/11/函数式一/</id>
    <published>2018-12-11T07:58:40.000Z</published>
    <updated>2018-12-13T13:52:17.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子："><a href="#1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：" class="headerlink" title="1.纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子："></a>1.纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Flock = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flock.prototype.conjoin = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag += other.seag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flock.prototype.breed = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag *= other.seag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Flock(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Flock(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Flock(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.breed(b) =&gt; 16;  16 + 16;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = a.conjoin(c).breed(b).conjoin(a.breed(b)).seag;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);    <span class="comment">// =&gt; 32</span></span><br></pre></td></tr></table></figure><p>上面这个例子输出的结果是32。</p><h3 id="2-区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array-prototype-slice就是一个纯方法，而Array-prototype-splice并不是一个纯方法。"><a href="#2-区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array-prototype-slice就是一个纯方法，而Array-prototype-splice并不是一个纯方法。" class="headerlink" title="2.区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array.prototype.slice就是一个纯方法，而Array.prototype.splice并不是一个纯方法。"></a>2.区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array.prototype.slice就是一个纯方法，而Array.prototype.splice并不是一个纯方法。</h3><h3 id="3-一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态："><a href="#3-一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态：" class="headerlink" title="3.一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态："></a>3.一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mini = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data &gt;= mini;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pure的应该像下面这样的写法</span></span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mini = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> data &gt;= mini;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-可以使用Object-freeze来创建一个不可变对象："><a href="#4-可以使用Object-freeze来创建一个不可变对象：" class="headerlink" title="4.可以使用Object.freeze来创建一个不可变对象："></a>4.可以使用Object.freeze来创建一个不可变对象：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = <span class="built_in">Object</span>.freeze(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);  <span class="comment">// 还是为1</span></span><br></pre></td></tr></table></figure><h3 id="5-纯函数的优点一：可缓存性："><a href="#5-纯函数的优点一：可缓存性：" class="headerlink" title="5.纯函数的优点一：可缓存性："></a>5.纯函数的优点一：可缓存性：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** memoize函数能够将计算过的值给缓存起来，节约计算时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">    cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[arg_str];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x &#125;);</span><br><span class="line">square(<span class="number">5</span>);</span><br><span class="line">square(<span class="number">5</span>); <span class="comment">// 从缓存里面取值</span></span><br></pre></td></tr></table></figure><h3 id="6-组合，下面可以看一个函数组合的例子："><a href="#6-组合，下面可以看一个函数组合的例子：" class="headerlink" title="6.组合，下面可以看一个函数组合的例子："></a>6.组合，下面可以看一个函数组合的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x=<span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.toUpperCase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">x=<span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> power = compose(toUpperCase, reverseString);  <span class="comment">// 很直观 从右到左</span></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="string">'hello frp'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：&quot;&gt;&lt;a href=&quot;#1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：&quot; class=&quot;headerlink&quot; title=&quot;1.纯函数：同一个输入，同一个输出，不改变数
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>rn基础一</title>
    <link href="http://yoursite.com/2018/12/11/rn%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/11/rn基础一/</id>
    <published>2018-12-11T05:51:46.000Z</published>
    <updated>2018-12-11T05:57:59.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-设置全屏"><a href="#1-设置全屏" class="headerlink" title="1.设置全屏"></a>1.设置全屏</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; View, Dimensions &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;&#123;<span class="attr">width</span>: Dimensions.get(<span class="string">'window'</span>).width, <span class="attr">height</span>: Dimensions.get(<span class="string">'window'</span>).height&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-设置全屏&quot;&gt;&lt;a href=&quot;#1-设置全屏&quot; class=&quot;headerlink&quot; title=&quot;1.设置全屏&quot;&gt;&lt;/a&gt;1.设置全屏&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>react生态基本使用笔记</title>
    <link href="http://yoursite.com/2018/12/07/react%E7%94%9F%E6%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/07/react生态基本使用笔记/</id>
    <published>2018-12-07T03:18:59.000Z</published>
    <updated>2018-12-23T05:24:36.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用react-router的link标签的时候可以这样使用："><a href="#1-使用react-router的link标签的时候可以这样使用：" class="headerlink" title="1.使用react-router的link标签的时候可以这样使用："></a>1.使用react-router的link标签的时候可以这样使用：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">`routeUrl`</span>, <span class="attr">state</span>: stateObj &#125;&#125;&gt;target&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure><p>Link里面所传递的state对象在子页面中可以通过this.props.location.state来进行获取。一个好处，放在location里面的数据不会被刷新掉。</p><h3 id="2-更新过程不会触发componentWillMount以及componentDidMount。"><a href="#2-更新过程不会触发componentWillMount以及componentDidMount。" class="headerlink" title="2.更新过程不会触发componentWillMount以及componentDidMount。"></a>2.更新过程不会触发componentWillMount以及componentDidMount。</h3><h3 id="3-一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this-props-params-classId来获取班级id。"><a href="#3-一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this-props-params-classId来获取班级id。" class="headerlink" title="3.一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this.props.params.classId来获取班级id。"></a>3.一个route形如下面这样的话：<route path="course/:courseId/class/:classId" component="{CourseClassInfo}/">，那么我们可以在CourseClassInfo组件中通过this.props.params.classId来获取班级id。</route></h3><p><strong>4.React挂载阶段所触发的生命周期方法：</strong></p><ul><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p><em>需要注意的地方，React 16.3版本发布以后，引入了下面几个生命周期方法：UNSAFE_componentWillMount,UNSAFE_componentWillReceiveProps,UNSAFE_componentWillUpdate，这几个方法是用来替代componentWillMount和componentWillReceiveProps以及componentWillUpdate的，为什么要进项替代？因为这几个方法在接下来react主要希望实现的目标-异步渲染中将会带来比之前更大的误解。</em> 虽然在react 16.3版本中引入了这几个方法，但是旧的原有方法和新的替代方法是处于一个可以共存的状态下。</p><p>来到react 17以上的版本之后，react将componentWillMount，componentWillReceiveProps，componentWillUpdate这些旧方法都给移除了。只有这些方法相对应的带有UNSAFE_前缀的才可使用。</p><p><strong>5.更新阶段执行的生命周期方法：首先更新一个组件有三种途径，分别是父组件更新，自身状态变化，自身强制更新</strong>。不同的途径所触发的生命周期方法是不同的，<em>先介绍父组件更新所触发的生命周期方法：</em></p><ul><li>1.componentWillReceiveProps()</li><li>2.shouldComponentUpdate()</li><li>3.componentWillUpdate()</li><li>4.render()</li><li>5.componentDidUpdate()</li></ul><p><em>当自身状态发生变化的时候，也就是自己调用setState，此时触发的生命周期方法如下所示：</em></p><ul><li>1.shouldComponentUpdate()</li><li>2.componentWillUpdate()</li><li>3.render()</li><li>4.componentDidUpdate()</li></ul><p><em>当调用forceUpdate()强制触发更新的时候，将会触发下面这些生命周期方法：</em></p><ul><li>1.componentWillUpdate()</li><li>2.render()</li><li>3.componentDidUpdate()</li></ul><p><strong>6.卸载阶段：这个阶段调用的就是componentWillUnmount，可以在这个方法里面执行一些垃圾回收操作。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用react-router的link标签的时候可以这样使用：&quot;&gt;&lt;a href=&quot;#1-使用react-router的link标签的时候可以这样使用：&quot; class=&quot;headerlink&quot; title=&quot;1.使用react-router的link标签的时候
      
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
</feed>
