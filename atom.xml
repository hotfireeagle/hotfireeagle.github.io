<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜游</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-16T13:31:09.594Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hahahai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>express</title>
    <link href="http://yoursite.com/2018/12/13/express/"/>
    <id>http://yoursite.com/2018/12/13/express/</id>
    <published>2018-12-13T14:11:01.000Z</published>
    <updated>2018-12-16T13:31:09.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。"><a href="#1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。" class="headerlink" title="1.express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。"></a>1.express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。</h3><h3 id="2-express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示："><a href="#2-express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示：" class="headerlink" title="2.express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示："></a>2.express被设计成了插件机制，如果你想实现什么功能的话，那么使用相对应的中间件即可。使用中间件的方法如下所示：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> morgan = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(morgan(<span class="string">'dev'</span>));</span><br></pre></td></tr></table></figure><h3 id="3-实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then-以及catch-的参数。一个Promise只能够被决议一次。"><a href="#3-实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then-以及catch-的参数。一个Promise只能够被决议一次。" class="headerlink" title="3.实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then()以及catch()的参数。一个Promise只能够被决议一次。"></a>3.实例化Promise对象时所传递的callback是立执行的。resolve以及reject中的参数将会作为then()以及catch()的参数。一个Promise只能够被决议一次。</h3><h3 id="4-express中间件的形式形如下面这样："><a href="#4-express中间件的形式形如下面这样：" class="headerlink" title="4.express中间件的形式形如下面这样："></a>4.express中间件的形式形如下面这样：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleWare</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do stuff with request and/or response</span></span><br><span class="line">  next(); <span class="comment">// when our middleware done,call the next middleWare to do work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你甚至可以创建一些下面这种没意思但是有趣的middleware</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, req.method, req.url); <span class="comment">// 打印请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a joke</span></span><br><span class="line">  <span class="keyword">let</span> second = <span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds();</span><br><span class="line">  <span class="keyword">if</span> (second % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.status(<span class="number">403</span>).json(&#123;<span class="string">"from_me"</span>: <span class="string">"403 forbidden"</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-一些不可错过的中间件之静态文件中间件："><a href="#5-一些不可错过的中间件之静态文件中间件：" class="headerlink" title="5.一些不可错过的中间件之静态文件中间件："></a>5.一些不可错过的中间件之静态文件中间件：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(PUBLIC_PATH));</span><br></pre></td></tr></table></figure><p>关于express.static中间件有一个需要注意的问题就是，当这个中间件进行了有效的服务的话（指分发了静态资源），那么它将会阻止中间件 chain，相当于不会调用next；但是如果没有匹配到需要分发的静态资源的话，那么会调用next，将执行权利继续交给下一个midlleware。所以最佳实践是将静态资源中间件放在后面的适当位置（自然是要放在404 middleware前面的）。</p><h3 id="6-路由：routing-is-a-way-to-map-requests-to-specific-handlers-depending-on-their-URL-and-HTTP-verb。"><a href="#6-路由：routing-is-a-way-to-map-requests-to-specific-handlers-depending-on-their-URL-and-HTTP-verb。" class="headerlink" title="6.路由：routing is a way to map requests to specific handlers depending on their URL and HTTP verb。"></a>6.路由：routing is a way to map requests to specific handlers depending on <strong>their URL and HTTP verb</strong>。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/hello/:who'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">`&lt;h1&gt;hello <span class="subst">$&#123;req.params.who&#125;</span>&lt;/h1&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-重定向："><a href="#7-重定向：" class="headerlink" title="7.重定向："></a>7.重定向：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/redirect'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.redirect(<span class="string">'/index'</span>); <span class="comment">// 站内重定向，或者像下面这样，重定向到其他站点</span></span><br><span class="line">  <span class="comment">// res.redirect('http://www.expressjs.com');</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-发文件："><a href="#8-发文件：" class="headerlink" title="8.发文件："></a>8.发文件：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">'somePath'</span>);</span><br><span class="line">app.get(<span class="string">'/file'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(filePath); <span class="comment">// 需要注意的是并不会触发下载操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）："><a href="#9-获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）：" class="headerlink" title="9.获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）："></a>9.获取访问ip（利用这个功能很容易实现拦截指定IP用户访问站点）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.ip, req.method, req.url);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="10-获取请求头中的某个字段的值："><a href="#10-获取请求头中的某个字段的值：" class="headerlink" title="10.获取请求头中的某个字段的值："></a>10.获取请求头中的某个字段的值：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.ip, req.method, req.url, req.get(<span class="string">'Accept-Language'</span>));</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="11-视图（采用ejs视图为例）："><a href="#11-视图（采用ejs视图为例）：" class="headerlink" title="11.视图（采用ejs视图为例）："></a>11.视图（采用ejs视图为例）：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'views'</span>, path.resolve(__dirname, <span class="string">'VIEWS_PATH'</span>));              <span class="comment">// 第一步设置视图文件所在的文件位置</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'ejs'</span>);                                         <span class="comment">// 设置视图引擎为EJS</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;<span class="attr">message</span> : <span class="string">'ejs template'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// VIEWS_PATH/index.ejs</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;ejs&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;%= message %&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><h3 id="12-让所有视图都可以使用某个数据-将这个数据挂载到app-locals下面即可-："><a href="#12-让所有视图都可以使用某个数据-将这个数据挂载到app-locals下面即可-：" class="headerlink" title="12.让所有视图都可以使用某个数据(将这个数据挂载到app.locals下面即可)："></a>12.让所有视图都可以使用某个数据(将这个数据挂载到app.locals下面即可)：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.locals.allCanUse = <span class="string">'all the views template can use this me'</span>;</span><br></pre></td></tr></table></figure><h3 id="13-res-end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。"><a href="#13-res-end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。" class="headerlink" title="13.res.end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。"></a>13.res.end表明node已经处理好了响应对象，是时候将响应对象发送给客户端了。</h3><h3 id="14-Express中的middleware-stack"><a href="#14-Express中的middleware-stack" class="headerlink" title="14.Express中的middleware stack"></a>14.Express中的middleware stack</h3><p>首先有很重要的一点需要明白，那就是express是基于node进行处理的，前面也提到了，node处理输入并作出响应可以被抽象为对req object以及res object的处理，node把每个网络中传输过来的二进制请求转换为JavaScript object，当我们做好了响应后，使用res.end便又把响应数据发送给了客户端。在原生的node里面，这两个对象在一个函数过程里面进行处理。而在express中，req，res这两个对象是经由一系列的函数数组进行处理的，这个函数数组便叫做middleware stack了。具体过程便是：1.请求到达node server-&gt;2.交接给express APP进行处理-&gt;3.express中middleware stack中的每一个函数对请求进行处理-&gt;4.处理好了之后将结果返回给node server-&gt;5.发回给客户。</p><p>middleware stack中的每一个函数都接受三个参数，其中前两个分别是req和res，他们都是node server产生的，当然express在两个对象的基础上进行了一些增强。第三个参数就是next，是一个函数类型的变量。</p><p>当处理好了响应（响应数据已经可以发送给客户端了）的时候，调用res.end方法即可；当然在express中，我们也可以通过调用其他方法比如说res.send和res.sendFile或者json等，无论如何，上面这些提到的方法都将调用res.end。</p><p>对于一个中间件来说，下面两个动作必须执行其中的某一个，否则会发生错误（比如请求一直被挂起）。两个动作分别如下所示：</p><ul><li>1.作出响应，具体来说就是调用res.end或者res.send,以及res.sendFile等；</li><li>2.调用next()将执行权利交出去，让middleware stack中的下一个函数执行；</li></ul><p><strong>15.错误中间件，错误中间件具有四个参数，按照顺序来分别是(err, req, res, next)。如果在某个正常的中间件中，调用next方法的时候传入了一个Error参数的话，那么当这个中间件执行完后，接下来执行的中间件有可能就不是下一个中间件了，而是下一个错误捕获中间件。并且错误中间件也能够调用next方法，同理，如果往next里面传入了一个错误参数的话那么也是跳到最近的下一个错误中间件。举个例子：假如有A,B,C,D,E,F这六个中间件，其中中间件C和中间件E都是错误中间件的话，那么当在执行B中间件的时候如果next的参数是一个error的话，那么执行权就到了最近的下一个错误捕获中间件C，如果继续在中间件C中的next方法传入一个error参数的话，那么执行权就又到了E错误中间件。</strong></p><p><strong>16.路由：express能够根据HTTP动作和请求资源将请求链接到相应的controller上面。</strong></p><p>动态路由匹配使用下面这种模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/users/:userId'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do some stuff</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>类似于上面这样的路由能够动态匹配到/users/123和/users/ebooks等类似的；但是对于像下面这样的路由是匹配不到的：/users/或者/users/123/photo等类似的。</p><p><strong>17.动态路由匹配之使用正则表达式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/^\/users\/(\d+)$/</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> userId = <span class="built_in">parseInt</span>(req.params[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于上面这个例子来说，我们定义的正则表达式所表达的意思是指：必须是以/users开始，以一个数字或者多个数字结尾的路由；使用正则表达式来定义动态路由匹配和使用普通字符串来匹配路由有一个区别就是，正则表达式没有给动态内容命名，对于这种情况，express是这样处理的：利用索引进行访问，每个被正则表达式所匹配到的值都会顺序占据数组的一个位置。所以看看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="regexp">/^\/users\/(\d+)-(\d+)$/</span>, (req, res) =&gt; &#123; <span class="comment">// 貌似一个圆括号是一个匹配单位</span></span><br><span class="line">  <span class="keyword">let</span> startId = <span class="built_in">parseInt</span>(req.params[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">let</span> endId = <span class="built_in">parseInt</span>(req.params[<span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看一个更加复杂的匹配要求，要求匹配 xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx，其中x是任意一个十六进制中的一个数，y是8，9，A，B中的某一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^([0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-4[0-9a-f]&#123;3&#125;-[89AB][0-9a-f]&#123;3&#125;-[0-9a-f]&#123;12&#125;)$/i</span>;</span><br><span class="line">app.get(reg, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> uuid = req.params[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>18.路由值查询字符串匹配</strong></p><p>先看一个正常的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url像这样：/search?key=chaos</span></span><br><span class="line">app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> key = req.query.key; <span class="comment">// 值是一个字符串</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看一个不太正常的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url像这样：/search?key=oh&amp;key=no ; 糟糕的url设计</span></span><br><span class="line">app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> keyArr = req.query.key; <span class="comment">// 由于两个query的键名一样，所以键值是一个数组！！！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。&quot;&gt;&lt;a href=&quot;#1-express模块自身就是一个函数，而我们要做的就是利用这个函数去实例化出一个server对象。&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch</title>
    <link href="http://yoursite.com/2018/12/13/elasticsearch/"/>
    <id>http://yoursite.com/2018/12/13/elasticsearch/</id>
    <published>2018-12-13T09:00:42.000Z</published>
    <updated>2018-12-13T14:13:05.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>需要先安装Java环境，接着直接到elasticsearch官网下载软件包，解压缩。启动到其解压后目录，运行./bin/elasticsearch即可。</p><p>测试是否启动成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9200/</span><br></pre></td></tr></table></figure><p>能看到序列化后的json字符串输出就说明成功启动了。（注意在启动时的日志上面会标明elasticsearch的启动端口以及IP）。</p><h3 id="2-ElasticSearch以及restful"><a href="#2-ElasticSearch以及restful" class="headerlink" title="2.ElasticSearch以及restful"></a>2.ElasticSearch以及restful</h3><p>restful：url就表示客户需要的资源，而需要对资源进行什么操作体现在http方法上。和大部分场景一样，在ElasticSearch中，资源就是json文档，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h3&gt;&lt;p&gt;需要先安装Java环境，接着直接到elasticsearch官网下载软件包，解压缩。启动到其解压后目录，运行./bin/el
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nodejs之process</title>
    <link href="http://yoursite.com/2018/12/12/nodejs%E4%B9%8Bprocess/"/>
    <id>http://yoursite.com/2018/12/12/nodejs之process/</id>
    <published>2018-12-12T11:57:32.000Z</published>
    <updated>2018-12-12T14:10:01.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"><a href="#1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。" class="headerlink" title="1.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"></a>1.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。</h3><h3 id="2-使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示："><a href="#2-使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示：" class="headerlink" title="2.使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示："></a>2.使用cluster模块来创建进程，每当调用fork方法时，都会创建一个进程来运行和当前脚本一模一样的内容，如下所示：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;   <span class="comment">// 判断是否是主进程</span></span><br><span class="line">  <span class="comment">// 每当成功创建一个进程，便会emit一个online事件，而主进程能够监听这个事件</span></span><br><span class="line">  cluster.on(<span class="string">'online'</span>, worker =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> is online`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;    <span class="comment">// 创建10个worker</span></span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 这是worker，每个worker运行的工作可以放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-被fork出来的process也被叫做worker-每个worker能够和master通过各种events来进行交流。"><a href="#3-被fork出来的process也被叫做worker-每个worker能够和master通过各种events来进行交流。" class="headerlink" title="3.被fork出来的process也被叫做worker,每个worker能够和master通过各种events来进行交流。"></a>3.被fork出来的process也被叫做worker,每个worker能够和master通过各种events来进行交流。</h3><h3 id="4-再看一下下面这个例子："><a href="#4-再看一下下面这个例子：" class="headerlink" title="4.再看一下下面这个例子："></a>4.再看一下下面这个例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CPUS = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'cpus'</span>, CPUS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'master listening...'</span>);</span><br><span class="line"></span><br><span class="line">    cluster.on(<span class="string">'listening'</span>, (worker, address) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(worker.process.pid, address.address+<span class="string">''</span>+address.port);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cluster.on(<span class="string">'exit'</span>, worker =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(worker.process.pid + <span class="string">'died'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; CPUS; i++) &#123;</span><br><span class="line">        cluster.fork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">200</span>);</span><br><span class="line">        res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">    &#125;).listen(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：对于上面的打印cpus的数量这一行，会打印几遍呢？答案是打印CPUS+1遍，不仅每个创建出来的worker运行了这份脚本，而且主worker也运行了这份脚本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>node事件循环</title>
    <link href="http://yoursite.com/2018/12/12/node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2018/12/12/node事件循环/</id>
    <published>2018-12-12T09:11:18.000Z</published>
    <updated>2018-12-12T09:11:18.568Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数式一</title>
    <link href="http://yoursite.com/2018/12/11/%E5%87%BD%E6%95%B0%E5%BC%8F%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/11/函数式一/</id>
    <published>2018-12-11T07:58:40.000Z</published>
    <updated>2018-12-13T13:52:17.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子："><a href="#1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：" class="headerlink" title="1.纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子："></a>1.纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Flock = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flock.prototype.conjoin = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag += other.seag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Flock.prototype.breed = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seag *= other.seag;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Flock(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Flock(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Flock(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.breed(b) =&gt; 16;  16 + 16;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = a.conjoin(c).breed(b).conjoin(a.breed(b)).seag;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'result'</span>, result);    <span class="comment">// =&gt; 32</span></span><br></pre></td></tr></table></figure><p>上面这个例子输出的结果是32。</p><h3 id="2-区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array-prototype-slice就是一个纯方法，而Array-prototype-splice并不是一个纯方法。"><a href="#2-区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array-prototype-slice就是一个纯方法，而Array-prototype-splice并不是一个纯方法。" class="headerlink" title="2.区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array.prototype.slice就是一个纯方法，而Array.prototype.splice并不是一个纯方法。"></a>2.区别一下原生的js类型中有哪些较为常见的纯方法以及非纯方法，比如说：Array.prototype.slice就是一个纯方法，而Array.prototype.splice并不是一个纯方法。</h3><h3 id="3-一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态："><a href="#3-一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态：" class="headerlink" title="3.一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态："></a>3.一个非纯函数还可能会长这样，尽管不太明显，但是需要清除这个函数依赖了外部的系统状态：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mini = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data &gt;= mini;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pure的应该像下面这样的写法</span></span><br><span class="line"><span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mini = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> data &gt;= mini;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-可以使用Object-freeze来创建一个不可变对象："><a href="#4-可以使用Object-freeze来创建一个不可变对象：" class="headerlink" title="4.可以使用Object.freeze来创建一个不可变对象："></a>4.可以使用Object.freeze来创建一个不可变对象：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = <span class="built_in">Object</span>.freeze(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);  <span class="comment">// 还是为1</span></span><br></pre></td></tr></table></figure><h3 id="5-纯函数的优点一：可缓存性："><a href="#5-纯函数的优点一：可缓存性：" class="headerlink" title="5.纯函数的优点一：可缓存性："></a>5.纯函数的优点一：可缓存性：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** memoize函数能够将计算过的值给缓存起来，节约计算时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">    cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[arg_str];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x &#125;);</span><br><span class="line">square(<span class="number">5</span>);</span><br><span class="line">square(<span class="number">5</span>); <span class="comment">// 从缓存里面取值</span></span><br></pre></td></tr></table></figure><h3 id="6-组合，下面可以看一个函数组合的例子："><a href="#6-组合，下面可以看一个函数组合的例子：" class="headerlink" title="6.组合，下面可以看一个函数组合的例子："></a>6.组合，下面可以看一个函数组合的例子：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x=<span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.toUpperCase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">x=<span class="string">''</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> power = compose(toUpperCase, reverseString);  <span class="comment">// 很直观 从右到左</span></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="string">'hello frp'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：&quot;&gt;&lt;a href=&quot;#1-纯函数：同一个输入，同一个输出，不改变数据。下面看一个槽糕的例子：&quot; class=&quot;headerlink&quot; title=&quot;1.纯函数：同一个输入，同一个输出，不改变数
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>rn基础一</title>
    <link href="http://yoursite.com/2018/12/11/rn%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/11/rn基础一/</id>
    <published>2018-12-11T05:51:46.000Z</published>
    <updated>2018-12-11T05:57:59.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-设置全屏"><a href="#1-设置全屏" class="headerlink" title="1.设置全屏"></a>1.设置全屏</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; View, Dimensions &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;&#123;<span class="attr">width</span>: Dimensions.get(<span class="string">'window'</span>).width, <span class="attr">height</span>: Dimensions.get(<span class="string">'window'</span>).height&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-设置全屏&quot;&gt;&lt;a href=&quot;#1-设置全屏&quot; class=&quot;headerlink&quot; title=&quot;1.设置全屏&quot;&gt;&lt;/a&gt;1.设置全屏&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>react生态基本使用笔记</title>
    <link href="http://yoursite.com/2018/12/07/react%E7%94%9F%E6%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/07/react生态基本使用笔记/</id>
    <published>2018-12-07T03:18:59.000Z</published>
    <updated>2018-12-07T08:33:11.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用react-router的link标签的时候可以这样使用："><a href="#1-使用react-router的link标签的时候可以这样使用：" class="headerlink" title="1.使用react-router的link标签的时候可以这样使用："></a>1.使用react-router的link标签的时候可以这样使用：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123; <span class="attr">pathname</span>: <span class="string">`routeUrl`</span>, <span class="attr">state</span>: stateObj &#125;&#125;&gt;target&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure><p>Link里面所传递的state对象在子页面中可以通过this.props.location.state来进行获取。一个好处，放在location里面的数据不会被刷新掉。</p><h3 id="2-更新过程不会触发componentWillMount以及componentDidMount。"><a href="#2-更新过程不会触发componentWillMount以及componentDidMount。" class="headerlink" title="2.更新过程不会触发componentWillMount以及componentDidMount。"></a>2.更新过程不会触发componentWillMount以及componentDidMount。</h3><h3 id="一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this-props-params-classId来获取班级id。"><a href="#一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this-props-params-classId来获取班级id。" class="headerlink" title="一个route形如下面这样的话：，那么我们可以在CourseClassInfo组件中通过this.props.params.classId来获取班级id。"></a>一个route形如下面这样的话：<route path="course/:courseId/class/:classId" component="{CourseClassInfo}/">，那么我们可以在CourseClassInfo组件中通过this.props.params.classId来获取班级id。</route></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用react-router的link标签的时候可以这样使用：&quot;&gt;&lt;a href=&quot;#1-使用react-router的link标签的时候可以这样使用：&quot; class=&quot;headerlink&quot; title=&quot;1.使用react-router的link标签的时候
      
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>《nodejs 8 the right way》-阅读笔记1</title>
    <link href="http://yoursite.com/2018/12/07/nodejs%20the%20right%20way%20%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/07/nodejs the right way 一/</id>
    <published>2018-12-06T16:49:00.000Z</published>
    <updated>2018-12-13T09:22:09.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用const定义变量，在定义的时候必须赋值。"><a href="#1-使用const定义变量，在定义的时候必须赋值。" class="headerlink" title="1.使用const定义变量，在定义的时候必须赋值。"></a>1.使用const定义变量，在定义的时候必须赋值。</h3><h3 id="2-fs-watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。"><a href="#2-fs-watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。" class="headerlink" title="2.fs.watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。"></a>2.fs.watch可以用来监控文件变化，第一个参数是文件路径，第二个参数是callback。</h3><h3 id="3-事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait-for，或者程序退出（比如一个未被捕获的异常所引起的退出）。"><a href="#3-事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait-for，或者程序退出（比如一个未被捕获的异常所引起的退出）。" class="headerlink" title="3.事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait for，或者程序退出（比如一个未被捕获的异常所引起的退出）。"></a>3.事件循环，node代码一路运行到底，事件循环会一直持续下去，直到已经没有什么需要被wait for，或者程序退出（比如一个未被捕获的异常所引起的退出）。</h3><h3 id="4-process-argv命令行参数列表，第一个是nodefull-path路径，第2个是所执行文件的full-path路径，第三个开始就是自定义参数。"><a href="#4-process-argv命令行参数列表，第一个是nodefull-path路径，第2个是所执行文件的full-path路径，第三个开始就是自定义参数。" class="headerlink" title="4.process.argv命令行参数列表，第一个是nodefull path路径，第2个是所执行文件的full path路径，第三个开始就是自定义参数。"></a>4.process.argv命令行参数列表，第一个是nodefull path路径，第2个是所执行文件的full path路径，第三个开始就是自定义参数。</h3><h3 id="5-child-process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject-pipe-process-stdout"><a href="#5-child-process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject-pipe-process-stdout" class="headerlink" title="5.child_process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject.pipe(process.stdout);"></a>5.child_process模块所暴露出来的spawn方法能够创建一个ChildProcess对象，这个对象具有stdin，stdout，stderr等属性，其中上面所提到的这三个属性是Stream类型的对象，能够被用来读写。比如说streamObject.pipe(process.stdout);</h3><h3 id="6-fs-writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。"><a href="#6-fs-writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。" class="headerlink" title="6.fs.writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。"></a>6.fs.writeFile，如果文件不存在的话则创建它，如果存在的话，并且没有携带其它额外参数的话，那么覆盖原文件。</h3><h3 id="7-事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err-cb。一个未被捕获的异常会导致线程被中断。"><a href="#7-事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err-cb。一个未被捕获的异常会导致线程被中断。" class="headerlink" title="7.事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err cb。一个未被捕获的异常会导致线程被中断。"></a>7.事件发布订阅模式，常见的错误捕获方式有两种，分别是利用on和作为一个err cb。一个未被捕获的异常会导致线程被中断。</h3><h3 id="8-node在很多build-in-模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。"><a href="#8-node在很多build-in-模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。" class="headerlink" title="8.node在很多build-in 模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。"></a>8.node在很多build-in 模块中都既提供了同步方法，也提供了异步方法，众所周知，同步方法会阻塞后续IO的执行，那么问题来了是不是使用异步方法是最佳时实践呢？其实也不尽然，分场合，在node中，程序的运行有两个阶段，分别是初始化阶段和运行阶段，在初始化阶段完成一些诸如引入模块文件，读取配置的工作；在运行阶段，则进入了事件循环里面，你可能会遇到大量的网络请求，因此在运行阶段记住使用异步方法是提高效率的最佳实践。而对于阶段一来说，很典型的require就是一个同步的操作，在第一阶段可以根据相应场合来做一些同步操作。</h3><h3 id="9-fs-watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs-watch监听的文件被删除是ok的，"><a href="#9-fs-watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs-watch监听的文件被删除是ok的，" class="headerlink" title="9.fs.watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs.watch监听的文件被删除是ok的，"></a>9.fs.watch监听一个不存在的文件会报错，不会被callback的错误处理方式给监听到；fs.watch监听的文件被删除是ok的，</h3><h3 id="10-net-createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection-write-方法写数据，可以监听connection-on-‘close’-来监听客户端断开连接。"><a href="#10-net-createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection-write-方法写数据，可以监听connection-on-‘close’-来监听客户端断开连接。" class="headerlink" title="10.net.createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection.write()方法写数据，可以监听connection.on(‘close’)来监听客户端断开连接。"></a>10.net.createServer方法接收一个cb，cb的第一个参数是connection，每当有请求进来的时候都会进入回调函数，要想向客户端写数据的话可以使用connection.write()方法写数据，可以监听connection.on(‘close’)来监听客户端断开连接。</h3><h3 id="11-当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。"><a href="#11-当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。" class="headerlink" title="11.当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。"></a>11.当你使用nodejs进行网络开发时，在两个端点之间传递信息如果处于理想情况下的话，那么可以一次传递成功；但是如果数据量很大的情况下的话，那么数据将会被分成几份进行传输。</h3><h3 id="12-npm-i-–production-表示只安装dependencies而不安装devDependencies。"><a href="#12-npm-i-–production-表示只安装dependencies而不安装devDependencies。" class="headerlink" title="12.npm i –production 表示只安装dependencies而不安装devDependencies。"></a>12.npm i –production 表示只安装dependencies而不安装devDependencies。</h3><h3 id="13-Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理："><a href="#13-Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理：" class="headerlink" title="13.Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理："></a>13.Mocha默认的最大延时时间为2s。运行的时候携带上–timeout后面加上最大延时时间表明最大的延时时间。如果在整个应用的测试实例中有一个测试单元是一个需要延时的操作，并且已经超过了Mocha设置的最大测试时间的话，那么我们可以像下面这样处理：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should finish with 5 seconds'</span>, done =&gt; &#123;</span><br><span class="line">  setTimeout(done, <span class="number">4500</span>);</span><br><span class="line">&#125;).timeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>除了在it后面调用timeout方法之外，其实在describe后面也可以设置一个timeout方法。</p><h3 id="14-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"><a href="#14-nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。" class="headerlink" title="14.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。"></a>14.nodejs是单线程的，尽管如此，但是node运行在机器上还是能够运用上多核机器的性能，也就是说，node尽管被设计成了单线程的，但是还是可以做多进程的事情，实现这个的银弹就是Node内建的模块cluster。在多线程系统中，要想以并行的方式处理更多的任务的话，那么自然是使用多个线程来协同处理了。但是node被设计成一种单线程事件循环模式，所以在node中要想并行的处理多个任务的话，那么就需要使用其它方法了，在node里面，完成这个目的使用的是进程来处理。</h3><h3 id="15-child-process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。"><a href="#15-child-process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。" class="headerlink" title="15.child_process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。"></a>15.child_process模块也是用来产生进程的，但是它spawn所执行的工作是非nodejs类的工作，但是对于处理nodejs类的工作的话，那么利用cluster模块中的fork方法是一种更好的选择。</h3><h3 id="16-直观看来，nodejs中process-nextTick中的cb会比setTimeout-cb-0-更快执行。"><a href="#16-直观看来，nodejs中process-nextTick中的cb会比setTimeout-cb-0-更快执行。" class="headerlink" title="16.直观看来，nodejs中process.nextTick中的cb会比setTimeout(cb, 0)更快执行。"></a>16.直观看来，nodejs中process.nextTick中的cb会比setTimeout(cb, 0)更快执行。</h3><h3 id="17-curl-O-资源链接-可以下载指定链接的资源。"><a href="#17-curl-O-资源链接-可以下载指定链接的资源。" class="headerlink" title="17.curl -O 资源链接 可以下载指定链接的资源。"></a>17.curl -O 资源链接 可以下载指定链接的资源。</h3><h3 id="18-Mocha携带flag-–-watch表明持续监听测试用例文件，如下所示："><a href="#18-Mocha携带flag-–-watch表明持续监听测试用例文件，如下所示：" class="headerlink" title="18.Mocha携带flag – watch表明持续监听测试用例文件，如下所示："></a>18.Mocha携带flag – watch表明持续监听测试用例文件，如下所示：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test:watch"</span>: <span class="string">"mocha --watch --reporter min"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-chmod-x-file；将文件权限修改为可执行。"><a href="#19-chmod-x-file；将文件权限修改为可执行。" class="headerlink" title="19.chmod +x file；将文件权限修改为可执行。"></a>19.chmod +x file；将文件权限修改为可执行。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用const定义变量，在定义的时候必须赋值。&quot;&gt;&lt;a href=&quot;#1-使用const定义变量，在定义的时候必须赋值。&quot; class=&quot;headerlink&quot; title=&quot;1.使用const定义变量，在定义的时候必须赋值。&quot;&gt;&lt;/a&gt;1.使用const定义
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue学习</title>
    <link href="http://yoursite.com/2018/12/01/vue%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/12/01/vue学习/</id>
    <published>2018-12-01T08:19:30.000Z</published>
    <updated>2018-12-01T08:21:54.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-vue-router-this-router-replace-url-进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。"><a href="#1-vue-router-this-router-replace-url-进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。" class="headerlink" title="1.vue-router: this.$router.replace(url)进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。"></a>1.vue-router: this.$router.replace(url)进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-vue-router-this-router-replace-url-进行跳转，并不会把当前URLpush到页面栈中，所以点击返回会返回到上上页面。&quot;&gt;&lt;a href=&quot;#1-vue-router-this-router-replace-url-进行跳转，并不
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用nestjs开发一个博客应用之程序配置</title>
    <link href="http://yoursite.com/2018/11/30/%E7%94%A8nestjs%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8%E4%B9%8B%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/30/用nestjs开发一个博客应用之程序配置/</id>
    <published>2018-11-29T16:52:52.000Z</published>
    <updated>2018-11-30T15:43:03.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi-package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示："><a href="#1-应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi-package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示：" class="headerlink" title="1.应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示："></a>1.应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi package一起使用，因为有的时候我们并不希望某个配置项为空或者不存在，那么便可以利用joi包对配置项目进行建模，以此达到一个更加完善的验证。（需要注意的是，对于每个配置属性，都必须有一个getter方法来取值）。相关用法如下所示：</h3><h3 id="2-1-先安装相关依赖包："><a href="#2-1-先安装相关依赖包：" class="headerlink" title="2-1:先安装相关依赖包："></a>2-1:先安装相关依赖包：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i --save dotenv; <span class="comment">## 键值对处理相关包，我们的配置文件是以键值对的形式出现的</span></span><br><span class="line">npm i --save joi; <span class="comment">## 字段建模验证</span></span><br><span class="line">npm i --save-dev @types/joi;</span><br></pre></td></tr></table></figure><h3 id="2-2-假设有配置问价如下所示："><a href="#2-2-假设有配置问价如下所示：" class="headerlink" title="2-2:假设有配置问价如下所示："></a>2-2:假设有配置问价如下所示：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_NAME = BLOG</span><br><span class="line">DATABASE_USER = YOU_NAME</span><br><span class="line">DATABASE_PASSWORD = YOU_PASSWORD</span><br></pre></td></tr></table></figure><h3 id="2-3-创建这个module的service文件："><a href="#2-3-创建这个module的service文件：" class="headerlink" title="2-3:创建这个module的service文件："></a>2-3:创建这个module的service文件：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.service.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> joi <span class="keyword">from</span> <span class="string">'joi'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个具有任意属性的对象类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> EnvConfig &#123;</span><br><span class="line">  [Key: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ConfigService &#123;</span><br><span class="line">  <span class="keyword">private</span> readonly envConfig: EnvConfig;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">filePath: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> config = dotenv.parse(fs.readFileSync(filePath));           <span class="comment">// 读取配置文件，并利用dotenv进行解析</span></span><br><span class="line">    <span class="keyword">this</span>.envConfig = <span class="keyword">this</span>.validateInput(config);                      <span class="comment">// 验证配置</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> validateInput(envConfig: EnvConfig): EnvConfig &#123;</span><br><span class="line">    <span class="keyword">const</span> envSchema: joi.ObjectSchema = joi.object(&#123;</span><br><span class="line">      DATABASE_NAME: joi.string()</span><br><span class="line">                        .valid([<span class="string">'blog'</span>, <span class="string">'ablog'</span>])</span><br><span class="line">                        .default(<span class="string">'blog'</span>),</span><br><span class="line">      DATABASE_USER: joi.string()</span><br><span class="line">                        .valid([<span class="string">'root'</span>, <span class="string">'visitor'</span>])</span><br><span class="line">                        .default(<span class="string">'root'</span>),</span><br><span class="line">      DATABASE_PASSWORD: joi.number().required()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> &#123; error, value: validateConfig &#125; = joi.validate(envConfig, envSchema);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> validateConfig</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个配置属性都必须设置一个getter方法来获取值</span></span><br><span class="line">  <span class="keyword">get</span> databaseName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.envConfig.DATABASE_NAME;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> databaseUser(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.envConfig.DATABASE_USER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> databasePassword(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.envConfig.DATABASE_PASSWORD;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-创建配置的module文件："><a href="#2-4-创建配置的module文件：" class="headerlink" title="2-4:创建配置的module文件："></a>2-4:创建配置的module文件：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigService &#125; <span class="keyword">from</span> <span class="string">'./config.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  providers: [</span><br><span class="line">    provide: ConfigService,</span><br><span class="line">    useValue: <span class="keyword">new</span> ConfigService(<span class="string">`<span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">  ],</span><br><span class="line">  exports: [ConfigService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ConfigModule &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块："><a href="#2-5-到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块：" class="headerlink" title="2-5:到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块："></a>2-5:到了上面这一步基本就已经完成了一个配置模块的功能编写，接下来介绍一下该怎么使用这个配置模块：</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule &#125; <span class="keyword">from</span> <span class="string">'./config.module'</span>;</span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [ConfigModule]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前模块中引入了config模块之后，便能够进行使用了，如下所示：</span></span><br><span class="line"><span class="comment">// app.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppService &#123;</span><br><span class="line">  <span class="keyword">private</span> dataBaseName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">config: ConfigService</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataBaseName = config.databaseName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-应用程序很多时候的运行条件都跟配置息息相关，而在nest中使用配置进行开发也很方便，他被抽象为一个功能模块，因此可以被导入到其他模块中进行动态注入。在nest中关于配置的最佳实践可以搭配joi-package一起使用，因为有的时候我们并不希望某个配置项为空或者
      
    
    </summary>
    
    
      <category term="nestjs" scheme="http://yoursite.com/tags/nestjs/"/>
    
  </entry>
  
  <entry>
    <title>typescript实践</title>
    <link href="http://yoursite.com/2018/11/27/typescript%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/11/27/typescript实践/</id>
    <published>2018-11-26T18:05:40.000Z</published>
    <updated>2018-11-26T18:08:01.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在typescript中使用Promise-需要先在tsconfig-json文件的”compilerOptions”字段里面增加下面这个值"><a href="#1-在typescript中使用Promise-需要先在tsconfig-json文件的”compilerOptions”字段里面增加下面这个值" class="headerlink" title="1.在typescript中使用Promise?需要先在tsconfig.json文件的”compilerOptions”字段里面增加下面这个值:"></a>1.在typescript中使用Promise?需要先在tsconfig.json文件的”compilerOptions”字段里面增加下面这个值:</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"lib": ["es2015"]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-在typescript中使用Promise-需要先在tsconfig-json文件的”compilerOptions”字段里面增加下面这个值&quot;&gt;&lt;a href=&quot;#1-在typescript中使用Promise-需要先在tsconfig-json文件的”com
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react坑</title>
    <link href="http://yoursite.com/2018/11/26/react%E5%9D%91/"/>
    <id>http://yoursite.com/2018/11/26/react坑/</id>
    <published>2018-11-26T12:58:28.000Z</published>
    <updated>2018-11-26T13:03:00.371Z</updated>
    
    <content type="html"><![CDATA[<p>1.一个语言层面优先级的问题，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exerciseType === <span class="string">'XINGCE'</span> || exerciseType === <span class="string">'SHENLUN'</span> &amp;&amp;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>这些的写法和自己所希望出现的情况应该会出现不符合的情况，正确的情况应该是像下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(exerciseType === <span class="string">'行测'</span> || exerciseType === <span class="string">'SHENLUN'</span>) &amp;&amp;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.一个语言层面优先级的问题，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongodb学习</title>
    <link href="http://yoursite.com/2018/11/22/mongodb%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/22/mongodb学习/</id>
    <published>2018-11-22T14:53:01.000Z</published>
    <updated>2018-11-24T02:04:23.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-mongo命令行基本用法-首先得使用mongod命令启动MongoDB数据库服务-才能运行mongo命令"><a href="#1-mongo命令行基本用法-首先得使用mongod命令启动MongoDB数据库服务-才能运行mongo命令" class="headerlink" title="1.mongo命令行基本用法(首先得使用mongod命令启动MongoDB数据库服务,才能运行mongo命令)"></a>1.mongo命令行基本用法(首先得使用mongod命令启动MongoDB数据库服务,才能运行mongo命令)</h3><ul><li><p>1.创建新的数据库：use dbName，存在该数据库的话那么便连接到该数据库，不存在数据库的话那么便创建数据库。需要注意的时，利用他创建数据库，数据库并不会立马展示出来，需要先往里面插入一些数据才行。</p></li><li><p>2.查看所有数据库：show dbs。</p></li><li><p>3.往数据库里面插入内容：db.databaseName.insert(Obj)，便可以插入一些数据。</p></li></ul><h3 id="2-mongodb搭配nestjs进行使用"><a href="#2-mongodb搭配nestjs进行使用" class="headerlink" title="2.mongodb搭配nestjs进行使用"></a>2.mongodb搭配nestjs进行使用</h3><ul><li><p>1.首先安装依赖包@nestjs/mongoose package以及mongoose package。</p></li><li><p>2.在应用的根模块里面import由@nestjs/mongoose package导出的MongooseModule模块，并且配置连接数据库的信息（使用MongooseModule的forRoot方法，该方法所接受的第一个参数是数据库的地址：形如mongodb://localhost/nest。</p></li><li><p>3.在每个功能模块里面（需要和数据库进行交互）导入功能Schema建模文件，依然需要导入MongooseModule模块，功能模块的service肯定是需要用上该功能的数据库对象的，那么他怎么使用呢？答案就是功能模块import MongooseModule.forFeature()，MongooseModule.forFeature方法接收一个数组作为参数，数组里面的每一项形如{name: ‘’, schema: SchemaModel }，利用nestjs的依赖注入功能，我们便可以在功能模块的service文件中@InjectModel(name)使用这个数据库对象了。使用MongooseModule.forFeature方法，我们往该模块里面注册model，在service文件里面我们使用@nestjs/common导出的@Injectable装饰器修饰service类，来表明这个类是可以被动态插入的，接着便可以使用@InjectModel(name)来引入model了：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MongooseModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserSchema &#125; <span class="keyword">from</span> <span class="string">'./user.schema'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService &#125; <span class="keyword">from</span> <span class="string">'./user.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserController &#125; <span class="keyword">from</span> <span class="string">'./user.controller'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">    imports: [MongooseModule.forFeature([&#123;name: <span class="string">'User'</span>, schema: UserSchema&#125;])],</span><br><span class="line">    controllers: [UserController],</span><br><span class="line">    providers: [UserService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserModule &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; InjectModel &#125; <span class="keyword">from</span> <span class="string">'@nestjs/mongoose'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Model &#125; <span class="keyword">from</span> <span class="string">'mongoose'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-mongo命令行基本用法-首先得使用mongod命令启动MongoDB数据库服务-才能运行mongo命令&quot;&gt;&lt;a href=&quot;#1-mongo命令行基本用法-首先得使用mongod命令启动MongoDB数据库服务-才能运行mongo命令&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>工作bug总结</title>
    <link href="http://yoursite.com/2018/11/21/%E5%B7%A5%E4%BD%9Cbug%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/11/21/工作bug总结/</id>
    <published>2018-11-21T03:06:23.000Z</published>
    <updated>2018-12-03T09:34:34.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-关于vue中v-html遇到null-a的问题，很不幸，浏览器控制台并不会报错，并且会莫名其妙的阻塞渲染。在拿到后端传过来的数据最好做一个检查，有效就使用，无效的话就使用默认值吧。"><a href="#1-关于vue中v-html遇到null-a的问题，很不幸，浏览器控制台并不会报错，并且会莫名其妙的阻塞渲染。在拿到后端传过来的数据最好做一个检查，有效就使用，无效的话就使用默认值吧。" class="headerlink" title="1.关于vue中v-html遇到null.a的问题，很不幸，浏览器控制台并不会报错，并且会莫名其妙的阻塞渲染。在拿到后端传过来的数据最好做一个检查，有效就使用，无效的话就使用默认值吧。"></a>1.关于vue中v-html遇到null.a的问题，很不幸，浏览器控制台并不会报错，并且会莫名其妙的阻塞渲染。在拿到后端传过来的数据最好做一个检查，有效就使用，无效的话就使用默认值吧。</h3><h3 id="2-微信分享接口将不再具有success回调以及fail回调。"><a href="#2-微信分享接口将不再具有success回调以及fail回调。" class="headerlink" title="2.微信分享接口将不再具有success回调以及fail回调。"></a>2.微信分享接口将不再具有success回调以及fail回调。</h3><h3 id="3-app里面的globalData和page里的data所建立的关系并不是响应式绑定。"><a href="#3-app里面的globalData和page里的data所建立的关系并不是响应式绑定。" class="headerlink" title="3.app里面的globalData和page里的data所建立的关系并不是响应式绑定。"></a>3.app里面的globalData和page里的data所建立的关系并不是响应式绑定。</h3><h3 id="4-微信页面栈的问题，最多同时存在五个页面在栈中，正常情况下，navigateTo是不断将新页面入栈的，redirectTo没有变化，出一个进来一个，navigateBack是出栈的；要解决这个问题就不要设计过于复杂的页面依赖跳转关系。"><a href="#4-微信页面栈的问题，最多同时存在五个页面在栈中，正常情况下，navigateTo是不断将新页面入栈的，redirectTo没有变化，出一个进来一个，navigateBack是出栈的；要解决这个问题就不要设计过于复杂的页面依赖跳转关系。" class="headerlink" title="4.微信页面栈的问题，最多同时存在五个页面在栈中，正常情况下，navigateTo是不断将新页面入栈的，redirectTo没有变化，出一个进来一个，navigateBack是出栈的；要解决这个问题就不要设计过于复杂的页面依赖跳转关系。"></a>4.微信页面栈的问题，最多同时存在五个页面在栈中，正常情况下，navigateTo是不断将新页面入栈的，redirectTo没有变化，出一个进来一个，navigateBack是出栈的；要解决这个问题就不要设计过于复杂的页面依赖跳转关系。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-关于vue中v-html遇到null-a的问题，很不幸，浏览器控制台并不会报错，并且会莫名其妙的阻塞渲染。在拿到后端传过来的数据最好做一个检查，有效就使用，无效的话就使用默认值吧。&quot;&gt;&lt;a href=&quot;#1-关于vue中v-html遇到null-a的问题，很不
      
    
    </summary>
    
    
      <category term="work" scheme="http://yoursite.com/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>js注意点</title>
    <link href="http://yoursite.com/2018/11/18/js%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2018/11/18/js注意点/</id>
    <published>2018-11-18T03:28:02.000Z</published>
    <updated>2018-11-27T14:38:43.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-pure-Array-prototype-push-不是一个纯方法；Array-prototype-filter是一个纯方法；String-prototype-replace是一个纯方法。String-prototype-substring-是一个纯方法。"><a href="#1-pure-Array-prototype-push-不是一个纯方法；Array-prototype-filter是一个纯方法；String-prototype-replace是一个纯方法。String-prototype-substring-是一个纯方法。" class="headerlink" title="1.pure: Array.prototype.push()不是一个纯方法；Array.prototype.filter是一个纯方法；String.prototype.replace是一个纯方法。String.prototype.substring()是一个纯方法。"></a>1.pure: Array.prototype.push()不是一个纯方法；Array.prototype.filter是一个纯方法；String.prototype.replace是一个纯方法。String.prototype.substring()是一个纯方法。</h3><h3 id="2-获取数组最大值"><a href="#2-获取数组最大值" class="headerlink" title="2.获取数组最大值"></a>2.获取数组最大值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-pure-Array-prototype-push-不是一个纯方法；Array-prototype-filter是一个纯方法；String-prototype-replace是一个纯方法。String-prototype-substring-是一个纯方法。&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nest学习</title>
    <link href="http://yoursite.com/2018/11/14/nest%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/14/nest学习/</id>
    <published>2018-11-14T03:52:42.000Z</published>
    <updated>2018-11-14T09:26:04.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Controllers的功能：handling-incoming-requests，returning-response-to-the-client。"><a href="#1-Controllers的功能：handling-incoming-requests，returning-response-to-the-client。" class="headerlink" title="1.Controllers的功能：handling incoming requests，returning response to the client。"></a>1.Controllers的功能：handling incoming requests，returning response to the client。</h3><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Controllers的功能：handling-incoming-requests，returning-response-to-the-client。&quot;&gt;&lt;a href=&quot;#1-Controllers的功能：handling-incoming-requests
      
    
    </summary>
    
    
      <category term="nest" scheme="http://yoursite.com/tags/nest/"/>
    
  </entry>
  
  <entry>
    <title>css知识点</title>
    <link href="http://yoursite.com/2018/11/04/css%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/11/04/css知识点/</id>
    <published>2018-11-04T04:09:42.000Z</published>
    <updated>2018-11-19T05:43:03.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-一个内联元素若是使用了flex布局的话，那么其width以及height都是可以设置的了。"><a href="#1-一个内联元素若是使用了flex布局的话，那么其width以及height都是可以设置的了。" class="headerlink" title="1.一个内联元素若是使用了flex布局的话，那么其width以及height都是可以设置的了。"></a>1.一个内联元素若是使用了flex布局的话，那么其width以及height都是可以设置的了。</h3><h3 id="2-css单位："><a href="#2-css单位：" class="headerlink" title="2.css单位："></a>2.css单位：</h3><ul><li>1.相对长度单位：1).相对字体长度单位，比如em,ex(字符x的高度)以及css3出现的rem,ch(字符0的宽度)。</li><li>2.相对视区单位：vw, vh, vmin, vmax，其中vmin代表的是视窗宽度和视窗高度较小值的百分比。vmax代表的是两者之间较大值的百分比。</li><li>3.绝对长度单位。</li></ul><h3 id="3-选择器备忘："><a href="#3-选择器备忘：" class="headerlink" title="3.选择器备忘："></a>3.选择器备忘：</h3><ul><li><p>1.属性选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[title="css"]</span>&#123;&#125;</span><br><span class="line"><span class="selector-attr">[title~="css"]</span>&#123;&#125;:包含<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-attr">[title^="css"]</span>&#123;&#125;:以<span class="selector-tag">css</span>开头</span><br><span class="line"><span class="selector-attr">[title$="css"]</span>&#123;&#125;:以<span class="selector-tag">css</span>结尾</span><br></pre></td></tr></table></figure></li><li><p>2.伪类选择器：一个英文冒号；</p></li><li>3.伪元素选择器：两个连续的英文冒号；</li><li>4.兄弟选择器：~连接；</li><li>5.相邻兄弟选择器：+连接；</li></ul><h3 id="4-关于浮动："><a href="#4-关于浮动：" class="headerlink" title="4.关于浮动："></a>4.关于浮动：</h3><p>浮动会使得自身元素脱离文档流，比如下面这种情况：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"out clear"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"f"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.out</span> &#123;</span></span><br><span class="line"><span class="undefined">    width: 500px;</span></span><br><span class="line"><span class="undefined">    background-color: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.f</span> &#123;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    background-color: green;</span></span><br><span class="line"><span class="undefined">    float: right;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面这种情况来说，由于子元素.f设置了浮动，而浮动会使得脱离文档流，因此.out并不会被子元素给撑开，这就造成.out根本就看不到的情况。那么怎么解决这种情况呢？可以利用清除浮动来解决这个问题，如下所示，只需要添加下面的这些css即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的地方是：如果一个元素是flex的话，那么他的子元素就是默认清楚了浮动的，对于上面这种情况，像下面这样设置也能够将out撑开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-块级元素：需要注意的是块级元素和display为block的元素并不是一个级别，例如常见的块元素有div-list-table其中list的display值为list-item，而table的display值为table。"><a href="#5-块级元素：需要注意的是块级元素和display为block的元素并不是一个级别，例如常见的块元素有div-list-table其中list的display值为list-item，而table的display值为table。" class="headerlink" title="5.块级元素：需要注意的是块级元素和display为block的元素并不是一个级别，例如常见的块元素有div,list,table其中list的display值为list-item，而table的display值为table。"></a>5.块级元素：需要注意的是块级元素和display为block的元素并不是一个级别，例如常见的块元素有div,list,table其中list的display值为list-item，而table的display值为table。</h3><h3 id="6-盒子：每个元素都拥有两个盒子，外在盒子和容器盒子，其中外在盒子决定了是可以一行显示还是需要换行显示；容器盒子负责宽高和内容呈现。照这个概念，起始display-block可以理解为display-block-block；而display-inline可以理解为display-inline-inline；display-inline-block可以理解为display-inline-block；display也可以理解为display-block-table；那么问题来了，width以及height是作用在哪个盒子上面的呢？答案是容器盒子。"><a href="#6-盒子：每个元素都拥有两个盒子，外在盒子和容器盒子，其中外在盒子决定了是可以一行显示还是需要换行显示；容器盒子负责宽高和内容呈现。照这个概念，起始display-block可以理解为display-block-block；而display-inline可以理解为display-inline-inline；display-inline-block可以理解为display-inline-block；display也可以理解为display-block-table；那么问题来了，width以及height是作用在哪个盒子上面的呢？答案是容器盒子。" class="headerlink" title="6.盒子：每个元素都拥有两个盒子，外在盒子和容器盒子，其中外在盒子决定了是可以一行显示还是需要换行显示；容器盒子负责宽高和内容呈现。照这个概念，起始display: block可以理解为display: block-block；而display: inline可以理解为display: inline inline；display: inline-block可以理解为display: inline block；display也可以理解为display: block table；那么问题来了，width以及height是作用在哪个盒子上面的呢？答案是容器盒子。"></a>6.盒子：每个元素都拥有两个盒子，外在盒子和容器盒子，其中外在盒子决定了是可以一行显示还是需要换行显示；容器盒子负责宽高和内容呈现。照这个概念，起始display: block可以理解为display: block-block；而display: inline可以理解为display: inline inline；display: inline-block可以理解为display: inline block；display也可以理解为display: block table；那么问题来了，width以及height是作用在哪个盒子上面的呢？答案是容器盒子。</h3><h3 id="7-关于width-auto所需要注意的地方，width-auto，它具有四种不同的宽度表现，分别如下所示：1-充分利用可用空间，比如说div元素以及p元素都是默认100-于父级容器的；2-收缩到合适（shrink-to-fit），典型代表就是浮动，绝对定位以及inline-block以及table元素。3-收缩到最小，经常出现在table布局为auto的表格中，比如说下面这种情况："><a href="#7-关于width-auto所需要注意的地方，width-auto，它具有四种不同的宽度表现，分别如下所示：1-充分利用可用空间，比如说div元素以及p元素都是默认100-于父级容器的；2-收缩到合适（shrink-to-fit），典型代表就是浮动，绝对定位以及inline-block以及table元素。3-收缩到最小，经常出现在table布局为auto的表格中，比如说下面这种情况：" class="headerlink" title="7.关于width:auto所需要注意的地方，width:auto，它具有四种不同的宽度表现，分别如下所示：1.充分利用可用空间，比如说div元素以及p元素都是默认100%于父级容器的；2.收缩到合适（shrink-to-fit），典型代表就是浮动，绝对定位以及inline-block以及table元素。3.收缩到最小，经常出现在table布局为auto的表格中，比如说下面这种情况："></a>7.关于width:auto所需要注意的地方，width:auto，它具有四种不同的宽度表现，分别如下所示：1.充分利用可用空间，比如说div元素以及p元素都是默认100%于父级容器的；2.收缩到合适（shrink-to-fit），典型代表就是浮动，绝对定位以及inline-block以及table元素。3.收缩到最小，经常出现在table布局为auto的表格中，比如说下面这种情况：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>ttttttttttttttttttttttttttttt<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>重中之重重中之重重中之重重中之重重中之重<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>ttttttttttttttttttttttttttttt<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  table &#123;</span></span><br><span class="line"><span class="undefined">    width: 100px; // 只设置宽度并且是一个很小的值，高度让子元素负责撑开</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  td &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于上面这种情况来说，出现的结果就是：中间的td的宽度是最小的，为什么呢，因为table设置了一个特别小的宽度，而td的width没有进行设置，所以就是默认值auto，对于td的width为auto来说，它所带来的效果就是缩小到最小，并且由于英文是单词换行而不是字母换行，而中文是每个字换行，所以最终导致了中间的这个td是最下的，两边的td并不会出现换行的情况（因为没有空格分割单词，所以都被认为是字母）。还有一点需要注意的那就是：尽管table设置了一个宽度为100px，但是他的实际宽度并不是100px.</p><p>4.width的值被设置成了auto还有一个结果那就是超出容器限制，一般情况下width:auto都不会超过父级容器宽度的，但是下面这种情况则可能发生：内容很长的连续英文和数字，或者内联元素被设置了white-space: nowrap。这种情况下则会出现子元素会超出父元素的宽度限制：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"out"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"overflow"</span>&gt;</span>中文测试，由于设置了white-space的值为wrap所以不会出现换行的情况<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.out</span> &#123;</span></span><br><span class="line"><span class="undefined">    width: 80px;</span></span><br><span class="line"><span class="undefined">    border: 1px solid red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.overflow</span> &#123;</span></span><br><span class="line"><span class="undefined">    white-space: nowrap;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-块级元素的正常流特性，块级元素与html文档就好比水流和容器一样，将水倒入容器里面，那么水会占满整个容器的宽度。块级元素也一样，当没有明确声明他的width值的时候，那么他的width值就是默认的auto，其表现就是父容器的100-了。所以像下面这样的用法是错误的："><a href="#8-块级元素的正常流特性，块级元素与html文档就好比水流和容器一样，将水倒入容器里面，那么水会占满整个容器的宽度。块级元素也一样，当没有明确声明他的width值的时候，那么他的width值就是默认的auto，其表现就是父容器的100-了。所以像下面这样的用法是错误的：" class="headerlink" title="8.块级元素的正常流特性，块级元素与html文档就好比水流和容器一样，将水倒入容器里面，那么水会占满整个容器的宽度。块级元素也一样，当没有明确声明他的width值的时候，那么他的width值就是默认的auto，其表现就是父容器的100%了。所以像下面这样的用法是错误的："></a>8.块级元素的正常流特性，块级元素与html文档就好比水流和容器一样，将水倒入容器里面，那么水会占满整个容器的宽度。块级元素也一样，当没有明确声明他的width值的时候，那么他的width值就是默认的auto，其表现就是父容器的100%了。所以像下面这样的用法是错误的：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  width: 100%; // 块级元素会自动铺满其父容器的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然block会自动占满整个容器的宽度，那么当我们给一个元素显式设置100%的话又会发生什么呢？答案就是有可能会超出容器空间。</p><h3 id="9-绝对定位模型（position值为absolute和fixed）情况下，如果没有设置宽度以及高度的话，那么盒子默认是以“包裹性”的一个形式出现的，也就是说宽度取决于内部尺寸。但是有一种情况除外，那就是非替换元素如果设置了left-right或者top-bottom的话，那么就会此时盒子的宽度就是由外部尺寸来决定了，取决于最近的具有定位属性的祖先元素的宽度来进行计算。"><a href="#9-绝对定位模型（position值为absolute和fixed）情况下，如果没有设置宽度以及高度的话，那么盒子默认是以“包裹性”的一个形式出现的，也就是说宽度取决于内部尺寸。但是有一种情况除外，那就是非替换元素如果设置了left-right或者top-bottom的话，那么就会此时盒子的宽度就是由外部尺寸来决定了，取决于最近的具有定位属性的祖先元素的宽度来进行计算。" class="headerlink" title="9.绝对定位模型（position值为absolute和fixed）情况下，如果没有设置宽度以及高度的话，那么盒子默认是以“包裹性”的一个形式出现的，也就是说宽度取决于内部尺寸。但是有一种情况除外，那就是非替换元素如果设置了left,right或者top,bottom的话，那么就会此时盒子的宽度就是由外部尺寸来决定了，取决于最近的具有定位属性的祖先元素的宽度来进行计算。"></a>9.绝对定位模型（position值为absolute和fixed）情况下，如果没有设置宽度以及高度的话，那么盒子默认是以“包裹性”的一个形式出现的，也就是说宽度取决于内部尺寸。但是有一种情况除外，那就是非替换元素如果设置了left,right或者top,bottom的话，那么就会此时盒子的宽度就是由外部尺寸来决定了，取决于最近的具有定位属性的祖先元素的宽度来进行计算。</h3><h3 id="10-包裹性：如果一个元素的display属性值为inline-block的话或者是浮动元素以及绝对定位元素的话，那么即使里面内容再多，只要是正常文本，那么其宽度也不会超过容器。按钮的默认最大宽度是240px，按钮属于典型的inline-block元素，因此如果按钮内具有很多文字的话，那么默认行为下，文字是不会溢出盒子的，文字会自动换行。包裹性在某些场合下特别有用："><a href="#10-包裹性：如果一个元素的display属性值为inline-block的话或者是浮动元素以及绝对定位元素的话，那么即使里面内容再多，只要是正常文本，那么其宽度也不会超过容器。按钮的默认最大宽度是240px，按钮属于典型的inline-block元素，因此如果按钮内具有很多文字的话，那么默认行为下，文字是不会溢出盒子的，文字会自动换行。包裹性在某些场合下特别有用：" class="headerlink" title="10.包裹性：如果一个元素的display属性值为inline-block的话或者是浮动元素以及绝对定位元素的话，那么即使里面内容再多，只要是正常文本，那么其宽度也不会超过容器。按钮的默认最大宽度是240px，按钮属于典型的inline-block元素，因此如果按钮内具有很多文字的话，那么默认行为下，文字是不会溢出盒子的，文字会自动换行。包裹性在某些场合下特别有用："></a>10.包裹性：如果一个元素的display属性值为inline-block的话或者是浮动元素以及绝对定位元素的话，那么即使里面内容再多，只要是正常文本，那么其宽度也不会超过容器。按钮的默认最大宽度是240px，按钮属于典型的inline-block元素，因此如果按钮内具有很多文字的话，那么默认行为下，文字是不会溢出盒子的，文字会自动换行。包裹性在某些场合下特别有用：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"out"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>some txt<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.out</span> &#123;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">    padding: 10px;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="undefined">    display: inline-block;</span></span><br><span class="line"><span class="undefined">    text-align: left;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>像上面这样的样式设置所产生的效果就是：当some txt很少的时候，文本在out容器中所呈现的效果是居中的；当some txt文本很多的时候，文本在out容器中所呈现的效果是左对齐的。</p><h3 id="11-内部容器尺寸除了包裹性这一表现外，还存在着其他两种表现行为，分别是：首选最小宽度，需要注意的是，首选最小宽度并不是0，在css世界中，文字以及图片的权重一定会大于布局，因此在width-auto的时候，宽度是不会变成0的，而是首选最小宽度。"><a href="#11-内部容器尺寸除了包裹性这一表现外，还存在着其他两种表现行为，分别是：首选最小宽度，需要注意的是，首选最小宽度并不是0，在css世界中，文字以及图片的权重一定会大于布局，因此在width-auto的时候，宽度是不会变成0的，而是首选最小宽度。" class="headerlink" title="11.内部容器尺寸除了包裹性这一表现外，还存在着其他两种表现行为，分别是：首选最小宽度，需要注意的是，首选最小宽度并不是0，在css世界中，文字以及图片的权重一定会大于布局，因此在width:auto的时候，宽度是不会变成0的，而是首选最小宽度。"></a>11.内部容器尺寸除了包裹性这一表现外，还存在着其他两种表现行为，分别是：首选最小宽度，需要注意的是，首选最小宽度并不是0，在css世界中，文字以及图片的权重一定会大于布局，因此在width:auto的时候，宽度是不会变成0的，而是首选最小宽度。</h3><h3 id="12-input以及textarea元素属于替换元素，替换元素的特性之一就是他的尺寸由内部元素决定（width被设置为auto的情况下），不管是block还是inline的。"><a href="#12-input以及textarea元素属于替换元素，替换元素的特性之一就是他的尺寸由内部元素决定（width被设置为auto的情况下），不管是block还是inline的。" class="headerlink" title="12.input以及textarea元素属于替换元素，替换元素的特性之一就是他的尺寸由内部元素决定（width被设置为auto的情况下），不管是block还是inline的。"></a>12.input以及textarea元素属于替换元素，替换元素的特性之一就是他的尺寸由内部元素决定（width被设置为auto的情况下），不管是block还是inline的。</h3><h3 id="13-height和width有一个明显的区别就是对于百分比单位的支持，对于width属性，就算父元素width的值为auto，其百分比也是支持的；但是对于height属性来说，如果父元素height的值为auto的话，只要子元素还在文档流中，其百分比值就完全被忽略了。"><a href="#13-height和width有一个明显的区别就是对于百分比单位的支持，对于width属性，就算父元素width的值为auto，其百分比也是支持的；但是对于height属性来说，如果父元素height的值为auto的话，只要子元素还在文档流中，其百分比值就完全被忽略了。" class="headerlink" title="13.height和width有一个明显的区别就是对于百分比单位的支持，对于width属性，就算父元素width的值为auto，其百分比也是支持的；但是对于height属性来说，如果父元素height的值为auto的话，只要子元素还在文档流中，其百分比值就完全被忽略了。"></a>13.height和width有一个明显的区别就是对于百分比单位的支持，对于width属性，就算父元素width的值为auto，其百分比也是支持的；但是对于height属性来说，如果父元素height的值为auto的话，只要子元素还在文档流中，其百分比值就完全被忽略了。</h3><h3 id="14-绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，绝对定位元素的百分比是根据父元素的padding-box的，而非绝对定位元素的百分比是根据父元素的content-box的。"><a href="#14-绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，绝对定位元素的百分比是根据父元素的padding-box的，而非绝对定位元素的百分比是根据父元素的content-box的。" class="headerlink" title="14.绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，绝对定位元素的百分比是根据父元素的padding-box的，而非绝对定位元素的百分比是根据父元素的content-box的。"></a>14.绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，绝对定位元素的百分比是根据父元素的padding-box的，而非绝对定位元素的百分比是根据父元素的content-box的。</h3><h3 id="15-绝对定位的元素width-auto不具有正常流的特性，具备的是包裹性。"><a href="#15-绝对定位的元素width-auto不具有正常流的特性，具备的是包裹性。" class="headerlink" title="15.绝对定位的元素width:auto不具有正常流的特性，具备的是包裹性。"></a>15.绝对定位的元素width:auto不具有正常流的特性，具备的是包裹性。</h3><h3 id="16-使用-img-max-width-100-height-auto-能够让图片有一个比较响应式效果，但是这样做也会产生另外一个后果，那就是在图片加载时到图片加载成功会有一个高度从0变成计算高度的过程，图文会有明显的瀑布式下落。"><a href="#16-使用-img-max-width-100-height-auto-能够让图片有一个比较响应式效果，但是这样做也会产生另外一个后果，那就是在图片加载时到图片加载成功会有一个高度从0变成计算高度的过程，图文会有明显的瀑布式下落。" class="headerlink" title="16.使用.img {max-width: 100%; height: auto;}能够让图片有一个比较响应式效果，但是这样做也会产生另外一个后果，那就是在图片加载时到图片加载成功会有一个高度从0变成计算高度的过程，图文会有明显的瀑布式下落。"></a>16.使用.img {max-width: 100%; height: auto;}能够让图片有一个比较响应式效果，但是这样做也会产生另外一个后果，那就是在图片加载时到图片加载成功会有一个高度从0变成计算高度的过程，图文会有明显的瀑布式下落。</h3><h3 id="17-max-width会超越-important的width。"><a href="#17-max-width会超越-important的width。" class="headerlink" title="17.max-width会超越!important的width。"></a>17.max-width会超越!important的width。</h3><h3 id="18-js获取页面加载成功，js操控css；"><a href="#18-js获取页面加载成功，js操控css；" class="headerlink" title="18.js获取页面加载成功，js操控css；"></a>18.js获取页面加载成功，js操控css；</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'someId'</span>);</span><br><span class="line">  box.style.display = <span class="string">'none'</span>; <span class="comment">// 需要注意的是，transition对display属性不会有动画效果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-任意高度的展开收起动画效果制作：1-使用display来控制，缺陷没有动画效果；2-使用height来完成，但是由于是不定高的，所以不好确定扩展之后的高度；3-使用max-height来完成，如下所示："><a href="#19-任意高度的展开收起动画效果制作：1-使用display来控制，缺陷没有动画效果；2-使用height来完成，但是由于是不定高的，所以不好确定扩展之后的高度；3-使用max-height来完成，如下所示：" class="headerlink" title="19.任意高度的展开收起动画效果制作：1.使用display来控制，缺陷没有动画效果；2.使用height来完成，但是由于是不定高的，所以不好确定扩展之后的高度；3.使用max-height来完成，如下所示："></a>19.任意高度的展开收起动画效果制作：1.使用display来控制，缺陷没有动画效果；2.使用height来完成，但是由于是不定高的，所以不好确定扩展之后的高度；3.使用max-height来完成，如下所示：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ele</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">transition</span>: max-height .<span class="number">55s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ele</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  max-height: 666px; // 设置一个合适的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-内联元素的定义：内联特指元素的外在盒子是和display-inline不是同一个概念。inline-block和inline-table都是内联元素，button是inline-block，img是inline-inline的，所以他们都是默认内联元素。几个概念：1-内容盒子-content-area-，由字符内容所限定的一个盒子，对于img来说，内容盒子就是img本身；2-内联盒子-inline-box-，行内显示，元素的外在盒子；3-行框盒子-line-box-，每一行就是一个行框盒子，行框盒子又由一个个内联盒子组成；4-包含块-containing-box-，包含块有一个一个的行框盒子组成。"><a href="#20-内联元素的定义：内联特指元素的外在盒子是和display-inline不是同一个概念。inline-block和inline-table都是内联元素，button是inline-block，img是inline-inline的，所以他们都是默认内联元素。几个概念：1-内容盒子-content-area-，由字符内容所限定的一个盒子，对于img来说，内容盒子就是img本身；2-内联盒子-inline-box-，行内显示，元素的外在盒子；3-行框盒子-line-box-，每一行就是一个行框盒子，行框盒子又由一个个内联盒子组成；4-包含块-containing-box-，包含块有一个一个的行框盒子组成。" class="headerlink" title="20.内联元素的定义：内联特指元素的外在盒子是和display:inline不是同一个概念。inline-block和inline-table都是内联元素，button是inline-block，img是inline-inline的，所以他们都是默认内联元素。几个概念：1.内容盒子(content area)，由字符内容所限定的一个盒子，对于img来说，内容盒子就是img本身；2.内联盒子(inline box)，行内显示，元素的外在盒子；3.行框盒子(line box)，每一行就是一个行框盒子，行框盒子又由一个个内联盒子组成；4.包含块(containing box)，包含块有一个一个的行框盒子组成。"></a>20.内联元素的定义：内联特指元素的外在盒子是和display:inline不是同一个概念。inline-block和inline-table都是内联元素，button是inline-block，img是inline-inline的，所以他们都是默认内联元素。几个概念：1.内容盒子(content area)，由字符内容所限定的一个盒子，对于img来说，内容盒子就是img本身；2.内联盒子(inline box)，行内显示，元素的外在盒子；3.行框盒子(line box)，每一行就是一个行框盒子，行框盒子又由一个个内联盒子组成；4.包含块(containing box)，包含块有一个一个的行框盒子组成。</h3><h3 id="21-幽灵空白节点，看下面这样的html结构以及样式设置："><a href="#21-幽灵空白节点，看下面这样的html结构以及样式设置：" class="headerlink" title="21.幽灵空白节点，看下面这样的html结构以及样式设置："></a>21.幽灵空白节点，看下面这样的html结构以及样式设置：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#233</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  span &#123;</span></span><br><span class="line"><span class="undefined">    display: inline-block;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这样写将会产生一个具有高度,width为100%的盒子。很奇怪吧，明明没有内容，height应该是0的。</p><h3 id="21-下划线效果"><a href="#21-下划线效果" class="headerlink" title="21.下划线效果"></a>21.下划线效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.un</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-替换元素：我们可以根据外在盒子是内联的还是块级的将盒子分为内联盒子和块级盒子，那什么是替换元素呢？替换元素就是那些通过修改元素标签的某个属性值，所呈现的内容就可以被替换的元素。因此img元素是（修改src属性便可以改变内容表现），video元素也是（修改src属性便可以改变内容表现），input元素也是（修改type属性也可以改变其内容表现），textarea元素也是（修改rows属性也可以改变内容表现），select元素也是（设置multiple属性便可以设置多选）。"><a href="#22-替换元素：我们可以根据外在盒子是内联的还是块级的将盒子分为内联盒子和块级盒子，那什么是替换元素呢？替换元素就是那些通过修改元素标签的某个属性值，所呈现的内容就可以被替换的元素。因此img元素是（修改src属性便可以改变内容表现），video元素也是（修改src属性便可以改变内容表现），input元素也是（修改type属性也可以改变其内容表现），textarea元素也是（修改rows属性也可以改变内容表现），select元素也是（设置multiple属性便可以设置多选）。" class="headerlink" title="22.替换元素：我们可以根据外在盒子是内联的还是块级的将盒子分为内联盒子和块级盒子，那什么是替换元素呢？替换元素就是那些通过修改元素标签的某个属性值，所呈现的内容就可以被替换的元素。因此img元素是（修改src属性便可以改变内容表现），video元素也是（修改src属性便可以改变内容表现），input元素也是（修改type属性也可以改变其内容表现），textarea元素也是（修改rows属性也可以改变内容表现），select元素也是（设置multiple属性便可以设置多选）。"></a>22.替换元素：我们可以根据外在盒子是内联的还是块级的将盒子分为内联盒子和块级盒子，那什么是替换元素呢？替换元素就是那些通过修改元素标签的某个属性值，所呈现的内容就可以被替换的元素。因此img元素是（修改src属性便可以改变内容表现），video元素也是（修改src属性便可以改变内容表现），input元素也是（修改type属性也可以改变其内容表现），textarea元素也是（修改rows属性也可以改变内容表现），select元素也是（设置multiple属性便可以设置多选）。</h3><ul><li>1.替换元素的典型行为之有自己的尺寸。大部分替换元素在没有明确尺寸设定的情况下，其默认尺寸为300px✖️150px，比如video元素和canvas元素，但是也有例外，比如img在明确尺寸设定的情况下，width一般都是为0，高度值在不同的浏览器下表现是不同的。所有的替换元素其外在盒子都是inline的，也就是说都是内联元素，但是内在盒子是啥在各个浏览器可能就有差异了，可以确定的是img和video在三大浏览器都是inlne的；button和select都是inline-block的；重点是经常使用到的input，在Firefox中是inline的，在ie和Chrome中是inline-block的。</li></ul><h3 id="22-一些有用的img标签应用："><a href="#22-一些有用的img标签应用：" class="headerlink" title="22.一些有用的img标签应用："></a>22.一些有用的img标签应用：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 图片被hover的时候显示另外一张图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"laugh.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">content</span>: <span class="selector-tag">url</span>(<span class="selector-tag">laugh-tear</span><span class="selector-class">.png</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-一个内联元素若是使用了flex布局的话，那么其width以及height都是可以设置的了。&quot;&gt;&lt;a href=&quot;#1-一个内联元素若是使用了flex布局的话，那么其width以及height都是可以设置的了。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>mysql命令行</title>
    <link href="http://yoursite.com/2018/11/03/mysql%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/11/03/mysql命令行/</id>
    <published>2018-11-03T12:39:58.000Z</published>
    <updated>2018-12-06T16:50:54.228Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-登录mysql："><a href="#1-登录mysql：" class="headerlink" title="1.登录mysql："></a>1.登录mysql：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="2-连接远程主机："><a href="#2-连接远程主机：" class="headerlink" title="2.连接远程主机："></a>2.连接远程主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 主机名 -u 用户名 -p</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-登录mysql：&quot;&gt;&lt;a href=&quot;#1-登录mysql：&quot; class=&quot;headerlink&quot; title=&quot;1.登录mysql：&quot;&gt;&lt;/a&gt;1.登录mysql：&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>angular模板语法</title>
    <link href="http://yoursite.com/2018/11/02/angular%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/02/angular模板语法/</id>
    <published>2018-11-02T04:02:46.000Z</published>
    <updated>2018-11-09T05:38:47.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-模板语法概览"><a href="#1-模板语法概览" class="headerlink" title="1.模板语法概览"></a>1.模板语法概览</h3><ul><li><p>1.插值语法：绑定属性变量的值到模板中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; detail.telNum &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>2.DOM元素属性绑定语法：将属性变量的值绑定到div的title属性上面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">title</span>]=<span class="string">"name"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span>，</span><br></pre></td></tr></table></figure></li><li><p>3.class类绑定：当isBlue返回true时div会绑定上isBlue这个类名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">class.isBlue</span>]=<span class="string">"isBlue()"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>4.style样式绑定：当isRed为ture时，那么button的文字的颜色为红色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> [<span class="attr">style.color</span>]=<span class="string">"isRed ? 'red' : 'green'"</span>&gt;</span>洪塞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>5.事键绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(click)="editContract()"</span><br></pre></td></tr></table></figure></li><li><p>6.双向绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(title)]="name"</span><br></pre></td></tr></table></figure></li><li><p>7.模板局部变量：模板局部变量name相当于input的实例化对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> #<span class="attr">name</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>8.管道操作符：形式 输入数据|管道名：管道参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>birthday&#123;&#123; birthday | date &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>9.模板表达式操作符：值不是必须的，当detail为null的时候也并不会发生异常。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; detail?.telNum &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>10.星号前缀：使用星号前缀可以简化对结构指令的使用，angular会将带有星号的指令引用替换成带有<template>标签的代码，等同于</template></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">myUnless</span>=<span class="string">"boolValue"</span>&gt;</span>myUnless is false now.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> [<span class="attr">myUnless</span>]=<span class="string">"boolValue"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>now is time<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-模板语法概览&quot;&gt;&lt;a href=&quot;#1-模板语法概览&quot; class=&quot;headerlink&quot; title=&quot;1.模板语法概览&quot;&gt;&lt;/a&gt;1.模板语法概览&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.插值语法：绑定属性变量的值到模板中。&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>angular生命周期</title>
    <link href="http://yoursite.com/2018/11/01/angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/11/01/angular生命周期/</id>
    <published>2018-11-01T14:04:27.000Z</published>
    <updated>2018-11-02T03:19:43.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-各个生命周期钩子接口包含在-angular-core中，每个接口都对应一个名为”ng-接口名”的生命周期方法。例如-angular-core提供的OnInit接口暴露出了一个叫做ngOnInit的生命周期方法。"><a href="#1-各个生命周期钩子接口包含在-angular-core中，每个接口都对应一个名为”ng-接口名”的生命周期方法。例如-angular-core提供的OnInit接口暴露出了一个叫做ngOnInit的生命周期方法。" class="headerlink" title="1.各个生命周期钩子接口包含在@angular/core中，每个接口都对应一个名为”ng+接口名”的生命周期方法。例如@angular/core提供的OnInit接口暴露出了一个叫做ngOnInit的生命周期方法。"></a>1.各个生命周期钩子接口包含在@angular/core中，每个接口都对应一个名为”ng+接口名”的生命周期方法。例如@angular/core提供的OnInit接口暴露出了一个叫做ngOnInit的生命周期方法。</h3><h3 id="2-各个生命周期方法调用的顺序如下所示："><a href="#2-各个生命周期方法调用的顺序如下所示：" class="headerlink" title="2.各个生命周期方法调用的顺序如下所示："></a>2.各个生命周期方法调用的顺序如下所示：</h3><ul><li>ngOnChanges: 当且仅当组件输入数据（@Input所修饰的组件数据）变化时被调用，该方法接收一个SimpleChanges对象，包含当前值和变化前的值。</li><li>ngOnInit: 会在第一次ngOnChanges之后被调用。</li><li>ngDoCheck: 会在每次变化监测时被调用，在每一个变化监测周期内，不管数据值是否发生了变化，ngDoCheck都会被调用。比如鼠标移动的时候会频繁触发mousemove事件，那么此时变化监测便会频繁被触发，随之带来的后果便是ngDoCheck被频繁调用，所以不应该在ngDoCheck里面写太过复杂的逻辑，否则性能大打折扣。</li><li>ngAfterContentInit: 使用<ng-content>将外部内容嵌入到组件视图中就会调用ngAfterContentInit，并且只会执行一次。</ng-content></li><li>ngAfterContentChecked: 使用<ng-content>将外部内容嵌入到组件视图中后，或者每次变化监测的时候都会调用。</ng-content></li><li>ngAfterViewInit: 创建完组件的视图以及子组件的视图后被调用。</li><li>ngAfterViewChecked: 创建完组件的视图以及子组件的视图后被调用一次，并且在每次子组件变化监测时也会被调用。</li><li>ngOnDestory: 销毁指令/组件之前触发。常在这里进行一些资源销毁的操作。</li></ul><h3 id="3-angular变化监测机制："><a href="#3-angular变化监测机制：" class="headerlink" title="3.angular变化监测机制："></a>3.angular变化监测机制：</h3><p>1.当数组发生变化时，Angular能够监测到这些变化并对其所绑定的DOM元素进行相应的更新。angular如何监测数据变化？策略是在适当的时机去检验对象的值是否被改动，什么时机是适当取决于NgZone这个服务来决定。NgZone能够获取到整个应用的上下文，能够对相关异步事件的发生，完成或者异常进行捕获，然后驱动angular的变化监测机制执行。数据变化的源头：在应用程序中，数据变化的源头可以分为如下三类：1.用户行为操作，比如点击；2.前后端数据交互；3.各种定时任务；这3个变化源头都拥有一个共同点那就是他们都是异步的。而之前所说的那个适当的时机就是当异步执行完之后去执行变化监测，而NgZone所做的就是让异步过程能够在执行完之后通知angular，这样angular就会执行下一轮的变化监测工作了，进而将数据更新到DOM上。</p><p>2.NgZone基于Zones实现，NgZone具有angular运行环境的执行上下文，在angular环境中注册的异步事件都运行在这个子zone上。</p><p>3.angular应用是有大大小小的组件组成的，每一个组件都拥有一个自己的变化监测器，由此一棵组件树也是一棵变化监测器树。变化监测器树中的数据流动总是从上到下单向流动的，这是因为变化监测的执行总是从根组件开始，接着从上到下的监测每一个组件的变化。正是因为每个组件都有一个独立的变化监测器，所以每个组件都能够自由灵活的控制变化监测器的暂停或者执行。这对于性能提升是很有意义的。</p><p>4.默认情况下，任何组件模型中的数据变化都会导致整个组件树的变化监测，从根组件开始单向向下，每个组件的变化监测器都会去执行变化的对比工作。而对于大部分组件来说，其输入属性很可能都是没有发生变化的，因此减少不必要的监测操作可以提升应用程序的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-各个生命周期钩子接口包含在-angular-core中，每个接口都对应一个名为”ng-接口名”的生命周期方法。例如-angular-core提供的OnInit接口暴露出了一个叫做ngOnInit的生命周期方法。&quot;&gt;&lt;a href=&quot;#1-各个生命周期钩子接口包
      
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
</feed>
