<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜游</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-28T03:43:56.645Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hahahai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现一个sleep方法</title>
    <link href="http://yoursite.com/2019/03/28/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/28/实现一个sleep方法/</id>
    <published>2019-03-28T02:52:53.000Z</published>
    <updated>2019-03-28T03:43:56.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题：实现一个sleep方法进行等待"><a href="#1-问题：实现一个sleep方法进行等待" class="headerlink" title="1.问题：实现一个sleep方法进行等待"></a>1.问题：实现一个sleep方法进行等待</h3><p><strong>法一：使用Promise实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果，步骤1和步骤2，步骤4几乎同时输出，步骤3被延时1S</span></span><br><span class="line"><span class="keyword">let</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p><strong>法二：使用promise+async实现，避免callback形式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果，步骤1，步骤2，步骤4的输出结果几乎相同；步骤3被延时1S</span></span><br><span class="line"><span class="keyword">let</span> sleepPromise = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wait1s = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  <span class="keyword">await</span> sleepPromise(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait1s();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p><strong>法三：使用promise+generator实现，注意每次调用generator构造方法都将会生成一个新的generator实例，此时将会从头开始yield.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1和步骤3几乎同时同时输出，步骤2滞后1S</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genIns = gen(<span class="number">1000</span>);</span><br><span class="line">genIns.next().value.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure><p>关于generator，调用generator实例的next会执行到yield语句，返回的是一个对象，该对象具有两个字段，分别是value和done，value对应yield出来的值，done表示这个generator实例是否执行完毕。每次调用generator构造函数函数都会生成一个新的generator实例。</p><p>看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gi = gen();</span><br><span class="line"><span class="built_in">console</span>.log(gi.next());     <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen().next());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gi.next());     <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gi.next());     <span class="comment">// &#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen().next());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen().next());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-问题：实现一个sleep方法进行等待&quot;&gt;&lt;a href=&quot;#1-问题：实现一个sleep方法进行等待&quot; class=&quot;headerlink&quot; title=&quot;1.问题：实现一个sleep方法进行等待&quot;&gt;&lt;/a&gt;1.问题：实现一个sleep方法进行等待&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>angular指令</title>
    <link href="http://yoursite.com/2019/02/11/angular%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2019/02/11/angular架构概览/</id>
    <published>2019-02-11T02:46:15.000Z</published>
    <updated>2019-02-14T02:05:35.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-内置指令"><a href="#一-内置指令" class="headerlink" title="一.内置指令"></a>一.内置指令</h3><p><strong>1.ngClass：在angular中，通过ngClass指令，可以同时添加或者移除多个类。</strong></p><p><strong>2.ngStyle: 使用ngStyle指令，可以给模板元素设置多个内联样式。</strong></p><p><strong>3.ngIf: 使用ngIf指令能够控制元素是否显示，并且如果其值为false的话，那么会从DOM树移除。</strong></p><p><strong>4.ngSwitch: ngSwitch指令需要和ngSwitchCase指令和ngSwitchDefault指令搭配使用。</strong></p><p><strong>5.ngFor：使用ngFor来展示列表数据；同时也可以获取到遍历索引；对于包含复杂列表的使用场景来说，使用普通的ngFor来渲染列表数据的话那么会出现明显的性能问题，此时应该配合使用trackBy来提升性能。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.component.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-root'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./app.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./app.component.css'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;</span><br><span class="line"></span><br><span class="line">  contractName = <span class="string">'hahahai'</span>;</span><br><span class="line"></span><br><span class="line">  setClasses() &#123;</span><br><span class="line">    <span class="keyword">let</span> classes = &#123;</span><br><span class="line">      red: <span class="literal">true</span>,</span><br><span class="line">      font14: <span class="literal">true</span>,</span><br><span class="line">      title: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setStyles() &#123;</span><br><span class="line">    <span class="keyword">let</span> styles = &#123;</span><br><span class="line">      <span class="string">'color'</span>: <span class="literal">true</span> ? <span class="string">'red'</span> : <span class="string">'yellow'</span>,</span><br><span class="line">      <span class="string">'font-size'</span>: <span class="literal">true</span> ? <span class="string">'14px'</span> : <span class="string">'16px'</span>,</span><br><span class="line">      <span class="string">'font-weight'</span>: <span class="literal">true</span> ? <span class="string">'bold'</span> : <span class="string">'normal'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> styles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.component.html</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 [ngClass]=<span class="string">"setClasses()"</span>&gt;angular&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h1 [ngStyle]="setStyles()"&gt;angular&lt;/</span>h1&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span [ngSwitch]=<span class="string">"contractName"</span>&gt;</span><br><span class="line">    &lt;span *ngSwitchCase=<span class="string">"'timcook'"</span>&gt;timcook&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span *ngSwitchCase="'billgates'"&gt;billgates&lt;/</span>span&gt;</span><br><span class="line">    &lt;span *ngSwitchCase=<span class="string">"'hahahai'"</span>&gt;hahahai&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span *ngSwitchDefault&gt;弄那么&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-内置指令&quot;&gt;&lt;a href=&quot;#一-内置指令&quot; class=&quot;headerlink&quot; title=&quot;一.内置指令&quot;&gt;&lt;/a&gt;一.内置指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.ngClass：在angular中，通过ngClass指令，可以同时添加或者移除多个类。
      
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>新点总结</title>
    <link href="http://yoursite.com/2019/01/26/%E6%96%B0%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/26/新点总结/</id>
    <published>2019-01-26T03:40:45.000Z</published>
    <updated>2019-01-26T03:57:04.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-react实现简易的下载功能"><a href="#1-react实现简易的下载功能" class="headerlink" title="1.react实现简易的下载功能"></a>1.react实现简易的下载功能</h3><p>1.如果对于某个接口来说，后端发给你的就是需要下载的文件内容自身。那么可以像下面这样实现下载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, config).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">    response.blob().then(<span class="function"><span class="params">blobData</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">      <span class="keyword">let</span> href = <span class="built_in">window</span>.URL.createObjectURL(blobData);</span><br><span class="line">      a.href = href;</span><br><span class="line">      a.download = <span class="string">'FILE_NAME'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(a).click();</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(href);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-react实现简易的下载功能&quot;&gt;&lt;a href=&quot;#1-react实现简易的下载功能&quot; class=&quot;headerlink&quot; title=&quot;1.react实现简易的下载功能&quot;&gt;&lt;/a&gt;1.react实现简易的下载功能&lt;/h3&gt;&lt;p&gt;1.如果对于某个接口来说，后
      
    
    </summary>
    
    
      <category term="work" scheme="http://yoursite.com/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>react遇上typescript</title>
    <link href="http://yoursite.com/2019/01/21/react%E9%81%87%E4%B8%8Atypescript/"/>
    <id>http://yoursite.com/2019/01/21/react遇上typescript/</id>
    <published>2019-01-21T10:10:53.000Z</published>
    <updated>2019-01-21T10:12:47.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h3><p>这里介绍用create-react-app所创建的应用，使用下面的命令开启对typescript的支持：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app learn --typescript</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本配置&quot;&gt;&lt;a href=&quot;#1-基本配置&quot; class=&quot;headerlink&quot; title=&quot;1.基本配置&quot;&gt;&lt;/a&gt;1.基本配置&lt;/h3&gt;&lt;p&gt;这里介绍用create-react-app所创建的应用，使用下面的命令开启对typescript的支持：&lt;/
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>express+ts上手记1</title>
    <link href="http://yoursite.com/2019/01/20/express-ts%E4%B8%8A%E6%89%8B%E8%AE%B01/"/>
    <id>http://yoursite.com/2019/01/20/express-ts上手记1/</id>
    <published>2019-01-20T02:55:47.000Z</published>
    <updated>2019-01-20T14:26:37.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础配置"><a href="#1-基础配置" class="headerlink" title="1.基础配置"></a>1.基础配置</h3><p>1.在项目目录使用npm init -y生成npm配置，接着安装node所对应的ts声明文件：npm i @types/node –save；参考ts官网配置tsconfig.json文件；如果使用vscode的话，那么使用command（control）+ shift + b构建或者watch整个项目的变化。到达这一步的时候基本配置就已经配置好了。</p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h3><p>尽管我们没有在tsconfig.json文件里面指定include入口，不过此时有一个默认的配置。他会编译项目里面除开exclude指定的其他js文件。所以我们可以在项目的根目录使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础配置&quot;&gt;&lt;a href=&quot;#1-基础配置&quot; class=&quot;headerlink&quot; title=&quot;1.基础配置&quot;&gt;&lt;/a&gt;1.基础配置&lt;/h3&gt;&lt;p&gt;1.在项目目录使用npm init -y生成npm配置，接着安装node所对应的ts声明文件：npm i @
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>rust2</title>
    <link href="http://yoursite.com/2019/01/15/rust2/"/>
    <id>http://yoursite.com/2019/01/15/rust2/</id>
    <published>2019-01-15T12:50:34.000Z</published>
    <updated>2019-01-16T02:15:12.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-trait"><a href="#1-trait" class="headerlink" title="1.trait"></a>1.trait</h3><p>在trait中可以包含函数，常量，类型等。如下所示是一个包含函数的trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Shape</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的trait中都有一个隐藏的类型Self，代表了当前实现了该trait的具体类型，在trait中定义的函数，被叫做关联函数。如果一个关联函数的第一个参数是Self类型并且名字叫self的话（这样的参数叫做接收者），那么这个关联函数叫做方法，方法通过变量实例加上小数点进行调用；如果一个关联函数第一个参数不是接收者的话，那么这个关联函数叫做静态函数，通过类型::函数名的形式来调用。</p><p>所以在Rust中，Self（类型）和self（变量实例名）都是保留关键字。</p><p>当然我们也可以显示给接收者指定类型，但是同时他们在rust中都具有简写的写法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trait Shape &#123;</span><br><span class="line">  fn method1(self: Self);</span><br><span class="line">  fn method2(self: &amp;Self);</span><br><span class="line">  fn method3(self: &amp;mut Self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于上面的情况，也可以简写成下面的形式：</span></span><br><span class="line">trait Shape &#123;</span><br><span class="line">  fn method1(self);</span><br><span class="line">  fn method2(&amp;self);</span><br><span class="line">  fn method3(&amp;mut self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是让一个类实现一个trait的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">trait Shape &#123;</span><br><span class="line">  fn area(&amp;self) -&gt; f64;</span><br><span class="line">&#125;</span><br><span class="line">struct Circle &#123;</span><br><span class="line">  radius: f64,</span><br><span class="line">&#125;</span><br><span class="line">impl Shape <span class="keyword">for</span> Circle &#123;</span><br><span class="line">  fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">    std::f64::consts::PI * self.radius * self.radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  let c = Circle&#123; radius: <span class="number">10</span>f64 &#125;;</span><br><span class="line">  println!(<span class="string">"area is &#123;&#125;"</span>, c.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以为一个struct实现一个匿名trait；并不是只能在trait中声明函数，也可以定义函数的行为，实现他的struct便能够直接使用，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span></span> &#123;</span><br><span class="line">  radius: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Circle &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">get_radius</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> c = Circle&#123; radius: <span class="number">10f64</span> &#125;;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"c.radius is &#123;&#125;"</span>, c.get_radius());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong>，只要一个trait里面的关联函数的第一个参数不是接收器的话，那么就表明这个方法是静态函数，使用类型::方式调用，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> T &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">func</span></span>(this: &amp;<span class="keyword">Self</span>) &#123;  <span class="comment">// 由于第一个参数的名字不是self，尽管类型是Self</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"value is &#123;&#125;"</span>, this.<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> x = T(<span class="number">42</span>);</span><br><span class="line">  T::func(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rust规定，在函数中进行参数传递，返回值传递等地方，都要求这个类型在编译阶段具有确定的大小。而trait本身既不是具体类型，也不是指针类型，它只是定义了一个针对类型的抽象的约束，不同的类型可以实现同一个trait，同时满足同一个trait的类型可能具有不同的大小，所以trait在编译期间是没有确定大小的，因此不能使用trait作为实例变量，参数，返回值。</strong></p><p>在rust中，一个类可以实现多个trait，那么问题来了，如果实现的多个trait里面具有同名函数的话，那么调用的时候该怎么调用呢？对此rust提出了完全函数调用的概念，这使得函数调用变得直接与直观，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Cook</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Wash</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chef</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cook <span class="keyword">for</span> Chef &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Cook::start"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wash <span class="keyword">for</span> Chef &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Wash::start"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-trait&quot;&gt;&lt;a href=&quot;#1-trait&quot; class=&quot;headerlink&quot; title=&quot;1.trait&quot;&gt;&lt;/a&gt;1.trait&lt;/h3&gt;&lt;p&gt;在trait中可以包含函数，常量，类型等。如下所示是一个包含函数的trait。&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="rust" scheme="http://yoursite.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>flutter之弹性布局Flex</title>
    <link href="http://yoursite.com/2019/01/15/flutter%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80Flex/"/>
    <id>http://yoursite.com/2019/01/15/flutter之弹性布局Flex/</id>
    <published>2019-01-15T02:35:04.000Z</published>
    <updated>2019-01-15T05:23:19.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>弹性布局表示允许子widget按照一定比例来分配父容器的空间；如果你知道主轴方向，那么使用Row/Column会更加方便一些，因为这两者也都是继承自Flex的。下面我们可以看看Flex的基本定义，在前面Row和Column中提到过的属性这里就不提了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.direction, <span class="comment">// 弹性布局方向，对于Row来说默认就是水平方向；对于Column来说默认就是垂直方向。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-新概念-Expanded"><a href="#2-新概念-Expanded" class="headerlink" title="2.新概念-Expanded"></a>2.新概念-Expanded</h3><p>可以按照比例来扩伸Row，Column和Flex子Widget所占用的空间。下面可以看看它的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">    <span class="built_in">int</span> flex = <span class="number">1</span>,</span><br><span class="line">    <span class="meta">@required</span> Widget child</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>flex为弹性系数，如果为0或者null的话，则child是没有弹性的，此时不会扩伸占用的空间。如果大于0，所有的Expanded将会按照其flex的比例来分割主轴的全部空闲空间。</p><h3 id="3-流式布局"><a href="#3-流式布局" class="headerlink" title="3.流式布局"></a>3.流式布局</h3><p>对于Row和Column来说，如果子widget超出屏幕范围，则会报溢出错误，因为Row默认只能显示一行，如果超出屏幕的话并不会折行。在Flutter中，把超出屏幕显示范围会自动折行的布局叫做流失布局，具体通过Wrap和Flow这两个widget来进行支持。</p><h3 id="4-布局类和容器类"><a href="#4-布局类和容器类" class="headerlink" title="4.布局类和容器类"></a>4.布局类和容器类</h3><p>布局类一般接受一个widget数组（children)，而容器类一般只接受一个子Widget（child)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;弹性布局表示允许子widget按照一定比例来分配父容器的空间；如果你知道主轴方向，那么使用Row/Colum
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter线性布局</title>
    <link href="http://yoursite.com/2019/01/15/flutter%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/01/15/flutter线性布局/</id>
    <published>2019-01-15T01:41:55.000Z</published>
    <updated>2019-01-15T02:33:52.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就是水平方向；如果布局沿垂直方向，那么主轴就是指垂直方向；在Flutter中通过Row和Column来实现线性布局；并且Row以及Column都是继承自Flex。</p><h3 id="2-Row"><a href="#2-Row" class="headerlink" title="2.Row"></a>2.Row</h3><p>Row表明在水平方向排列其子widget，因此此时主轴就是水平方向；纵轴就是垂直方向；Row的定义如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  TextDirection textDirection,</span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  List&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>构造函数中各个字段的意思：</p><ul><li>1.textDirection：表示在水平方向上widget的布局顺序，注意一定是水平方向。</li><li>2.mainAxisSize：表示一个Row在水平方向所占用的空间，两个值可选，分别是mainAxisSize.min和mainAxisSize.max。</li><li>3.mainAxisAlignment：表示子Widgets在水平空间内的对齐方式；如果mainAxisSize的值为MainAxisSize.min的话，那么定义mainAxisAlignment的值将没有意义，因为子widget的宽度和Row的宽度是一样的。只有在mainAxisSize的值为mainAxisSize.max的时候，给mainAxisAlignment设置值才是可以接受的，假设textDirection的值为TextDirection.ltr的话，那么MainAxisAlignment.start表示左对齐；假设textDirection的值为TextDirection.rtl的话，那么设置MainAxisAlignment.end的话也是表明左对齐。当然还有mainAxisAlignment.center，这自然表明是居中了。</li><li>4.verticalDirection：表示Row的纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。</li><li>5.crossAxisAlignment：表示子widget在纵轴方向的对齐方式，在线性布局里面，Row的高度等于子Widgets中最高的子元素高度。这个属性具有三个可选值，分别是start,end,center，不同的是它的参考系是verticalDirection。</li><li>6.children：子widget数组。</li></ul><h3 id="3-Column"><a href="#3-Column" class="headerlink" title="3.Column"></a>3.Column</h3><p>Column表示在垂直方向进行排列，参数和Row类似，不同的就是Column表明的是垂直方向。</p><h3 id="4-需要注意的地方"><a href="#4-需要注意的地方" class="headerlink" title="4.需要注意的地方"></a>4.需要注意的地方</h3><p>如果Row里面嵌套Row，或者Column里面嵌套Column，那么只有最外面的Row或者Column会占用尽可能大的空间，里面的Row和Column为其实际大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;对于线性布局，有主轴和纵轴之分，如果布局是沿水平方，那么主轴就是水平方向；如果布局沿垂直方向，那么主轴就是指
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>next.js学习</title>
    <link href="http://yoursite.com/2019/01/14/next-js%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/14/next-js学习/</id>
    <published>2019-01-14T03:20:44.000Z</published>
    <updated>2019-01-15T01:57:35.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save next react reac-dom</span><br></pre></td></tr></table></figure><p>将上面的这些依赖安装好了之后，接着配置package.json文件，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"next"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"next build"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"next start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这些设置之后，在项目根目录下面的pages文件夹下面就是一个路由文件了，路由的名字和</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-使用&quot;&gt;&lt;a href=&quot;#1-使用&quot; class=&quot;headerlink&quot; title=&quot;1.使用&quot;&gt;&lt;/a&gt;1.使用&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="next.js" scheme="http://yoursite.com/tags/next-js/"/>
    
  </entry>
  
  <entry>
    <title>flutter之图片和icon</title>
    <link href="http://yoursite.com/2019/01/11/flutter%E4%B9%8B%E5%9B%BE%E7%89%87%E5%92%8Cicon/"/>
    <id>http://yoursite.com/2019/01/11/flutter之图片和icon/</id>
    <published>2019-01-11T11:46:42.000Z</published>
    <updated>2019-01-11T12:49:26.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>Flutter中，通过Image来加载并显示图片，Image的数据源可以是asset，文件，内存以及网络。</p><h3 id="2-ImageProvider"><a href="#2-ImageProvider" class="headerlink" title="2.ImageProvider"></a>2.ImageProvider</h3><p>ImageProvider是一个抽象类，主要定义了图片数据获取的接口load()，从不同的数据源获取图片需要实现不同的ImageProvider，比如AssetImage是实现了从Asset中加载图片的ImageProvider，而NetworkImage实现了从网络中加载图片的ImageProvider。</p><p>Image Widget有一个必选的image参数，它对应一个ImageProvider，如下面例子：</p><p>如果是从asset中加载图片的话，那么要先在pubspec.yml文件中的flutter部分添加以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  assets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">images/WechatIMG540.jpeg</span></span><br></pre></td></tr></table></figure><p>具体的实例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">    image: AssetImage(<span class="string">"images/some.png"</span>),</span><br><span class="line">    width: <span class="number">100.0</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 或者像下面这样</span></span><br><span class="line">Image.asset(<span class="string">"images/some.png"</span>, width: <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于网络图片来说，其用法可能更加简单一点</span></span><br><span class="line">Image(</span><br><span class="line">    image: NetworkImage(<span class="string">'image_url'</span>),</span><br><span class="line">    width: <span class="number">300.0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者像下面这样的便捷写法</span></span><br><span class="line">Image.network(</span><br><span class="line">    <span class="string">'img_url'</span>,</span><br><span class="line">    width: <span class="number">300.0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;Flutter中，通过Image来加载并显示图片，Image的数据源可以是asset，文件，内存以及网络。&lt;
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter之按钮</title>
    <link href="http://yoursite.com/2019/01/11/Flutter%E4%B9%8B%E6%8C%89%E9%92%AE/"/>
    <id>http://yoursite.com/2019/01/11/Flutter之按钮/</id>
    <published>2019-01-11T09:34:47.000Z</published>
    <updated>2019-01-11T11:29:33.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>Material widget库中提供了多种按钮Widget，比如RaisedButton，FlatButton，OutlineButton，它们都是直接或间接继承自RawMaterialButton。所有的Material库中的按钮都有下面几相同点：</p><ul><li>1.按下的时候会有水波动画</li><li>2.<strong>有一个onPressed属性来设置点击回调，按钮按下的时候执行该回调；如果不提供该回调的话则按钮会处于禁用状态。禁用状态不响应用户点击。</strong></li></ul><h3 id="2-RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。"><a href="#2-RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。" class="headerlink" title="2.RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。"></a>2.RaisedButton：漂浮按钮，默认带有阴影和灰色背景，按下后，阴影会变大。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">'购买'</span>),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="3-FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。"><a href="#3-FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。" class="headerlink" title="3.FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。"></a>3.FlatButton：扁平按钮，默认背景透明并且不带阴影，按下后，会有背景色。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">    child: Text(<span class="string">'按钮'</span>),</span><br><span class="line">    onPressed: () =&gt; &#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>FlatButton的构造信息如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FlatButton(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onPressed, <span class="comment">// 按钮点击回调</span></span><br><span class="line">    <span class="keyword">this</span>.textColor,   <span class="comment">// 按钮文字颜色,</span></span><br><span class="line">    <span class="keyword">this</span>.color,     <span class="comment">// 按钮背景颜色</span></span><br><span class="line">    <span class="keyword">this</span>.disabledColor, <span class="comment">// 按钮禁用时候的背景颜色</span></span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h3&gt;&lt;p&gt;Material widget库中提供了多种按钮Widget，比如RaisedButton，FlatButt
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter之文本</title>
    <link href="http://yoursite.com/2019/01/09/Flutter%E4%B9%8B%E6%96%87%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/01/09/Flutter之文本/</id>
    <published>2019-01-09T15:17:00.000Z</published>
    <updated>2019-01-10T13:50:29.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>用于显示简单样式文本。用法如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Text(<span class="string">'hello world'</span>, textAlign: TextAlign.center);</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'hello world'</span>*<span class="number">4</span>, maxLines: <span class="number">1</span>, overflow: TextOverflow.ellipsis);</span><br><span class="line"></span><br><span class="line">Text(<span class="string">'hello world'</span>, textScaleFactor: <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><h3 id="2-Text方法的几个参数代表的意思"><a href="#2-Text方法的几个参数代表的意思" class="headerlink" title="2.Text方法的几个参数代表的意思"></a>2.Text方法的几个参数代表的意思</h3><ul><li><p>1.textAlign: 文本的对齐方式，可以选择左对齐，右对齐还是居中；这几个值都是从TextAlign里面获取。<strong>需要注意，对齐的参考系是Text Widget本身，这意味着如果Text的宽度和文本内容长度相等的话，那么此时指定对齐方式是没有意义的。</strong></p></li><li><p>2.maxLines, overflow: 指定文本显示的最大行数，默认情况下，文本是自动折行的。但是如果指定了maxLine的话，那么最多显示maxLines行，超出了maxLines行的行为由overflow的值来决定，默认是直接截断；如果想要显示省略号的话，那么使用TextOverflow.ellipsis值。</p></li><li><p>3.textScaleFactor: 代表文本相对于当前字体大小(style属性里面的fontSize)的缩放因子。</p></li><li><p>4.style: 他的值是一个TextStyle类所实例化出来的对象，举个例子如下所示：</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  <span class="string">'hello world'</span>,</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">      color: Colors.black,    <span class="comment">// 字体颜色</span></span><br><span class="line">      background: <span class="keyword">new</span> Paint()..color = Colors.white,    <span class="comment">// 字体底层的颜色（背景颜色）</span></span><br><span class="line">      fontSize: <span class="number">20</span>,</span><br><span class="line">      fontFamily: <span class="string">'Courier'</span>,</span><br><span class="line">      decoration: TextDecoration.underline,</span><br><span class="line">      height: <span class="number">1.3</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>需要注意的地方，TextStyle类的实例化参数height是一个因子，具体行高等于fontSize乘height。</strong></p><h3 id="3-TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。"><a href="#3-TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。" class="headerlink" title="3.TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。"></a>3.TextSpan：如果是Text是p元素的话，那么TextSpan就是span元素。</h3><p>如果想要对Text的不同部分应用不同的效果的话，那么使用TextSpan会更加方便。可以先看看TextSpan的构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用了命名可选参数的写法，采用这种写法的话，除非带上@required的话否则都是可选</span></span><br><span class="line"><span class="keyword">const</span> TextSpan(&#123;</span><br><span class="line">    TextStyle style,</span><br><span class="line">    <span class="built_in">String</span> text,</span><br><span class="line">    <span class="built_in">List</span>&lt;TextSpan&gt; children,</span><br><span class="line">    GestureRecognizer recognizer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>各个参数的解释：</p><ul><li>1.children，一个TextSpan数组，说明TextSpan里面可以包含其它TextSpan</li><li>2.recognizer，在文本片段上进行手势处理</li></ul><p>举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Text.rich(TextSpan(</span><br><span class="line">    children: [</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">'主页：'</span></span><br><span class="line">      ),</span><br><span class="line">      TextSpan(</span><br><span class="line">          text: <span class="string">'hotfireeagle.github.io'</span>,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">              color: Colors.blue</span><br><span class="line">          ),</span><br><span class="line">          recognizer: gotoLink, <span class="comment">// 手势处理方法</span></span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">))</span><br></pre></td></tr></table></figure><h3 id="4-DefaultTextStyle"><a href="#4-DefaultTextStyle" class="headerlink" title="4.DefaultTextStyle"></a>4.DefaultTextStyle</h3><p>在Widget树中，文本的样式默认是可以继承的。因此，如果在Widget树中的某个节点处设置一个默认的文本样式的话，那么该节点下的子树中的所有文本都会默认使用这个样式。不同于web编程，设置默认文本样式可以在任意一个父元素里面，但是在flutter里面如果想要设置默认文本样式的话，那么应该使用DefaultTextStyle这个widget才行。如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DefaultTextStyle(</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        fontSize: <span class="number">18.0</span></span><br><span class="line">    ),</span><br><span class="line">    textAlign: TextAlign.center,</span><br><span class="line">    <span class="comment">// 注意在这里是child</span></span><br><span class="line">    child: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        <span class="comment">// 注意在这里是children</span></span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">'hello world'</span>),</span><br><span class="line">          Text(<span class="string">'hello flutter'</span>),</span><br><span class="line">          Text(<span class="string">'cool'</span>, style: TextStyle(color: Colors.green))</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h3&gt;&lt;p&gt;用于显示简单样式文本。用法如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>express学习</title>
    <link href="http://yoursite.com/2019/01/07/express%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/07/express学习/</id>
    <published>2019-01-07T09:17:44.000Z</published>
    <updated>2019-01-09T15:22:15.814Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.helmet中间件介绍</strong></p><p>helmet中间件是用来增强express应用的安全性的，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.helmet中间件介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;helmet中间件是用来增强express应用的安全性的，&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>dart基础3</title>
    <link href="http://yoursite.com/2019/01/07/dart%E5%9F%BA%E7%A1%803/"/>
    <id>http://yoursite.com/2019/01/07/dart基础3/</id>
    <published>2019-01-07T03:03:34.000Z</published>
    <updated>2019-01-07T03:54:59.732Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.异步支持，在dart中有很多返回Future和Stream对象的函数，这些函数在设置完耗时任务之后就立即返回了，不会等待耗时任务完成。使用async和await关键字可以让我们像编写同步代码一样实现异步操作。</strong></p><p><strong>2.如何获得Future的返回结果，具有两种方式，分别是使用async和await；使用Future API。可以使用try…catch…来捕获代码中使用await所导致的错误。首先看看第一种方式：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.声明异步函数，使用async声明函数并且返回值是Future。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">'1.0.0'</span>; <span class="comment">// 需要注意async修饰符的位置</span></span><br></pre></td></tr></table></figure><p><strong>4.同样，对于Stream对象来说，他也是一种异步操作，如果想获取他的返回值的话，那么也有两种方式：分别是使用await（await for)和Stream API。</strong></p><p><strong>5.可调用类，通过给类实现一个call方法，能够让类所实例化出来的对象被调用。如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">callable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> a;</span><br><span class="line"></span><br><span class="line">  callable(<span class="keyword">this</span>.a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> consoleA() &#123; <span class="built_in">print</span>(<span class="string">'a is <span class="subst">$a<span class="string">'); &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  call(String a, String b, String c) =&gt; '</span></span><span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">void main() &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  let cb = callable(3);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  cb.consoleA(); // a is 3</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  let ret = cb('</span><span class="number">7</span><span class="string">', '</span><span class="number">8</span><span class="string">', '</span><span class="number">9</span><span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>ret is <span class="subst">$ret<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p><strong>6.typedef类型定义，考虑下面这个场景:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortCollection sc = SortCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(sc.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个例子，当把f赋值给compare的时候，f的类型信息(Object, Object) -&gt; int（rust写法)被丢弃了，此时compare的类型信息为Function。为了避免这种类型丢失的情况，可以像下面这样做：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortCollection coll = SortCollection(sort);</span><br><span class="line">  <span class="comment">// 这样做的话coll.compare类型信息便没有丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typedef和泛型结合在一起：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare&lt;<span class="built_in">int</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.异步支持，在dart中有很多返回Future和Stream对象的函数，这些函数在设置完耗时任务之后就立即返回了，不会等待耗时任务完成。使用async和await关键字可以让我们像编写同步代码一样实现异步操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>dart基础2</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2019/01/05/dart基础2/</id>
    <published>2019-01-05T09:23:32.000Z</published>
    <updated>2019-01-07T02:59:50.356Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.类</strong></p><p>Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。</p><p>在Dart2中，new关键字是可选的。</p><p>在dart中，存在像下面这样实例化对象的方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.常量构造函数</strong></p><p>在构造函数名之前加const关键字，来创建编译时常量，构造两个相同的编译时常量会产生一个唯一的，标准的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(identical(a, b));</span><br></pre></td></tr></table></figure><p><strong>3.一个不太明白的特性：在dart2中，一个常量上下文中的const关键字可以被省略。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个不省略的版本</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'point'</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 接下来是一个省略的版本，仅有一个const，由该const建立上下文</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">'point'</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.获取对象的类型</strong></p><p>使用对象的runtimeType属性可以在运行的时候获取对象的类型。他返回的是一个Type对象。</p><p><strong>5.实例变量：就是不是类对象所拥有的，而是类所实例化出来的对象所拥有的</strong></p><p>所有未初始化变量的默认值都是null，所有实例变量都会生成一个隐式的getter方法，非final的实例变量同样会生成一个隐式的setter方法。也就是说对一个实例变量进行赋值的时候，实际都是通过调用setter方法来赋值的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> y;  <span class="comment">// 初始值是null</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;  <span class="comment">// 初始值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.构造函数，通过创建一个和类同名的函数来声明构造函数，可以使用this关键字来获取当前实例。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很常见的生成构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还有更好的方式实现下面代码，在dart里面最佳实践应该减少使用this</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是精简模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="comment">// 一颗语法题</span></span><br><span class="line">  Point (<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有声明构造函数的情况下，Dart会提供一个默认的构造函数，默认构造函数没有参数并会调用父类的无参构造函数。子类不会继承父类的构造函数，子类不声明构造函数，那么它就只有默认构造函数。</p><p><strong>7.命名构造函数，使用命名构造函数可以为一个类实现多个构造函数，可以使用命名构造函数来更清晰的表明函数意图：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.什么鬼super，如下所示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Person'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Employee'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;); <span class="comment">// 输出 =&gt; in Person in Employee</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.初始化列表概念，很难看</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">    : x = x,</span><br><span class="line">      y = y,</span><br><span class="line">      distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种初始化列表的写法起的作用对应了js里面的参数默认值，在写法上后者简直不要太简单优雅；在dart中，我们可以在构造函数后面加上一个:后面跟上一些初始化列表语句，同时也能够对其进行开发期assert判断处理。</p><p><strong>10.重定向构造函数，在某些情况下，某些命名构造函数只需要使用其它构造函数的逻辑即可，那么此时使用重定向构造函数便很合适：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  Point.which(<span class="built_in">num</span> x): <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.常量构造函数，常量构造函数所创建出来的实例并不是常量（？？），如果希望实例出来的变量是固定不变的话，那么首先构造函数得是const的，并且所有实例变量也都得是final。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.工厂构造函数，第一次接触到。如果类中的某个构造函数并不总是返回这个类的实例（而是有可能返回其它类的实例）的话，那么这个构造函数也被叫做工厂构造函数，使用factory关键字来定义，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.Getters和Setters，每一个实例变量都会有一个隐式的getter，通常也会有一个setter。同时我们也可以使用get和set关键字来显式设置getters和setters。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示声明带有getter和setter的实例属性</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>l</span><br><span class="line">  <span class="keyword">assert</span>(rect.left = <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>14.抽象方法，抽象方法只能够存在于抽象类中。实例方法，getter，setter方法可以是抽象的，他们只定义接口而不实现，实现交给子类去完成。调用抽象方法会带来运行时错误：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doStuff();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuff</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> soStuff() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>15.抽象类：使用abstract修饰符来定义一个抽象类，抽象类不能用来实例化，如果希望抽象类能够被实例化，那么可以通过定义工厂实例函数来实现。在dart中声明抽象方法无需加上abstract修饰符，没有大花括号并且加上返回值就是了。抽象方法只能在抽象类中定义。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> updateChildren();  <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16.接口：每个类都隐式的定义了一个接口，接口包含了该类所有的实例变量以及实例方法，但是，注意并不包含构造函数。如果想要创建一个A类，并且A类要支持B类的API的话，但是又不想继承B类的实现的话，那么可以通过让A类来实现B类的接口。如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>, I am <span class="subst">$_name<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">class Impostor implements Person &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  get _name =&gt; '</span><span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  String greet(String who) =&gt; '</span></span>Hi, <span class="subst">$who</span>, Do You Know Who I Am'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">'kay'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时一个类也能够用来实现多个接口，如下所示：</p><p>class Point implements PointA, PointB {…}</p><p><strong>17.枚举类型是一种特殊的类，使用enum关键字来定义一个枚举类。枚举中的每一个值都具有一个index getter方法，该方法这个值在枚举类型中的位置；每个枚举类型，都具有一个values实例常量，用来获取所有枚举值列表。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p><strong>18.使用mixins，使用类的时候with一个mixin，怎么实现一个mixin？使用mixin关键字进行定义，写法和类写法一样，除了使用mixin代替了class外。</strong></p><p><strong>19.静态变量和静态方法，使用static即可，注意，静态变量只有在被使用的时候才会初始化；静态方法因为不可以在实例上访问，所以无法访问this。</strong></p><p><strong>20.泛型，挺好的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p><strong>21.参数化字面量，作用是不用去猜？</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">'haha'</span>, <span class="string">'hai'</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">'index.html'</span>: <span class="string">'Homepage'</span>,</span><br><span class="line">  <span class="string">'robots.txt'</span>: <span class="string">'all spider'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>22.在运行时能够测试到泛型类型，泛型类型是固化的</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'n1'</span>, <span class="string">'n2'</span>, <span class="string">'n3'</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>23.限制泛型类型</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> toString() =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>24.泛型方法，这才像样</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>25.库和可见性，import和library指令用来创建模块化的，可共享的代码库。以下划线_开头的标识符仅在库中可见，每个dart程序都是一个库，尽管没有使用library指令。</strong></p><p>利用import命令来使用一个库，import后面加上一个URI；对于内置的库来说，URI拥有自己内置的dart:方案；对于其他的库，使用系统文件路径或者package:方案；其中后者使用package:方案是指定由包管理器（pub工具）所提供的库。如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure><p><strong>26.指定库前缀来解决两个库里面定义了同一个类；假设下面两个类中都有Element的声明的话，那么如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Element</span> ele1 = <span class="built_in">Element</span>();</span><br><span class="line">lib2.<span class="built_in">Element</span> ele2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure><p><strong>27.导入库的一部分，还是挺方便的，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo; <span class="comment">// 只导入这个库的foo部分</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo; <span class="comment">// 导入这个库除了foo外的其它部分</span></span><br></pre></td></tr></table></figure><p><strong>28.延迟加载库，在某些地方还是能够派上用场的，使用延迟加载库的功能能够优化App启动时间；延迟加载库使用上了dart的异步功能，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary(); <span class="comment">// 调用loadLibrary函数来加载库</span></span><br><span class="line">  hello.printGreet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dart是一种基于类和mixin继承机制的面向对象的语言。所有的类都继承于Object。基于Mixin机制意味着每个类都只有一个超类（除Object外），一个类中的代码可以在其它多个继承类中反复使用。&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>dart基础1</title>
    <link href="http://yoursite.com/2019/01/05/dart%E5%9F%BA%E7%A1%801/"/>
    <id>http://yoursite.com/2019/01/05/dart基础1/</id>
    <published>2019-01-05T02:02:32.000Z</published>
    <updated>2019-01-05T07:42:10.258Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.使用var会自动进行类型推断，如果不想要类型推断的话，那么使用dynamic。</strong></p><p><strong>2.dart没有关键字public,protected,private，如果标识符以_开头，则说明它相对于库是私有的。</strong></p><p><strong>3.任何和变量进行捆绑的都是对象，无论它是不是基本类型。例如String,Number也是继承自Object类，是祖先类。</strong></p><p><strong>4.变量只是存储对象引用，声明定义变量可以有如下方式：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'bob'</span>; <span class="comment">// 会自动进行类型推断为String类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span> name1 = <span class="string">'i can change'</span>; <span class="comment">// 动态类型，为什么是动态？因为Object是所有对象的祖先类ya</span></span><br><span class="line"><span class="keyword">dynamic</span> name2 = <span class="string">'also change'</span>;  <span class="comment">// 也是动态类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> name3 = <span class="string">'me'</span>; <span class="comment">// 显式说明类型</span></span><br></pre></td></tr></table></figure><p><strong>5.在使用过程中不会发生变化的变量可以使用final或者const来声明，final变量的值只能被设置一次；const在编译时则已经固定。如果const变量是类级别的，需要标记为static const。</strong></p><p><strong>6.天秀const，像是回到了c指针又像是rust的mut，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'a'</span>;  <span class="comment">// 定义一个常量变量a，前面也提到了变量里面存储的是对象引用，所以这个变量a不能再被赋值了，只能指向'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">const</span> []; <span class="comment">// ???? 秀，这个时候的const是说明右值是不会发生变化的，因此使用aa变量的时候是不能修改到其引用的对象的</span></span><br><span class="line"></span><br><span class="line">aa = <span class="string">'ok'</span>; <span class="comment">// 话还没说完，但是变量aa并不是不可变的，所以变量aa是可以再次赋值，可以更改为指向其它对象的引用</span></span><br></pre></td></tr></table></figure><p><strong>7.String可以通过${expression}的方式内嵌表达式，如果表达式是一个标识符，则{}可以省略。</strong></p><p><strong>8.List就相当于js里面的Array，可以看看下面这种使用方法，其知识点正是上面所提到的那个const的地方：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">const</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// arr[1] = 1;  这种操作是会报错的，因为已经明确声明了变量arr所指向的对象是不可变的</span></span><br></pre></td></tr></table></figure><p><strong>9.Map就像是JavaScript里面的object一样，在一个map对象中一个key只能出现一次，下面介绍一下Map的用法：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">  <span class="string">'first'</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用map字面量来初始化一个对象，会被自动类型推断为Map&lt;String, String&gt;，所以如果有不符合类型推断的key或者value加入进去的话</span></span><br><span class="line"><span class="comment">// 那么将会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">Map</span>();</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">'one'</span>;</span><br><span class="line">m[<span class="number">2</span>] = <span class="string">'two'</span>;</span><br></pre></td></tr></table></figure><p>使用.length方法来获取当前map中的key-value对数量。创建一个Map类型运行时常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">'two'</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">'three'</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">'four'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>10.函数：如果函数中只有一句表达式的话，那么可以使用简写语法：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> n) =&gt; n !==<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><strong>11.函数的可选参数，函数具有两种参数类型，分别是required类型和optional类型，required类型参数放在参数的最前面，随后optional类型参数。其中可选参数又分为了命名参数和位置参数，一个可选参数只能是其中某一种。</strong></p><p><strong>12.命名可选参数，使用这种方式调用函数的时候很奇怪，看着像是js里面的object参数，但是又不是，其实也就是规定了参数的名字，让调用者明白对所传参数的意思更加一目了然？，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125; <span class="comment">// 这是定义函数时候的模样</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>); <span class="comment">// 这是调用函数时的模样，很奇怪吧</span></span><br></pre></td></tr></table></figure><p><em>（注：在flutter中，窗口小部件的构造函数仅使用命名参数），更易于阅读？</em></p><p>使用@required注释表明一个命名参数是必选的，其中@required被定义在package:meta/meta.dart里面，同时其它一些包也将其引入并导出了，比如说package:flutter/material.dart。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun(&#123;<span class="built_in">String</span> param1, <span class="meta">@required</span> <span class="built_in">bool</span> param2&#125;) &#123;...&#125; <span class="comment">// 如果在调用函数的时候没有传params参数的话将会报错</span></span><br></pre></td></tr></table></figure><p><strong>13.位置可选参数，将参数放到[]里面，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> say <span class="subst">$msg<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (device != null) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    result = '</span></span><span class="subst">$result</span> with <span class="subst">$device<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return result;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">say('</span></span>hai'</span>, <span class="string">'hello'</span>);</span><br><span class="line">say(<span class="string">'who'</span>, <span class="string">'hello'</span>, <span class="string">'wrchat'</span>);</span><br></pre></td></tr></table></figure><p><strong>14.默认参数值：可以使用=来定义可选参数的默认值，并且默认值只能是编译时常量，如果没有提供默认值的话，那么默认值为null。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'one'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'two'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list: <span class="subst">$list<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>gifts: <span class="subst">$gifts<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p><strong>15.main方法，任意一个dart应用都需要main函数，参数为一个可选的List<string></string></strong></p><p><strong>16.词法闭包</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeFun(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> add2 = makeFun(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> add4 = makeFun(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>17.关于算术操作需要注意的地方：/是返回浮点数；~/返回整数。</strong></p><p><strong>18.赋值运算符的花样，dart提供了一个??= 赋值运算符，只有当被赋值变量为null的时候，才会执行赋值操作，如下所示：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b ??= value; <span class="comment">// 如果b为空的话，将变量赋值给b；否则，b的值保持不变</span></span><br></pre></td></tr></table></figure><p><strong>19.dart给条件表达式所新引入的东西：?? ； 用法如下所示：expr1 ?? expr2，如果expr1是non-null的话，那么返回expr1的值，否则返回expr2的值。</strong></p><p><strong>20.级联运算符..，用于支撑起链式调用，但是这里和js里所出现的又有所区别，多加了一个点。</strong></p><p><strong>21.流程控制语句：assert，如果assert语句中的布尔条件为false的话，那么正常的程序执行流程会被打断。assert的参数是可以解析成布尔值的任何表达式，如果表达式为true的话，则断言成功，程序继续执行。注，assert语句只在开发环境中有效。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.使用var会自动进行类型推断，如果不想要类型推断的话，那么使用dynamic。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.dart没有关键字public,protected,private，如果标识符以_开头，则说明它相对于库是私有的。&lt;/st
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>express开发小结</title>
    <link href="http://yoursite.com/2019/01/02/express%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/02/express开发小结/</id>
    <published>2019-01-02T13:27:49.000Z</published>
    <updated>2019-01-03T14:03:14.536Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.mongoose.model.prototype.findOne是一个promise，应该await一下的，否则的话，执行之后所返回的结果总会是true。</strong></p><p><strong>2.一个问题，如果请求头里面没有带上Content-Type为application/json的话，那么在某些时候会出现一些不确定的情况。</strong></p><p><strong>3.对于下面这个操作会出错，最好try…catch一下</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  id = mongoose.Types.Object(id);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'非法id'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.mongoose.model.prototype.findOne是一个promise，应该await一下的，否则的话，执行之后所返回的结果总会是true。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.一个问题，如果请求头里面没有带上Content
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Express值请求体中间件解析</title>
    <link href="http://yoursite.com/2018/12/29/Express%E5%80%BC%E8%AF%B7%E6%B1%82%E4%BD%93%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/29/Express值请求体中间件解析/</id>
    <published>2018-12-29T05:55:40.000Z</published>
    <updated>2018-12-29T06:36:24.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.express请求体中间件有很多，比如说常见的body-parser,multer,formidable,这些中间件都各有各的应用场景,比如说body-parser很适合用来对application/x-www-form-urlencoded，application/json格式的表单请求做处理。multer中间件很适合对multipart/form-data的body，也就是说很适合处理文件上传。Formidable中间件可用于处理表单和上传文件，功能大而且全，既可以用来处理表单也能够用来处理上传文件。</strong></p><p><strong>2.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.express请求体中间件有很多，比如说常见的body-parser,multer,formidable,这些中间件都各有各的应用场景,比如说body-parser很适合用来对application/x-www-form-urlencoded，appli
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>express测试</title>
    <link href="http://yoursite.com/2018/12/28/express%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/12/28/express测试/</id>
    <published>2018-12-28T05:25:45.000Z</published>
    <updated>2018-12-28T10:04:55.253Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.测试API</strong></p><p>一个API基本上是一系列的代码块逻辑组成的，而对于mocha和chai来说，一般只是用来测试某个函数，所以就测试场景来说不是特别适合。因此有了Supertest，Supertest就不一样了，对于API测试来说，它会向server发送一个请求，自然的，server会对我们的请求作出响应，一旦做出了响应，那么我们便可以对响应进行断言，以此来测试响应数据是否正确。</p><p><strong>2.关键库supertest</strong></p><p>示例代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line"><span class="keyword">const</span> supertest = <span class="built_in">require</span>(<span class="string">'supertest'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'html test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    request = supertest(app)</span><br><span class="line">      .get(<span class="string">'/html'</span>)</span><br><span class="line">      .set(<span class="string">'User-Agent'</span>, <span class="string">'cool supertest'</span>)</span><br><span class="line">      .set(<span class="string">'Accept'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'return html response'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    request</span><br><span class="line">      .expect(<span class="string">'Content-Type'</span>, /text\/html/)</span><br><span class="line">      .expect(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> $ = cheerio.load(res.text);</span><br><span class="line">        <span class="keyword">let</span> domContent = $(query).text();                  <span class="comment">// 获取query处的content</span></span><br><span class="line">        <span class="keyword">if</span> (domContent !== <span class="string">'CONTENT_YOU_WANT'</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'content do not match'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .expect(<span class="number">200</span>)</span><br><span class="line">      .end(done);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.测试API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个API基本上是一系列的代码块逻辑组成的，而对于mocha和chai来说，一般只是用来测试某个函数，所以就测试场景来说不是特别适合。因此有了Supertest，Supertest就不一样了，对于API测试来说
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>flutter之widget基础</title>
    <link href="http://yoursite.com/2018/12/28/flutter%E4%B9%8Bwidget%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/28/flutter之widget基础/</id>
    <published>2018-12-27T16:36:20.000Z</published>
    <updated>2018-12-28T15:16:27.444Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.基础概念</strong></p><p>widget不仅只描述UI。widget是描述一个UI元素的配置数据；widget并不是绘制在屏幕的UI的抽象，那是Element，Widget只是描述Element的配置；一个Widget可以对应多个Element。</p><p>StatelessWidget适用于不需要维护状态的场景，通常在build方法中嵌套其它Widget来构建UI。</p><p>StatefulWidget继承自Widget类，并重写了createElement方法，而且还提供了一个新的接口createState。其中createState用于创建和Stateful widget相关的状态，如果一个stateful widget被插入到widget树的多个位置的话，那么flutter framework会调用该方法为每一个位置生成一个独立的state实例。</p><p><strong>2.State</strong></p><p>一个StatefulWidget类会对应一个State类，State表示的是其需要进行维护的状态。这些状态信息能够在widget build时被同步获取；State所维护的状态信息可以在widget的生命周期中被改变，当state发生变化后，可以手动调用setState来通知flutter状态发生了变化，flutter在收到通知后，会重新调用build方法构建widget树，从而达到更新UI的目的。</p><p>state有两个常用的属性，这里做个介绍：</p><ul><li><p>1.widget：表示和本State实例所关联的widget实例；由于State实例只会在widget第一次被插入到树中时被创建，所以State实例和widget的对应关系是动态化的，当重新构建的时候widget发生了变化的话，那么flutter会动态设置State实例的widget属性为新的widget实例；</p></li><li><p>2.context：BuildContext类的一个实例，表示构建widget的上下文。</p></li></ul><p><strong>3.Widget的生命周期</strong></p><ul><li>1.initState：当一个statewidget第一次被插入到widget树的时候会首先调用它，对于每一个state对象，flutter只会调用一次该回调，通常在这个回调中只会做一些一次性的动作。</li><li>2.didChangeDependencies</li><li>3.build</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.基础概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;widget不仅只描述UI。widget是描述一个UI元素的配置数据；widget并不是绘制在屏幕的UI的抽象，那是Element，Widget只是描述Element的配置；一个Widget可以对应多个Eleme
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
</feed>
